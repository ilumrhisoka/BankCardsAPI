================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\docker-compose.yml
================================================================================

services:
  postgres:
    image: postgres:16
    container_name: bank_postgres
    environment:
      POSTGRES_DB: ${DB_NAME}
      POSTGRES_USER: ${DB_USER}
      POSTGRES_PASSWORD: ${DB_PASSWORD}
    ports:
      - "5000:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    env_file:
      - .env
    healthcheck:
      test: [ "CMD-SHELL", "pg_isready -U ${DB_USER} -d ${DB_NAME}" ]
      interval: 5s
      timeout: 5s
      retries: 5

volumes:
  postgres_data:


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\pom.xml
================================================================================

<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.5.5</version>
        <relativePath/>
    </parent>
    <groupId>com.bank</groupId>
    <artifactId>test</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>test</name>
    <description>test</description>
    <url/>
    <licenses>
        <license/>
    </licenses>
    <developers>
        <developer/>
    </developers>
    <scm>
        <connection/>
        <developerConnection/>
        <tag/>
        <url/>
    </scm>
    <properties>
        <java.version>21</java.version>
        <mapstruct.version>1.5.5.Final</mapstruct.version>
        <lombok.version>1.18.30</lombok.version>
        <springdoc.version>2.8.10</springdoc.version>
        <jjwt.version>0.13.0</jjwt.version>
    </properties>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-thymeleaf</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
            <version>${springdoc.version}</version>
        </dependency>
        <dependency>
            <groupId>io.github.cdimascio</groupId>
            <artifactId>dotenv-java</artifactId>
            <version>3.2.0</version>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.liquibase</groupId>
            <artifactId>liquibase-core</artifactId>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>${jjwt.version}</version>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>${jjwt.version}</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>${jjwt.version}</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>org.mapstruct</groupId>
            <artifactId>mapstruct</artifactId>
            <version>${mapstruct.version}</version>
        </dependency>

        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
            <version>${lombok.version}</version>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>


        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>junit-jupiter</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-testcontainers</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>postgresql</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-thymeleaf</artifactId>
        </dependency>
        <dependency>
            <groupId>org.thymeleaf.extras</groupId>
            <artifactId>thymeleaf-extras-springsecurity6</artifactId>
        </dependency>
    </dependencies>

    <build>
        <plugins>

            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.11.0</version>
                <configuration>
                    <annotationProcessorPaths>
                        <path>
                            <groupId>org.mapstruct</groupId>
                            <artifactId>mapstruct-processor</artifactId>
                            <version>${mapstruct.version}</version>
                        </path>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                            <version>${lombok.version}</version>
                        </path>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok-mapstruct-binding</artifactId>
                            <version>0.1.0</version>
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
        </plugins>
    </build>

</project>


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\BankApplication.java
================================================================================

package com.example.bankcards;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class BankApplication {
    public static void main(String[] args) {
        SpringApplication.run(BankApplication.class, args);
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\controller\admin\AdminCardController.java
================================================================================

package com.example.bankcards.controller.admin;

import com.example.bankcards.exception.card.CardNotFoundException;
import com.example.bankcards.exception.card.CardStatusException;
import com.example.bankcards.exception.user.UserNotFoundException;
import com.example.bankcards.model.dto.card.CardCreateRequest;
import com.example.bankcards.model.dto.card.CardResponseDto;
import com.example.bankcards.model.dto.card.CardUpdateRequest;
import com.example.bankcards.exception.card.CardOwnershipException;
import com.example.bankcards.service.card.CardService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import com.example.bankcards.exception.dto.ErrorResponse;

/**
 * REST controller for managing bank cards by administrators.
 * This controller provides endpoints for creating, retrieving, updating, deleting,
 * blocking, and activating bank cards.
 * All operations require the authenticated user to have the 'ROLE_ADMIN' authority.
 */

@RestController
@RequestMapping("/api/admin/cards")
@RequiredArgsConstructor
@Tag(name = "Admin Card Management", description = "Operations related to managing bank cards by administrators")
@PreAuthorize("hasAuthority('ROLE_ADMIN')")
public class AdminCardController {

    private final CardService cardService;

    /**
     * Creates a new bank card with specified details.
     * This operation is accessible only by administrators.
     *
     * @param request The request body containing details for the new card, including user ID,
     *                card number, card holder name, expiry date, and initial balance.
     * @return A {@link ResponseEntity} containing the created card details
     *         ({@link CardResponseDto}) and HTTP status 201 (Created).
     * @throws UserNotFoundException (HTTP 404) if the user specified by {@code userId} in the request is not found.
     * @throws IllegalArgumentException (HTTP 400) if the card number in the request is invalid.
     * @throws CardOwnershipException (HTTP 403) if the authenticated user does not have 'ROLE_ADMIN' authority.
     */
    @Operation(summary = "Create a new bank card",
            description = "Allows administrators to create a new bank card with specified details.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "201", description = "Card created successfully",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = CardResponseDto.class))),
            @ApiResponse(responseCode = "400", description = "Invalid request body or data validation failed.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))), // Для общих ошибок валидации
            @ApiResponse(responseCode = "403", description = "Forbidden - Admin access required.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = CardOwnershipException.class))),
            @ApiResponse(responseCode = "404", description = "User not found for card creation.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = UserNotFoundException.class)))
    })
    @PostMapping
    public ResponseEntity<CardResponseDto> createCard(@Valid @RequestBody CardCreateRequest request){
        CardResponseDto card = cardService.createCard(request);
        return ResponseEntity.status(HttpStatus.CREATED).body(card);
    }

    /**
     * Retrieves a paginated list of all bank cards.
     * This operation is accessible only by administrators.
     *
     * @param pageable Pagination information (page number, size, sort order).
     * @return A {@link ResponseEntity} containing a {@link Page} of card details
     *         ({@link CardResponseDto}) and HTTP status 200 (OK).
     * @throws CardOwnershipException (HTTP 403) if the authenticated user does not have 'ROLE_ADMIN' authority.
     */
    @Operation(summary = "Get all bank cards with pagination",
            description = "Retrieves a paginated list of all bank cards. Only accessible by administrators.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Successfully retrieved list of cards",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = Page.class))),
            @ApiResponse(responseCode = "403", description = "Forbidden - Admin access required.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = CardOwnershipException.class)))
    })
    @GetMapping
    public ResponseEntity<Page<CardResponseDto>> getAllCards(Pageable pageable) {
        Page<CardResponseDto> cards = cardService.getAllCards(pageable);
        return ResponseEntity.ok(cards);
    }

    /**
     * Retrieves details of a specific bank card by its ID.
     * This operation is accessible only by administrators.
     *
     * @param id The ID of the card to retrieve.
     * @return A {@link ResponseEntity} containing the card details
     *         ({@link CardResponseDto}) and HTTP status 200 (OK).
     * @throws CardNotFoundException (HTTP 404) if no card is found with the given ID.
     * @throws CardOwnershipException (HTTP 403) if the authenticated user does not have 'ROLE_ADMIN' authority.
     */
    @Operation(summary = "Get a bank card by ID",
            description = "Retrieves details of a specific bank card by its ID. Only accessible by administrators.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Card found and retrieved successfully",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = CardResponseDto.class))),
            @ApiResponse(responseCode = "404", description = "Card not found with the given ID.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = CardNotFoundException.class))),
            @ApiResponse(responseCode = "403", description = "Forbidden - Admin access required.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = CardOwnershipException.class)))
    })
    @GetMapping("/{id}")
    public ResponseEntity<CardResponseDto> getCardById(@PathVariable Long id) {
        CardResponseDto card = cardService.getCardById(id);
        return ResponseEntity.ok(card);
    }

    /**
     * Updates details of an existing bank card by its ID.
     * This operation is accessible only by administrators.
     *
     * @param id The ID of the card to update.
     * @param request The request body containing updated card details.
     * @return A {@link ResponseEntity} containing the updated card details
     *         ({@link CardResponseDto}) and HTTP status 200 (OK).
     * @throws CardNotFoundException (HTTP 404) if no card is found with the given ID.
     * @throws CardOwnershipException (HTTP 403) if the authenticated user does not have 'ROLE_ADMIN' authority.
     */
    @Operation(summary = "Update an existing bank card",
            description = "Allows administrators to update details of an existing bank card by its ID.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Card updated successfully",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = CardResponseDto.class))),
            @ApiResponse(responseCode = "400", description = "Invalid request body or data validation failed.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))), // Для общих ошибок валидации
            @ApiResponse(responseCode = "404", description = "Card not found with the given ID.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = CardNotFoundException.class))),
            @ApiResponse(responseCode = "403", description = "Forbidden - Admin access required.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = CardOwnershipException.class)))
    })
    @PutMapping("/{id}")
    public ResponseEntity<CardResponseDto> updateCard(@PathVariable Long id,
                                                      @Valid @RequestBody CardUpdateRequest request) {
        CardResponseDto card = cardService.updateCard(id, request);
        return ResponseEntity.ok(card);
    }

    /**
     * Deletes a bank card permanently by its ID.
     * This operation is accessible only by administrators.
     *
     * @param id The ID of the card to delete.
     * @return A {@link ResponseEntity} with no content and HTTP status 204 (No Content)
     *         upon successful deletion.
     * @throws CardNotFoundException (HTTP 404) if no card is found with the given ID.
     * @throws CardOwnershipException (HTTP 403) if the authenticated user does not have 'ROLE_ADMIN' authority.
     */
    @Operation(summary = "Delete a bank card by ID",
            description = "Deletes a bank card permanently by its ID. Only accessible by administrators.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "204", description = "Card deleted successfully",
                    content = @Content(mediaType = "application/json")),
            @ApiResponse(responseCode = "404", description = "Card not found with the given ID.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = CardNotFoundException.class))),
            @ApiResponse(responseCode = "403", description = "Forbidden - Admin access required.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = CardOwnershipException.class)))
    })
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteCard(@PathVariable Long id) {
        cardService.deleteCard(id);
        return ResponseEntity.noContent().build();
    }

    /**
     * Blocks a specific bank card by its ID, preventing further transactions.
     * This operation is accessible only by administrators.
     *
     * @param id The ID of the card to block.
     * @return A {@link ResponseEntity} containing the blocked card details
     *         ({@link CardResponseDto}) and HTTP status 200 (OK).
     * @throws CardStatusException (HTTP 400) if the card is already blocked or cannot be blocked in its current state.
     * @throws CardNotFoundException (HTTP 404) if no card is found with the given ID.
     * @throws CardOwnershipException (HTTP 403) if the authenticated user does not have 'ROLE_ADMIN' authority.
     */
    @Operation(summary = "Block a bank card",
            description = "Blocks a specific bank card by its ID, preventing further transactions. Only accessible by administrators.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Card blocked successfully",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = CardResponseDto.class))),
            @ApiResponse(responseCode = "400", description = "Card is already blocked or cannot be blocked in its current state.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = CardStatusException.class))),
            @ApiResponse(responseCode = "404", description = "Card not found with the given ID.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = CardNotFoundException.class))),
            @ApiResponse(responseCode = "403", description = "Forbidden - Admin access required.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = CardOwnershipException.class)))
    })
    @PostMapping("/{id}/block")
    public ResponseEntity<CardResponseDto> blockCard(@PathVariable Long id) {
        CardResponseDto card = cardService.blockCard(id);
        return ResponseEntity.ok(card);
    }

    /**
     * Activates a previously blocked or inactive bank card by its ID.
     * This operation is accessible only by administrators.
     *
     * @param id The ID of the card to activate.
     * @return A {@link ResponseEntity} containing the activated card details
     *         ({@link CardResponseDto}) and HTTP status 200 (OK).
     * @throws CardStatusException (HTTP 400) if the card is already active or cannot be activated in its current state.
     * @throws CardNotFoundException (HTTP 404) if no card is found with the given ID.
     * @throws CardOwnershipException (HTTP 403) if the authenticated user does not have 'ROLE_ADMIN' authority.
     */
    @Operation(summary = "Activate a bank card",
            description = "Activates a previously blocked or inactive bank card by its ID. Only accessible by administrators.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Card activated successfully",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = CardResponseDto.class))),
            @ApiResponse(responseCode = "400", description = "Card is already active or cannot be activated in its current state.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = CardStatusException.class))),
            @ApiResponse(responseCode = "404", description = "Card not found with the given ID.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = CardNotFoundException.class))),
            @ApiResponse(responseCode = "403", description = "Forbidden - Admin access required.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = CardOwnershipException.class)))
    })
    @PostMapping("/{id}/activate")
    public ResponseEntity<CardResponseDto> activateCard(@PathVariable Long id) {
        CardResponseDto card = cardService.activateCard(id);
        return ResponseEntity.ok(card);
    }

    /**
     * Approves a pending block request for a specific bank card by its ID.
     * This operation is accessible only by administrators.
     *
     * @param id The ID of the card to approve blocking for.
     * @return A {@link ResponseEntity} containing the blocked card details
     *         ({@link CardResponseDto}) and HTTP status 200 (OK).
     * @throws CardStatusException (HTTP 400) if the card is not in PENDING_BLOCK state.
     * @throws CardNotFoundException (HTTP 404) if no card is found with the given ID.
     * @throws CardOwnershipException (HTTP 403) if the authenticated user does not have 'ROLE_ADMIN' authority.
     */
    @Operation(summary = "Approve a card block request",
            description = "Approves a pending block request for a specific bank card by its ID. Only accessible by administrators.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Card block request approved successfully",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = CardResponseDto.class))),
            @ApiResponse(responseCode = "400", description = "Card is not in PENDING_BLOCK state.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = CardStatusException.class))),
            @ApiResponse(responseCode = "404", description = "Card not found with the given ID.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = CardNotFoundException.class))),
            @ApiResponse(responseCode = "403", description = "Forbidden - Admin access required.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = CardOwnershipException.class)))
    })
    @PostMapping("/{id}/approve-block")
    public ResponseEntity<CardResponseDto> approveBlockRequest(@PathVariable Long id) {
        CardResponseDto card = cardService.approveBlockRequest(id);
        return ResponseEntity.ok(card);
    }

    /**
     * Approves a pending unblock request for a specific bank card by its ID.
     * This operation is accessible only by administrators.
     *
     * @param id The ID of the card to approve unblocking for.
     * @return A {@link ResponseEntity} containing the activated card details
     *         ({@link CardResponseDto}) and HTTP status 200 (OK).
     * @throws CardStatusException (HTTP 400) if the card is not in PENDING_UNBLOCK state.
     * @throws CardNotFoundException (HTTP 404) if no card is found with the given ID.
     * @throws CardOwnershipException (HTTP 403) if the authenticated user does not have 'ROLE_ADMIN' authority.
     */
    @Operation(summary = "Approve a card unblock request",
            description = "Approves a pending unblock request for a specific bank card by its ID. Only accessible by administrators.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Card unblock request approved successfully",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = CardResponseDto.class))),
            @ApiResponse(responseCode = "400", description = "Card is not in PENDING_UNBLOCK state.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = CardStatusException.class))),
            @ApiResponse(responseCode = "404", description = "Card not found with the given ID.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = CardNotFoundException.class))),
            @ApiResponse(responseCode = "403", description = "Forbidden - Admin access required.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = CardOwnershipException.class)))
    })
    @PostMapping("/{id}/approve-unblock")
    public ResponseEntity<CardResponseDto> approveUnblockRequest(@PathVariable Long id) {
        CardResponseDto card = cardService.approveUnblockRequest(id);
        return ResponseEntity.ok(card);
    }

    @PostMapping("/{id}/decline")
    public ResponseEntity<CardResponseDto> declineRequest(@PathVariable Long id) {
        CardResponseDto card = cardService.declineRequest(id);
        return ResponseEntity.ok(card);
    }

    @PostMapping("/{id}/deposit")
    public ResponseEntity<CardResponseDto> deposit(@PathVariable Long id, @RequestBody com.example.bankcards.model.dto.card.BalanceChangeRequest request) {
        CardResponseDto card = cardService.deposit(id, request.getAmount());
        return ResponseEntity.ok(card);
    }

    @PostMapping("/{id}/withdraw")
    public ResponseEntity<CardResponseDto> withdraw(@PathVariable Long id, @RequestBody com.example.bankcards.model.dto.card.BalanceChangeRequest request) {
        CardResponseDto card = cardService.withdraw(id, request.getAmount());
        return ResponseEntity.ok(card);
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\controller\admin\AdminSupportTicketController.java
================================================================================

package com.example.bankcards.controller.admin;

import com.example.bankcards.model.dto.ticket.TicketResponseDto;
import com.example.bankcards.service.support.SupportTicketService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * REST controller for administrative operations related to support tickets.
 * Access restricted to users with ROLE_ADMIN.
 */
@RestController
@RequestMapping("/api/admin/tickets")
@Tag(name = "Admin Support Ticket Management", description = "Operations for administrators to manage and process support tickets")
@RequiredArgsConstructor
@PreAuthorize("hasRole('ADMIN')")
public class AdminSupportTicketController {

    private final SupportTicketService ticketService;

    @Operation(summary = "Get all open and in-progress tickets")
    @GetMapping("/open")
    public ResponseEntity<List<TicketResponseDto>> getOpenTickets() {
        List<TicketResponseDto> tickets = ticketService.getOpenTickets();
        return ResponseEntity.ok(tickets);
    }

    @Operation(summary = "Assign a ticket to the currently authenticated admin")
    @PostMapping("/{ticketId}/assign")
    public ResponseEntity<TicketResponseDto> assignTicketToMe(
            @PathVariable Long ticketId,
            Authentication authentication) {

        String adminUsername = authentication.getName();
        TicketResponseDto assignedTicket = ticketService.assignTicket(ticketId, adminUsername);
        return ResponseEntity.ok(assignedTicket);
    }

    // В реальной системе может быть метод для назначения любому админу, но для простоты используем "назначить мне".

    @Operation(summary = "Close a specific ticket")
    @PostMapping("/{ticketId}/close")
    public ResponseEntity<TicketResponseDto> closeTicket(@PathVariable Long ticketId) {
        TicketResponseDto closedTicket = ticketService.closeTicket(ticketId);
        return ResponseEntity.ok(closedTicket);
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\controller\admin\AdminUserController.java
================================================================================

package com.example.bankcards.controller.admin;

import com.example.bankcards.exception.user.UserNotFoundException;
import com.example.bankcards.model.dto.user.UserResponseDto;
import com.example.bankcards.model.dto.user.UserUpdateRequest;
import com.example.bankcards.service.admin.AdminUserService;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import com.example.bankcards.exception.card.CardOwnershipException;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;

import com.example.bankcards.exception.dto.ErrorResponse;
import java.util.List;

/**
 * REST controller for managing users by administrators.
 * This controller provides endpoints for retrieving, updating, and deleting user accounts.
 * All operations require the authenticated user to have the 'ROLE_ADMIN' authority.
 */
@RestController
@RequestMapping("/api/admin/users")
@RequiredArgsConstructor
@Tag(name = "Admin User Management", description = "Operations related to managing users by administrators")
@PreAuthorize("hasAuthority('ROLE_ADMIN')")
public class AdminUserController {

    private final AdminUserService userService;

    /**
     * Retrieves a list of all registered users.
     * This operation is accessible only by administrators.
     *
     * @return A {@link ResponseEntity} containing a list of user details
     *         ({@link UserResponseDto}) and HTTP status 200 (OK).
     * @throws CardOwnershipException (HTTP 403) if the authenticated user does not have 'ROLE_ADMIN' authority.
     */
    @Operation(summary = "Get all users",
            description = "Retrieves a list of all registered users. Only accessible by administrators.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Successfully retrieved list of users",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = UserResponseDto.class))),
            @ApiResponse(responseCode = "403", description = "Forbidden - Admin access required.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = CardOwnershipException.class)))
    })
    @GetMapping
    public ResponseEntity<List<UserResponseDto>> getAllUsers() {
        List<UserResponseDto> users = userService.getAllUsers();
        return ResponseEntity.ok(users);
    }

    /**
     * Retrieves details of a specific user by their ID.
     * This operation is accessible only by administrators.
     *
     * @param id The ID of the user to retrieve.
     * @return A {@link ResponseEntity} containing the user details
     *         ({@link UserResponseDto}) and HTTP status 200 (OK).
     * @throws UserNotFoundException (HTTP 404) if no user is found with the given ID.
     * @throws CardOwnershipException (HTTP 403) if the authenticated user does not have 'ROLE_ADMIN' authority.
     */
    @Operation(summary = "Get user by ID",
            description = "Retrieves details of a specific user by their ID. Only accessible by administrators.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "User found and retrieved successfully",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = UserResponseDto.class))),
            @ApiResponse(responseCode = "403", description = "Forbidden - Admin access required.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = CardOwnershipException.class))),
            @ApiResponse(responseCode = "404", description = "User not found with the given ID.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = UserNotFoundException.class)))
    })
    @GetMapping("/{id}")
    public ResponseEntity<UserResponseDto> getUserById(@PathVariable Long id) {
        UserResponseDto user = userService.getUserById(id);
        return ResponseEntity.ok(user);
    }

    /**
     * Allows administrators to update details of an existing user by their ID.
     *
     * @param id The ID of the user to update.
     * @param request The request body containing updated user details.
     * @return A {@link ResponseEntity} containing the updated user details
     *         ({@link UserResponseDto}) and HTTP status 200 (OK).
     * @throws UserNotFoundException (HTTP 404) if no user is found with the given ID.
     * @throws CardOwnershipException (HTTP 403) if the authenticated user does not have 'ROLE_ADMIN' authority.
     */
    @Operation(summary = "Update user details",
            description = "Allows administrators to update details of an existing user by their ID.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "User updated successfully",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = UserResponseDto.class))),
            @ApiResponse(responseCode = "400", description = "Invalid request body or data validation failed.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))), // Для общих ошибок валидации
            @ApiResponse(responseCode = "403", description = "Forbidden - Admin access required.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = CardOwnershipException.class))),
            @ApiResponse(responseCode = "404", description = "User not found with the given ID.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = UserNotFoundException.class)))
    })
    @PutMapping("/{id}")
    public ResponseEntity<UserResponseDto> updateUser(@PathVariable Long id,
                                                      @Valid @RequestBody UserUpdateRequest request) {
        UserResponseDto updatedUser = userService.updateUser(id, request);
        return ResponseEntity.ok(updatedUser);
    }

    /**
     * Deletes a user permanently by their ID.
     * This operation is accessible only by administrators.
     *
     * @param id The ID of the user to delete.
     * @return A {@link ResponseEntity} with no content and HTTP status 204 (No Content)
     *         upon successful deletion.
     * @throws UserNotFoundException (HTTP 404) if no user is found with the given ID.
     * @throws CardOwnershipException (HTTP 403) if the authenticated user does not have 'ROLE_ADMIN' authority.
     */
    @Operation(summary = "Delete a user",
            description = "Deletes a user permanently by their ID. Only accessible by administrators.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "204", description = "User deleted successfully",
                    content = @Content(mediaType = "application/json")),
            @ApiResponse(responseCode = "403", description = "Forbidden - Admin access required.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = CardOwnershipException.class))),
            @ApiResponse(responseCode = "404", description = "User not found with the given ID.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = UserNotFoundException.class)))
    })
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteUser(@PathVariable Long id) {
        userService.deleteUser(id);
        return ResponseEntity.status(HttpStatus.NO_CONTENT).build();
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\controller\auth\AuthController.java
================================================================================

package com.example.bankcards.controller.auth;

import com.example.bankcards.exception.user.DuplicateUsernameException;
import com.example.bankcards.model.dto.auth.AuthResponseDto;
import com.example.bankcards.model.dto.auth.LoginRequest;
import com.example.bankcards.model.dto.auth.RefreshRequest;
import com.example.bankcards.model.dto.auth.RegisterRequest;
import com.example.bankcards.model.entity.User;
import com.example.bankcards.repository.UserRepository;
import com.example.bankcards.security.JwtUtil;
import com.example.bankcards.service.auth.AuthService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.Optional;

@RestController
@RequestMapping("/api/auth")
@Tag(name = "Authentication", description = "User authentication and registration operations")
@RequiredArgsConstructor
public class AuthController {

    private final AuthService authService;
    private final UserRepository userRepository;
    private final JwtUtil jwtUtil;

    private void setAccessTokenCookie(HttpServletResponse response, String token) {
        int maxAgeSeconds = (int) (jwtUtil.getAccessTokenExpiration() / 1000);
        Cookie cookie = new Cookie("accessToken", token);
        cookie.setHttpOnly(true);
        cookie.setSecure(false); // true для HTTPS
        cookie.setPath("/");
        cookie.setMaxAge(maxAgeSeconds);
        response.addCookie(cookie);
    }

    @Operation(summary = "User login")
    @PostMapping("/login")
    public ResponseEntity<?> login(@Valid @RequestBody LoginRequest loginRequest, HttpServletResponse response) {
        AuthResponseDto authResponse = authService.login(loginRequest.getUsername(), loginRequest.getPassword());
        setAccessTokenCookie(response, authResponse.getAccessToken());
        return ResponseEntity.ok(authResponse);
    }

    @Operation(summary = "User registration")
    @PostMapping("/register")
    public ResponseEntity<?> register(@Valid @RequestBody RegisterRequest registerRequest, HttpServletResponse response) {
        Optional<User> registeredUser = userRepository.findByUsername(registerRequest.getUsername());
        if(registeredUser.isPresent()) {
            throw new DuplicateUsernameException("Username " + registerRequest.getUsername()+ " already exists");
        }
        AuthResponseDto user = authService.register(
                registerRequest.getUsername(),
                registerRequest.getEmail(),
                registerRequest.getPassword()
        );
        setAccessTokenCookie(response, user.getAccessToken());
        return ResponseEntity.status(HttpStatus.CREATED).body(user);
    }

    @Operation(summary = "Refresh access token")
    @PostMapping("/refresh-token")
    public ResponseEntity<?> refreshToken(@Valid @RequestBody RefreshRequest refreshRequest, HttpServletResponse response) {
        String refreshToken = refreshRequest.getRefreshToken();
        if (refreshToken == null) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(null);
        }
        AuthResponseDto authResponse = authService.refreshAccessToken(refreshToken);
        setAccessTokenCookie(response, authResponse.getAccessToken());
        return ResponseEntity.ok(authResponse);
    }

    // НОВЫЙ МЕТОД ДЛЯ ВЫХОДА
    @PostMapping("/logout")
    public ResponseEntity<?> logout(HttpServletResponse response) {
        Cookie cookie = new Cookie("accessToken", null);
        cookie.setHttpOnly(true);
        cookie.setSecure(false);
        cookie.setPath("/");
        cookie.setMaxAge(0); // Удаляем куку
        response.addCookie(cookie);
        return ResponseEntity.ok("Logged out successfully");
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\controller\user\AccountController.java
================================================================================

package com.example.bankcards.controller.user;

import com.example.bankcards.model.dto.account.AccountCreateRequest;
import com.example.bankcards.model.dto.account.AccountResponseDto;
import com.example.bankcards.model.dto.fee.ServiceFeeResponseDto;
import com.example.bankcards.service.account.AccountService;
import com.example.bankcards.service.fee.ServiceFeeService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.math.BigDecimal;
import java.util.List;

/**
 * REST controller for managing user's bank accounts.
 * All operations require the authenticated user.
 */
@RestController
@RequestMapping("/api/user/accounts")
@Tag(name = "User Account Management", description = "Operations related to managing user's bank accounts and associated fees")
@RequiredArgsConstructor
public class AccountController {

    private final AccountService accountService;
    private final ServiceFeeService serviceFeeService; // NEW: Интеграция сервиса комиссий

    /**
     * Creates a new bank account for the authenticated user.
     *
     * @param request The request containing account type.
     * @param authentication The authentication object.
     * @return The created account details.
     */
    @Operation(summary = "Create a new bank account")
    @PostMapping
    public ResponseEntity<AccountResponseDto> createAccount(
            @Valid @RequestBody AccountCreateRequest request,
            Authentication authentication) {

        String username = authentication.getName();
        AccountResponseDto newAccount = accountService.createAccount(request, username);
        return new ResponseEntity<>(newAccount, HttpStatus.CREATED);
    }

    /**
     * Retrieves a list of all bank accounts owned by the authenticated user.
     *
     * @param authentication The authentication object.
     * @return List of account details.
     */
    @Operation(summary = "Get all accounts for the current user")
    @GetMapping
    public ResponseEntity<List<AccountResponseDto>> getMyAccounts(Authentication authentication) {
        String username = authentication.getName();
        List<AccountResponseDto> accounts = accountService.getMyAccounts(username);
        return ResponseEntity.ok(accounts);
    }

    /**
     * Retrieves the total balance across all accounts owned by the authenticated user.
     *
     * @param authentication The authentication object.
     * @return Total balance.
     */
    @Operation(summary = "Get total balance across all user accounts")
    @GetMapping("/total-balance")
    public ResponseEntity<BigDecimal> getTotalBalance(Authentication authentication) {
        String username = authentication.getName();
        BigDecimal totalBalance = accountService.getTotalBalanceAcrossAccounts(username);
        return ResponseEntity.ok(totalBalance);
    }

    /**
     * Retrieves all fees associated with the authenticated user's accounts.
     */
    @Operation(summary = "Get all service fees charged to user's accounts")
    @GetMapping("/fees")
    public ResponseEntity<List<ServiceFeeResponseDto>> getMyFees(Authentication authentication) {
        String username = authentication.getName();
        List<ServiceFeeResponseDto> fees = serviceFeeService.getMyFees(username);
        return ResponseEntity.ok(fees);
    }

    /**
     * Retrieves all unpaid fees for a specific account.
     */
    @Operation(summary = "Get unpaid fees for a specific account")
    @GetMapping("/{accountId}/unpaid-fees")
    public ResponseEntity<List<ServiceFeeResponseDto>> getUnpaidFees(
            @PathVariable Long accountId,
            Authentication authentication) {
        String username = authentication.getName();
        List<ServiceFeeResponseDto> fees = serviceFeeService.getUnpaidFeesForAccount(accountId, username);
        return ResponseEntity.ok(fees);
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\controller\user\NotificationController.java
================================================================================

package com.example.bankcards.controller.user;

import com.example.bankcards.model.dto.notification.NotificationResponseDto;
import com.example.bankcards.service.notification.NotificationService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * REST controller for managing user notifications.
 */
@RestController
@RequestMapping("/api/user/notifications")
@Tag(name = "User Notifications", description = "Operations related to viewing and managing user notifications")
@RequiredArgsConstructor
public class NotificationController {

    private final NotificationService notificationService;

    @Operation(summary = "Get all notifications for the current user")
    @GetMapping
    public ResponseEntity<List<NotificationResponseDto>> getAllNotifications(Authentication authentication) {
        String username = authentication.getName();
        List<NotificationResponseDto> notifications = notificationService.getMyNotifications(username);
        return ResponseEntity.ok(notifications);
    }

    @Operation(summary = "Get only unread notifications")
    @GetMapping("/unread")
    public ResponseEntity<List<NotificationResponseDto>> getUnreadNotifications(Authentication authentication) {
        String username = authentication.getName();
        List<NotificationResponseDto> notifications = notificationService.getUnreadNotifications(username);
        return ResponseEntity.ok(notifications);
    }

    @Operation(summary = "Mark a specific notification as read")
    @PostMapping("/{notificationId}/read")
    public ResponseEntity<Void> markNotificationAsRead(
            @PathVariable Long notificationId,
            Authentication authentication) {
        String username = authentication.getName();
        notificationService.markAsRead(notificationId, username);
        return ResponseEntity.ok().build();
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\controller\user\QuickTransferController.java
================================================================================

package com.example.bankcards.controller.user;

import com.example.bankcards.exception.user.UserNotFoundException;
import com.example.bankcards.model.dto.user.QuickTransferDto;
import com.example.bankcards.model.entity.QuickTransfer;
import com.example.bankcards.model.entity.User;
import com.example.bankcards.repository.QuickTransferRepository;
import com.example.bankcards.repository.UserRepository;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/user/quick-transfers")
@RequiredArgsConstructor
@Tag(name = "Quick Transfers", description = "Manage favorite contacts")
public class QuickTransferController {

    private final QuickTransferRepository quickTransferRepository;
    private final UserRepository userRepository;

    @GetMapping
    public ResponseEntity<List<QuickTransferDto>> getAll(Authentication authentication) {
        List<QuickTransfer> list = quickTransferRepository.findByUserUsername(authentication.getName());
        List<QuickTransferDto> dtos = list.stream().map(qt -> {
            QuickTransferDto dto = new QuickTransferDto();
            dto.setId(qt.getId());
            dto.setName(qt.getName());
            dto.setCardNumber(qt.getCardNumber());
            return dto;
        }).collect(Collectors.toList());
        return ResponseEntity.ok(dtos);
    }

    @PostMapping
    @Transactional
    public ResponseEntity<QuickTransferDto> create(@RequestBody QuickTransferDto request, Authentication authentication) {
        User user = userRepository.findByUsername(authentication.getName())
                .orElseThrow(() -> new UserNotFoundException("User not found"));

        QuickTransfer qt = new QuickTransfer();
        qt.setUser(user);
        qt.setName(request.getName());
        qt.setCardNumber(request.getCardNumber());

        QuickTransfer saved = quickTransferRepository.save(qt);

        request.setId(saved.getId());
        return ResponseEntity.ok(request);
    }

    @DeleteMapping("/{id}")
    @Transactional
    public ResponseEntity<Void> delete(@PathVariable Long id, Authentication authentication) {
        QuickTransfer qt = quickTransferRepository.findById(id).orElse(null);
        if (qt != null && qt.getUser().getUsername().equals(authentication.getName())) {
            quickTransferRepository.delete(qt);
        }
        return ResponseEntity.ok().build();
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\controller\user\SupportTicketController.java
================================================================================

package com.example.bankcards.controller.user;

import com.example.bankcards.model.dto.ticket.TicketCreateRequest;
import com.example.bankcards.model.dto.ticket.TicketResponseDto;
import com.example.bankcards.service.support.SupportTicketService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * REST controller for user interaction with the support ticket system.
 */
@RestController
@RequestMapping("/api/user/tickets")
@Tag(name = "User Support Tickets", description = "Operations for creating and viewing user support tickets")
@RequiredArgsConstructor
public class SupportTicketController {

    private final SupportTicketService ticketService;

    @Operation(summary = "Create a new support ticket")
    @PostMapping
    public ResponseEntity<TicketResponseDto> createTicket(
            @Valid @RequestBody TicketCreateRequest request,
            Authentication authentication) {
        String username = authentication.getName();
        TicketResponseDto newTicket = ticketService.createTicket(request, username);
        return new ResponseEntity<>(newTicket, HttpStatus.CREATED);
    }

    @Operation(summary = "Get all support tickets created by the current user")
    @GetMapping
    public ResponseEntity<List<TicketResponseDto>> getMyTickets(Authentication authentication) {
        String username = authentication.getName();
        List<TicketResponseDto> tickets = ticketService.getMyTickets(username);
        return ResponseEntity.ok(tickets);
    }

    @Operation(summary = "Get details of a specific ticket")
    @GetMapping("/{ticketId}")
    public ResponseEntity<TicketResponseDto> getTicketById(
            @PathVariable Long ticketId,
            Authentication authentication) {
        String username = authentication.getName();
        TicketResponseDto ticket = ticketService.getTicketById(ticketId, username);
        return ResponseEntity.ok(ticket);
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\controller\user\TransferController.java
================================================================================

package com.example.bankcards.controller.user;

import com.example.bankcards.exception.card.CardNotFoundException;
import com.example.bankcards.exception.card.CardStatusException;
import com.example.bankcards.exception.card.InsufficientFundsException;
import com.example.bankcards.exception.transfer.InvalidTransferException;
import com.example.bankcards.exception.transfer.TransferNotFoundException;
import com.example.bankcards.model.dto.transfer.TransferRequest;
import com.example.bankcards.model.dto.transfer.TransferResponseDto;
import com.example.bankcards.service.transfer.TransferService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import com.example.bankcards.exception.card.CardOwnershipException;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;


import jakarta.validation.Valid;
import java.util.List;

/**
 * REST controller for managing user's money transfers.
 * This controller provides endpoints for creating transfers, retrieving transfers
 * for the authenticated user, and retrieving transfers for a specific card owned by the user.
 * All operations require the authenticated user to have the 'ROLE_USER' authority.
 */
@RestController
@RequestMapping("/api/user/transfers")
@RequiredArgsConstructor
@Tag(name = "User Transfers", description = "Operations related to managing user's money transfers")
public class TransferController {

    private final TransferService transferService;

    /**
     * Allows an authenticated user to initiate a new money transfer between cards.
     *
     * @param request The request body containing details for the transfer, including
     *                source card ID, destination card number, and amount.
     * @param authentication The authentication object containing the current user's details.
     * @return A {@link ResponseEntity} containing the created transfer details
     *         ({@link TransferResponseDto}) and HTTP status 201 (Created).
     * @throws InvalidTransferException (HTTP 400) if attempting to transfer to the same card.
     * @throws InsufficientFundsException (HTTP 400) if the source card has insufficient funds.
     * @throws CardStatusException (HTTP 400) if the source or destination card is not active.
     * @throws CardOwnershipException (HTTP 403) if the authenticated user does not have 'ROLE_USER' authority
     *         or if the source card does not belong to the user.
     * @throws CardNotFoundException (HTTP 404) if the source or destination card is not found.
     */
    @Operation(summary = "Create a new money transfer",
            description = "Allows an authenticated user to initiate a new money transfer between cards.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "201", description = "Transfer created successfully",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = TransferResponseDto.class))),
            @ApiResponse(responseCode = "400", description = "Invalid transfer request (e.g., same card, inactive card, insufficient funds).",
                    content = @Content(mediaType = "application/json", schema = @Schema(oneOf = {InvalidTransferException.class, InsufficientFundsException.class, CardStatusException.class}))),
            @ApiResponse(responseCode = "403", description = "Forbidden - User access required or card does not belong to the user.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = CardOwnershipException.class))),
            @ApiResponse(responseCode = "404", description = "Source or destination card not found.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = CardNotFoundException.class)))
    })
    @PostMapping
    public ResponseEntity<TransferResponseDto> createTransfer(@Valid @RequestBody TransferRequest request,
                                                              Authentication authentication) {
        String username = authentication.getName();
        TransferResponseDto transfer = transferService.createTransfer(request, username);
        return ResponseEntity.status(HttpStatus.CREATED).body(transfer);
    }

    /**
     * Retrieves a list of all money transfers initiated by or received by the authenticated user.
     *
     * @param authentication The authentication object containing the current user's details.
     * @return A {@link ResponseEntity} containing a list of transfer details
     *         ({@link TransferResponseDto}) and HTTP status 200 (OK).
     * @throws CardOwnershipException (HTTP 403) if the authenticated user does not have 'ROLE_USER' authority.
     */
    @Operation(summary = "Get all transfers for the current user",
            description = "Retrieves a list of all money transfers initiated by or received by the authenticated user.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Successfully retrieved list of transfers",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = TransferResponseDto.class))),
            @ApiResponse(responseCode = "403", description = "Forbidden - User access required.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = CardOwnershipException.class)))
    })
    @GetMapping("/my")
    public ResponseEntity<List<TransferResponseDto>> getMyTransfers(Authentication authentication) {
        String username = authentication.getName();
        List<TransferResponseDto> transfers = transferService.getUserTransfers(username);
        return ResponseEntity.ok(transfers);
    }

    /**
     * Retrieves a list of transfers associated with a specific card owned by the authenticated user.
     *
     * @param cardId The ID of the card for which to retrieve transfers.
     * @param authentication The authentication object containing the current user's details.
     * @return A {@link ResponseEntity} containing a list of transfer details
     *         ({@link TransferResponseDto}) and HTTP status 200 (OK).
     * @throws CardOwnershipException (HTTP 403) if the card does not belong to the user or user access is required.
     * @throws CardNotFoundException (HTTP 404) if the card is not found with the given ID.
     */
    @Operation(summary = "Get transfers for a specific card",
            description = "Retrieves a list of transfers associated with a specific card owned by the authenticated user.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Successfully retrieved list of card transfers",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = TransferResponseDto.class))),
            @ApiResponse(responseCode = "403", description = "Forbidden - Card does not belong to user or user access required.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = CardOwnershipException.class))),
            @ApiResponse(responseCode = "404", description = "Card not found with the given ID.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = CardNotFoundException.class)))
    })
    @GetMapping("/card/{cardId}")
    public ResponseEntity<List<TransferResponseDto>> getCardTransfers(@PathVariable Long cardId,
                                                                      Authentication authentication) {
        String username = authentication.getName();
        List<TransferResponseDto> transfers = transferService.getCardTransfers(cardId, username);
        return ResponseEntity.ok(transfers);
    }

    /**
     * Retrieves details of a specific transfer by its ID, if it belongs to the authenticated user.
     *
     * @param transferId The ID of the transfer to retrieve.
     * @param authentication The authentication object containing the current user's details.
     * @return A {@link ResponseEntity} containing the transfer details
     *         ({@link TransferResponseDto}) and HTTP status 200 (OK).
     * @throws CardOwnershipException (HTTP 403) if the transfer is not associated with the user.
     * @throws TransferNotFoundException (HTTP 404) if the transfer is not found with the given ID.
     */
    @Operation(summary = "Get a specific transfer by ID",
            description = "Retrieves details of a specific transfer by its ID, if it belongs to the authenticated user.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Transfer found and retrieved successfully",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = TransferResponseDto.class))),
            @ApiResponse(responseCode = "403", description = "Forbidden - Transfer not associated with user or user access required.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = CardOwnershipException.class))),
            @ApiResponse(responseCode = "404", description = "Transfer not found with the given ID.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = TransferNotFoundException.class)))
    })
    @GetMapping("/{transferId}")
    public ResponseEntity<TransferResponseDto> getTransfer(@PathVariable Long transferId,
                                                           Authentication authentication) {
        String username = authentication.getName();
        TransferResponseDto transfer = transferService.getTransfer(transferId, username);
        return ResponseEntity.ok(transfer);
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\controller\user\UserCardController.java
================================================================================

package com.example.bankcards.controller.user;

import com.example.bankcards.exception.card.CardNotFoundException;
import com.example.bankcards.exception.card.CardStatusException;
import com.example.bankcards.model.dto.card.CardResponseDto;
import com.example.bankcards.service.card.UserCardService;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.ResponseEntity;
import com.example.bankcards.exception.card.CardOwnershipException;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;

import java.math.BigDecimal;

/**
 * REST controller for managing user's bank cards.
 * This controller provides endpoints for retrieving user's cards, blocking/unblocking requests,
 * and getting the total balance across all user cards.
 * All operations require the authenticated user.
 */
@RestController
@RequestMapping("/api/user/cards")
@Tag(name = "User Card Management", description = "Operations related to managing user's bank cards")
@RequiredArgsConstructor
public class UserCardController {
    private final UserCardService userCardService;

    /**
     * Retrieves a paginated list of all bank cards owned by the authenticated user.
     *
     * @param authentication The authentication object containing the current user's details.
     * @param pageable Pagination information (page number, size, sort order).
     * @return A {@link ResponseEntity} containing a {@link Page} of card details
     *         ({@link CardResponseDto}) and HTTP status 200 (OK).
     * @throws CardOwnershipException (HTTP 403) if the authenticated user does not have required access.
     */
    @Operation(summary = "Get all cards for the current user with pagination",
            description = "Retrieves a paginated list of all bank cards owned by the authenticated user.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Successfully retrieved list of user cards",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = Page.class))),
            @ApiResponse(responseCode = "403", description = "Forbidden - User access required.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = CardOwnershipException.class)))
    })
    @GetMapping
    public ResponseEntity<Page<CardResponseDto>> getUserCards(Authentication authentication, Pageable pageable) {
        String username = authentication.getName();
        Page<CardResponseDto> cards = userCardService.getUserCards(username, pageable);
        return ResponseEntity.ok(cards);
    }

    /**
     * Retrieves details of a specific bank card by its ID, if it belongs to the authenticated user.
     *
     * @param cardId The ID of the card to retrieve.
     * @param authentication The authentication object containing the current user's details.
     * @return A {@link ResponseEntity} containing the card details
     *         ({@link CardResponseDto}) and HTTP status 200 (OK).
     * @throws CardOwnershipException (HTTP 403) if the card does not belong to the user or user access is required.
     * @throws CardNotFoundException (HTTP 404) if no card is found with the given ID.
     */
    @Operation(summary = "Get a specific card by ID",
            description = "Retrieves details of a specific bank card by its ID, if it belongs to the authenticated user.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Card found and retrieved successfully",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = CardResponseDto.class))),
            @ApiResponse(responseCode = "403", description = "Forbidden - Card does not belong to user or user access required.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = CardOwnershipException.class))),
            @ApiResponse(responseCode = "404", description = "Card not found with the given ID.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = CardNotFoundException.class)))
    })
    @GetMapping("/{cardId}")
    public ResponseEntity<CardResponseDto> getCardById(@PathVariable Long cardId,
                                                       Authentication authentication) {
        String username = authentication.getName();
        CardResponseDto card = userCardService.getUserCardById(cardId, username);
        return ResponseEntity.ok(card);
    }

    /**
     * Submits a request to block a specific card owned by the authenticated user.
     * The actual blocking might be an asynchronous process or require admin approval.
     *
     * @param cardId The ID of the card to request blocking for.
     * @param authentication The authentication object containing the current user's details.
     * @return A {@link ResponseEntity} with no content and HTTP status 200 (OK) upon successful request submission.
     * @throws CardStatusException (HTTP 400) if the card is already blocked or in a pending block state.
     * @throws CardOwnershipException (HTTP 403) if the card does not belong to the user or user access is required.
     * @throws CardNotFoundException (HTTP 404) if no card is found with the given ID.
     */
    @Operation(summary = "Request to block a card",
            description = "Submits a request to block a specific card owned by the authenticated user. The actual blocking might be an asynchronous process or require admin approval.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Card block request submitted successfully",
                    content = @Content(mediaType = "application/json")),
            @ApiResponse(responseCode = "400", description = "Card is already blocked or a block request is pending.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = CardStatusException.class))),
            @ApiResponse(responseCode = "403", description = "Forbidden - Card does not belong to user or user access required.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = CardOwnershipException.class))),
            @ApiResponse(responseCode = "404", description = "Card not found with the given ID.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = CardNotFoundException.class)))
    })
    @PostMapping("/block/{cardId}")
    public ResponseEntity<?> requestBlockCard(@PathVariable Long cardId,
                                              Authentication authentication) {
        String username = authentication.getName();
        userCardService.requestBlock(cardId, username);
        return ResponseEntity.ok().build();
    }

    /**
     * Submits a request to unblock a specific card owned by the authenticated user.
     * The actual unblocking might be an asynchronous process or require admin approval.
     *
     * @param cardId The ID of the card to request unblocking for.
     * @param authentication The authentication object containing the current user's details.
     * @return A {@link ResponseEntity} with no content and HTTP status 200 (OK) upon successful request submission.
     * @throws CardStatusException (HTTP 400) if the card is already active or in a pending unblock state.
     * @throws CardOwnershipException (HTTP 403) if the card does not belong to the user or user access is required.
     * @throws CardNotFoundException (HTTP 404) if no card is found with the given ID.
     */
    @Operation(summary = "Request to unblock a card",
            description = "Submits a request to unblock a specific card owned by the authenticated user. The actual unblocking might be an asynchronous process or require admin approval.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Card unblock request submitted successfully",
                    content = @Content(mediaType = "application/json")),
            @ApiResponse(responseCode = "400", description = "Card is already active or an unblock request is pending.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = CardStatusException.class))),
            @ApiResponse(responseCode = "403", description = "Forbidden - Card does not belong to user or user access required.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = CardOwnershipException.class))),
            @ApiResponse(responseCode = "404", description = "Card not found with the given ID.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = CardNotFoundException.class)))
    })
    @PostMapping("/unblock/{cardId}")
    public ResponseEntity<?> requestUnblockCard(@PathVariable Long cardId,
                                                Authentication authentication) {
        String username = authentication.getName();
        userCardService.requestUnblock(cardId, username);
        return ResponseEntity.ok().build();
    }

    /**
     * Retrieves the sum of balances from all bank cards owned by the authenticated user.
     *
     * @param authentication The authentication object containing the current user's details.
     * @return A {@link ResponseEntity} containing the total balance as a {@link BigDecimal}
     *         and HTTP status 200 (OK).
     * @throws CardOwnershipException (HTTP 403) if the authenticated user does not have required access.
     */
    @Operation(summary = "Get total balance across all user cards",
            description = "Retrieves the sum of balances from all bank cards owned by the authenticated user.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Total balance retrieved successfully",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = BigDecimal.class))),
            @ApiResponse(responseCode = "403", description = "Forbidden - User access required.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = CardOwnershipException.class)))
    })
    @GetMapping("/balance")
    public ResponseEntity<BigDecimal> getBalance(Authentication authentication) {
        String username = authentication.getName();
        BigDecimal balance = userCardService.getTotalBalance(username);
        return ResponseEntity.ok(balance);
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\controller\user\UserProfileController.java
================================================================================

package com.example.bankcards.controller.user;

import com.example.bankcards.exception.user.UserNotFoundException;
import com.example.bankcards.model.dto.user.UserResponseDto;
import com.example.bankcards.model.entity.User;
import com.example.bankcards.repository.UserRepository;
import com.example.bankcards.util.mapper.UserMapper;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.Data;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.bind.annotation.*;

import java.math.BigDecimal;

@RestController
@RequestMapping("/api/user/profile")
@RequiredArgsConstructor
@Tag(name = "User Profile", description = "Profile management and settings")
public class UserProfileController {

    private final UserRepository userRepository;
    private final UserMapper userMapper;

    @Operation(summary = "Get current user profile")
    @GetMapping
    public ResponseEntity<UserResponseDto> getMyProfile(Authentication authentication) {
        String username = authentication.getName();
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new UserNotFoundException("User not found"));
        return ResponseEntity.ok(userMapper.toUserResponseDto(user));
    }

    @Operation(summary = "Update monthly spending limit")
    @PostMapping("/limit")
    @Transactional
    public ResponseEntity<UserResponseDto> updateLimit(@RequestBody LimitUpdateRequest request, Authentication authentication) {
        String username = authentication.getName();
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new UserNotFoundException("User not found"));

        if (request.getLimit().compareTo(BigDecimal.ZERO) < 0) {
            throw new IllegalArgumentException("Limit cannot be negative");
        }

        user.setMonthlyLimit(request.getLimit());
        userRepository.save(user);

        return ResponseEntity.ok(userMapper.toUserResponseDto(user));
    }

    @Data
    public static class LimitUpdateRequest {
        private BigDecimal limit;
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\controller\WebController.java
================================================================================

package com.example.bankcards.controller;

import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;

@Controller
public class WebController {

    private Authentication getCurrentAuthentication() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.isAuthenticated() && !"anonymousUser".equals(authentication.getPrincipal())) {
            return authentication;
        }
        return null;
    }

    private boolean hasRole(Authentication authentication, String role) {
        if (authentication == null) return false;
        return authentication.getAuthorities().stream()
                .map(GrantedAuthority::getAuthority)
                .anyMatch(role::equals);
    }

    @GetMapping("/")
    public String index() {
        Authentication authentication = getCurrentAuthentication();
        if (authentication != null) {
            if (hasRole(authentication, "ROLE_ADMIN")) {
                return "redirect:/admin/dashboard";
            }
            return "redirect:/dashboard";
        }
        return "redirect:/login";
    }

    @GetMapping("/login")
    public String login() {
        Authentication authentication = getCurrentAuthentication();
        if (authentication != null) {
            return "redirect:/";
        }
        return "login";
    }

    @GetMapping("/register")
    public String register() {
        Authentication authentication = getCurrentAuthentication();
        if (authentication != null) {
            return "redirect:/";
        }
        return "register";
    }

    @GetMapping("/dashboard")
    public String dashboard() {
        return "dashboard";
    }

    @GetMapping("/admin/dashboard")
    public String adminDashboard() {
        return "admin_dashboard";
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\exception\account\AccountNotFoundException.java
================================================================================

package com.example.bankcards.exception.account;

import com.example.bankcards.exception.dto.ResourceNotFoundException;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

/**
 * Exception thrown when a requested card is not found.
 * This exception maps to an HTTP 404 Not Found status.
 */
@ResponseStatus(HttpStatus.NOT_FOUND)
public class AccountNotFoundException extends ResourceNotFoundException {

    /**
     * Constructs a new CardNotFoundException with the specified detail message.
     *
     * @param message the detail message (which is saved for later retrieval by the {@link Throwable#getMessage()} method).
     */
    public AccountNotFoundException(String message) {
        super(message);
    }

    /**
     * Constructs a new CardNotFoundException with the specified detail message and cause.
     *
     * @param message the detail message.
     * @param cause the cause (which is saved for later retrieval by the {@link Throwable#getCause()} method).
     *              (A {@code null} value is permitted, and indicates that the cause is nonexistent or unknown.)
     */
    public AccountNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\exception\card\CardNotFoundException.java
================================================================================

package com.example.bankcards.exception.card;

import com.example.bankcards.exception.dto.ResourceNotFoundException;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

/**
 * Exception thrown when a requested card is not found.
 * This exception maps to an HTTP 404 Not Found status.
 */
@ResponseStatus(HttpStatus.NOT_FOUND)
public class CardNotFoundException extends ResourceNotFoundException {

    /**
     * Constructs a new CardNotFoundException with the specified detail message.
     *
     * @param message the detail message (which is saved for later retrieval by the {@link Throwable#getMessage()} method).
     */
    public CardNotFoundException(String message) {
        super(message);
    }

    /**
     * Constructs a new CardNotFoundException with the specified detail message and cause.
     *
     * @param message the detail message.
     * @param cause the cause (which is saved for later retrieval by the {@link Throwable#getCause()} method).
     *              (A {@code null} value is permitted, and indicates that the cause is nonexistent or unknown.)
     */
    public CardNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\exception\card\CardOwnershipException.java
================================================================================

package com.example.bankcards.exception.card;

import com.example.bankcards.exception.dto.ForbiddenException;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

/**
 * Exception thrown when a user attempts an operation on a card they do not own,
 * or for which they do not have the necessary permissions.
 * This exception maps to an HTTP 403 Forbidden status.
 */
@ResponseStatus(HttpStatus.FORBIDDEN)
public class CardOwnershipException extends ForbiddenException {

    /**
     * Constructs a new CardOwnershipException with the specified detail message.
     *
     * @param message the detail message.
     */
    public CardOwnershipException(String message) {
        super(message);
    }

    /**
     * Constructs a new CardOwnershipException with the specified detail message and cause.
     *
     * @param message the detail message.
     * @param cause the cause.
     */
    public CardOwnershipException(String message, Throwable cause) {
        super(message, cause);
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\exception\card\CardStatusException.java
================================================================================

package com.example.bankcards.exception.card;

import com.example.bankcards.exception.dto.BadRequestException;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

/**
 * Exception thrown when an operation cannot be performed due to the card's current status.
 * For example, attempting to use a blocked or expired card.
 * This exception maps to an HTTP 400 Bad Request status.
 */
@ResponseStatus(HttpStatus.BAD_REQUEST)
public class CardStatusException extends BadRequestException {

    /**
     * Constructs a new CardStatusException with the specified detail message.
     *
     * @param message the detail message.
     */
    public CardStatusException(String message) {
        super(message);
    }

    /**
     * Constructs a new CardStatusException with the specified detail message and cause.
     *
     * @param message the detail message.
     * @param cause the cause.
     */
    public CardStatusException(String message, Throwable cause) {
        super(message, cause);
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\exception\card\InsufficientFundsException.java
================================================================================

package com.example.bankcards.exception.card;

import com.example.bankcards.exception.dto.BadRequestException;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

/**
 * Exception thrown when a transaction or operation fails due to insufficient funds on a card.
 * This exception maps to an HTTP 400 Bad Request status.
 */
@ResponseStatus(HttpStatus.BAD_REQUEST)
public class InsufficientFundsException extends BadRequestException {

    /**
     * Constructs a new InsufficientFundsException with the specified detail message.
     *
     * @param message the detail message.
     */
    public InsufficientFundsException(String message) {
        super(message);
    }

    /**
     * Constructs a new InsufficientFundsException with the specified detail message and cause.
     *
     * @param message the detail message.
     * @param cause the cause.
     */
    public InsufficientFundsException(String message, Throwable cause) {
        super(message, cause);
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\exception\dto\BadRequestException.java
================================================================================

package com.example.bankcards.exception.dto;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

/**
 * Base exception for client-side errors that result in an HTTP 400 Bad Request status.
 * This typically indicates that the client has sent an invalid request.
 */
@ResponseStatus(HttpStatus.BAD_REQUEST)
public class BadRequestException extends RuntimeException {

    /**
     * Constructs a new BadRequestException with the specified detail message.
     *
     * @param message the detail message.
     */
    public BadRequestException(String message) {
        super(message);
    }

    /**
     * Constructs a new BadRequestException with the specified detail message and cause.
     *
     * @param message the detail message.
     * @param cause the cause.
     */
    public BadRequestException(String message, Throwable cause) {
        super(message, cause);
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\exception\dto\ConflictException.java
================================================================================

package com.example.bankcards.exception.dto;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

/**
 * Base exception for resource conflicts, typically resulting in an HTTP 409 Conflict status.
 * This indicates that the request could not be completed due to a conflict with the current state of the target resource.
 * For example, attempting to create a resource that already exists.
 */
@ResponseStatus(HttpStatus.CONFLICT)
public class ConflictException extends RuntimeException {

    /**
     * Constructs a new ConflictException with the specified detail message.
     *
     * @param message the detail message.
     */
    public ConflictException(String message) {
        super(message);
    }

    /**
     * Constructs a new ConflictException with the specified detail message and cause.
     *
     * @param message the detail message.
     * @param cause the cause.
     */
    public ConflictException(String message, Throwable cause) {
        super(message, cause);
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\exception\dto\ErrorResponse.java
================================================================================

package com.example.bankcards.exception.dto;

import com.fasterxml.jackson.annotation.JsonFormat;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.http.HttpStatus;

import java.time.LocalDateTime;
import java.util.Map;

/**
 * Generic DTO for error responses.
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
public class ErrorResponse {

    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime timestamp;
    private int status;
    private String error;
    private String message;
    private String path;
    private Map<String, String> errors;

    /**
     * Constructs a new ErrorResponse with the given HTTP status, message, and request path.
     * The timestamp is set to the current time, and the error phrase is derived from the HttpStatus.
     *
     * @param status the HTTP status of the error.
     * @param message a descriptive error message.
     * @param path the request URI path.
     */
    public ErrorResponse(HttpStatus status, String message, String path) {
        this.timestamp = LocalDateTime.now();
        this.status = status.value();
        this.error = status.getReasonPhrase();
        this.message = message;
        this.path = path;
    }

    /**
     * Constructs a new ErrorResponse with the given HTTP status, message, request path, and a map of specific errors.
     * This constructor is particularly useful for validation errors where multiple fields might have issues.
     * The timestamp is set to the current time, and the error phrase is derived from the HttpStatus.
     *
     * @param status the HTTP status of the error.
     * @param message a general descriptive error message.
     * @param path the request URI path.
     * @param errors a map containing specific field errors (e.g., field name to error message).
     */
    public ErrorResponse(HttpStatus status, String message, String path, Map<String, String> errors) {
        this.timestamp = LocalDateTime.now();
        this.status = status.value();
        this.error = status.getReasonPhrase();
        this.message = message;
        this.path = path;
        this.errors = errors;
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\exception\dto\ForbiddenException.java
================================================================================

package com.example.bankcards.exception.dto;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

/**
 * Base exception for forbidden access errors, resulting in an HTTP 403 Forbidden status.
 * This indicates that the server understood the request but refuses to authorize it.
 * This is typically used when a user is authenticated but does not have the necessary permissions.
 */
@ResponseStatus(HttpStatus.FORBIDDEN)
public class ForbiddenException extends RuntimeException {

    /**
     * Constructs a new ForbiddenException with the specified detail message.
     *
     * @param message the detail message.
     */
    public ForbiddenException(String message) {
        super(message);
    }

    /**
     * Constructs a new ForbiddenException with the specified detail message and cause.
     *
     * @param message the detail message.
     * @param cause the cause.
     */
    public ForbiddenException(String message, Throwable cause) {
        super(message, cause);
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\exception\dto\ResourceNotFoundException.java
================================================================================

package com.example.bankcards.exception.dto;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

/**
 * Base exception for resource not found errors, resulting in an HTTP 404 Not Found status.
 * This indicates that the requested resource could not be found on the server.
 */
@ResponseStatus(HttpStatus.NOT_FOUND)
public class ResourceNotFoundException extends RuntimeException {

    /**
     * Constructs a new ResourceNotFoundException with the specified detail message.
     *
     * @param message the detail message.
     */
    public ResourceNotFoundException(String message) {
        super(message);
    }

    /**
     * Constructs a new ResourceNotFoundException with the specified detail message and cause.
     *
     * @param message the detail message.
     * @param cause the cause.
     */
    public ResourceNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\exception\GlobalExceptionHandler.java
================================================================================

package com.example.bankcards.exception;

import com.example.bankcards.exception.card.CardStatusException;
import com.example.bankcards.exception.card.InsufficientFundsException;
import com.example.bankcards.exception.dto.BadRequestException;
import com.example.bankcards.exception.dto.ConflictException;
import com.example.bankcards.exception.dto.ForbiddenException;
import com.example.bankcards.exception.dto.ResourceNotFoundException;
import com.example.bankcards.exception.dto.ErrorResponse;
import com.example.bankcards.exception.transfer.InvalidTransferException;
import com.example.bankcards.exception.user.AuthenticationFailedException;
import com.example.bankcards.exception.user.DuplicateUsernameException;
import com.example.bankcards.exception.user.TokenExpiredException;
import jakarta.servlet.http.HttpServletRequest;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import com.example.bankcards.exception.card.CardOwnershipException;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import jakarta.servlet.ServletException;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

/**
 * Global exception handler for the application.
 * This class intercepts exceptions thrown by controllers and provides a centralized
 * way to handle them, returning consistent {@link ErrorResponse} objects.
 * It is annotated with {@link RestControllerAdvice} to apply to all controllers.
 */
@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {

    /**
     * Helper method to create a {@link ResponseEntity} containing an {@link ErrorResponse}.
     * Reduces code duplication in exception handlers.
     *
     * @param status the HTTP status to set in the response.
     * @param message the error message to include.
     * @param request the current {@link HttpServletRequest} to extract the request URI.
     * @param errors an optional map of field-specific errors, typically for validation failures.
     * @return a {@link ResponseEntity} with the constructed {@link ErrorResponse} and the specified HTTP status.
     */
    private ResponseEntity<ErrorResponse> createErrorResponseEntity(HttpStatus status, String message, HttpServletRequest request, Map<String, String> errors) {
        ErrorResponse errorResponse = new ErrorResponse(status, message, request.getRequestURI(), errors);
        return new ResponseEntity<>(errorResponse, status);
    }

    /**
     * Overloaded helper method to create a {@link ResponseEntity} containing an {@link ErrorResponse}
     * without specific field errors.
     *
     * @param status the HTTP status to set in the response.
     * @param message the error message to include.
     * @param request the current {@link HttpServletRequest} to extract the request URI.
     * @return a {@link ResponseEntity} with the constructed {@link ErrorResponse} and the specified HTTP status.
     */
    private ResponseEntity<ErrorResponse> createErrorResponseEntity(HttpStatus status, String message, HttpServletRequest request) {
        return createErrorResponseEntity(status, message, request, null);
    }

    /**
     * Handles {@link CardOwnershipException}, which occurs when a user attempts an operation
     * on a card they do not own.
     * Returns an HTTP 403 Forbidden status.
     *
     * @param ex the {@link CardOwnershipException} that was thrown.
     * @param request the current {@link HttpServletRequest}.
     * @return a {@link ResponseEntity} with an {@link ErrorResponse} and HTTP 403 Forbidden status.
     */
    @ExceptionHandler(CardOwnershipException.class)
    public ResponseEntity<ErrorResponse> handleCardOwnershipException(CardOwnershipException ex, HttpServletRequest request) {
        log.error("CardOwnershipException: {}", ex.getMessage(), ex);
        return createErrorResponseEntity(HttpStatus.FORBIDDEN, "Access denied: " + ex.getMessage(), request);
    }

    /**
     * Handles general {@link ServletException}s that may occur during request processing.
     * Returns an HTTP 500 Internal Server Error status.
     *
     * @param ex the {@link ServletException} that was thrown.
     * @param request the current {@link HttpServletRequest}.
     * @return a {@link ResponseEntity} with an {@link ErrorResponse} and HTTP 500 Internal Server Error status.
     */
    @ExceptionHandler(ServletException.class)
    public ResponseEntity<ErrorResponse> handleServletException(ServletException ex, HttpServletRequest request) {
        log.error("ServletException: {}", ex.getMessage(), ex);
        return createErrorResponseEntity(HttpStatus.INTERNAL_SERVER_ERROR, "Servlet error: " + ex.getMessage(), request);
    }

    /**
     * Handles {@link IOException}s that may occur during I/O operations.
     * Returns an HTTP 500 Internal Server Error status.
     *
     * @param ex the {@link IOException} that was thrown.
     * @param request the current {@link HttpServletRequest}.
     * @return a {@link ResponseEntity} with an {@link ErrorResponse} and HTTP 500 Internal Server Error status.
     */
    @ExceptionHandler(IOException.class)
    public ResponseEntity<ErrorResponse> handleIOException(IOException ex, HttpServletRequest request) {
        log.error("IOException: {}", ex.getMessage(), ex);
        return createErrorResponseEntity(HttpStatus.INTERNAL_SERVER_ERROR, "I/O error: " + ex.getMessage(), request);
    }

    /**
     * Handles {@link ResourceNotFoundException} and its subclasses.
     * Returns an HTTP 404 Not Found status.
     *
     * @param ex the {@link ResourceNotFoundException} that was thrown.
     * @param request the current {@link HttpServletRequest}.
     * @return a {@link ResponseEntity} with an {@link ErrorResponse} and HTTP 404 Not Found status.
     */
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleResourceNotFoundException(ResourceNotFoundException ex, HttpServletRequest request) {
        log.error("ResourceNotFoundException: {}", ex.getMessage(), ex);
        return createErrorResponseEntity(HttpStatus.NOT_FOUND, ex.getMessage(), request);
    }

    /**
     * Handles {@link BadRequestException} and its subclasses (e.g., {@link CardStatusException}, {@link InsufficientFundsException},
     * {@link InvalidTransferException}).
     * Returns an HTTP 400 Bad Request status.
     *
     * @param ex the {@link BadRequestException} that was thrown.
     * @param request the current {@link HttpServletRequest}.
     * @return a {@link ResponseEntity} with an {@link ErrorResponse} and HTTP 400 Bad Request status.
     */
    @ExceptionHandler(BadRequestException.class)
    public ResponseEntity<ErrorResponse> handleBadRequestException(BadRequestException ex, HttpServletRequest request) {
        log.error("BadRequestException: {}", ex.getMessage(), ex);
        return createErrorResponseEntity(HttpStatus.BAD_REQUEST, ex.getMessage(), request);
    }

    /**
     * Handles {@link ConflictException} and its subclasses (e.g., {@link DuplicateUsernameException}).
     * Returns an HTTP 409 Conflict status.
     *
     * @param ex the {@link ConflictException} that was thrown.
     * @param request the current {@link HttpServletRequest}.
     * @return a {@link ResponseEntity} with an {@link ErrorResponse} and HTTP 409 Conflict status.
     */
    @ExceptionHandler(ConflictException.class)
    public ResponseEntity<ErrorResponse> handleConflictException(ConflictException ex, HttpServletRequest request) {
        log.error("ConflictException: {}", ex.getMessage(), ex);
        return createErrorResponseEntity(HttpStatus.CONFLICT, ex.getMessage(), request);
    }

    /**
     * Handles {@link ForbiddenException} and its subclasses (e.g., {@link TokenExpiredException}).
     * Returns an HTTP 403 Forbidden status.
     *
     * @param ex the {@link ForbiddenException} that was thrown.
     * @param request the current {@link HttpServletRequest}.
     * @return a {@link ResponseEntity} with an {@link ErrorResponse} and HTTP 403 Forbidden status.
     */
    @ExceptionHandler(ForbiddenException.class)
    public ResponseEntity<ErrorResponse> handleForbiddenException(ForbiddenException ex, HttpServletRequest request) {
        log.error("ForbiddenException: {}", ex.getMessage(), ex);
        return createErrorResponseEntity(HttpStatus.FORBIDDEN, ex.getMessage(), request);
    }

    /**
     * Handles {@link AuthenticationFailedException}, which occurs when user authentication fails.
     * Returns an HTTP 401 Unauthorized status.
     *
     * @param ex the {@link AuthenticationFailedException} that was thrown.
     * @param request the current {@link HttpServletRequest}.
     * @return a {@link ResponseEntity} with an {@link ErrorResponse} and HTTP 401 Unauthorized status.
     */
    @ExceptionHandler(AuthenticationFailedException.class)
    public ResponseEntity<ErrorResponse> handleAuthenticationFailedException(AuthenticationFailedException ex, HttpServletRequest request) {
        log.error("AuthenticationFailedException: {}", ex.getMessage(), ex);
        return createErrorResponseEntity(HttpStatus.UNAUTHORIZED, ex.getMessage(), request);
    }

    /**
     * Handles {@link TokenExpiredException}, which occurs when an authentication token is expired or invalid.
     * Returns an HTTP 403 Forbidden status.
     *
     * @param ex the {@link TokenExpiredException} that was thrown.
     * @param request the current {@link HttpServletRequest}.
     * @return a {@link ResponseEntity} with an {@link ErrorResponse} and HTTP 403 Forbidden status.
     */
    @ExceptionHandler(TokenExpiredException.class)
    public ResponseEntity<ErrorResponse> handleTokenExpiredException(TokenExpiredException ex, HttpServletRequest request) {
        log.error("TokenExpiredException: {}", ex.getMessage(), ex);
        return createErrorResponseEntity(HttpStatus.FORBIDDEN, ex.getMessage(), request);
    }

    /**
     * Handles {@link MethodArgumentNotValidException}, typically thrown when method arguments
     * annotated with {@code @Valid} fail validation.
     * Returns an HTTP 400 Bad Request status and includes details of validation errors.
     *
     * @param ex the {@link MethodArgumentNotValidException} that was thrown.
     * @param request the current {@link HttpServletRequest}.
     * @return a {@link ResponseEntity} with an {@link ErrorResponse} and HTTP 400 Bad Request status,
     *         including a map of validation errors.
     */
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidationExceptions(MethodArgumentNotValidException ex, HttpServletRequest request) {
        log.error("MethodArgumentNotValidException: {}", ex.getMessage(), ex);
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getAllErrors().forEach((error) -> {
            String fieldName = ((FieldError) error).getField();
            String errorMessage = error.getDefaultMessage();
            errors.put(fieldName, errorMessage);
        });
        return createErrorResponseEntity(HttpStatus.BAD_REQUEST, "Validation failed", request, errors);
    }

    /**
     * Global handler for all other unexpected exceptions not specifically handled by other methods.
     * This acts as a fallback mechanism to ensure that any unhandled exception
     * is caught and returned in a structured {@link ErrorResponse} format.
     * Returns an HTTP 500 Internal Server Error status.
     *
     * @param ex the {@link Exception} that was thrown.
     * @param request the current {@link HttpServletRequest}.
     * @return a {@link ResponseEntity} with an {@link ErrorResponse} and HTTP 500 Internal Server Error status.
     */
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGlobalException(Exception ex, HttpServletRequest request) {
        log.error("An unexpected error occurred: {}", ex.getMessage(), ex);
        return createErrorResponseEntity(HttpStatus.INTERNAL_SERVER_ERROR, "An unexpected error occurred: " + ex.getMessage(), request);
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\exception\transfer\InvalidTransferException.java
================================================================================

package com.example.bankcards.exception.transfer;

import com.example.bankcards.exception.dto.BadRequestException;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

/**
 * Exception thrown when a money transfer operation is invalid due to specific business rules,
 * such as attempting to transfer to the same card.
 * This exception maps to an HTTP 400 Bad Request status.
 */
@ResponseStatus(HttpStatus.BAD_REQUEST)
public class InvalidTransferException extends BadRequestException {

    /**
     * Constructs a new InvalidTransferException with the specified detail message.
     *
     * @param message the detail message.
     */
    public InvalidTransferException(String message) {
        super(message);
    }

    /**
     * Constructs a new InvalidTransferException with the specified detail message and cause.
     *
     * @param message the detail message.
     * @param cause the cause.
     */
    public InvalidTransferException(String message, Throwable cause) {
        super(message, cause);
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\exception\transfer\TransferNotFoundException.java
================================================================================

package com.example.bankcards.exception.transfer;

import com.example.bankcards.exception.dto.ResourceNotFoundException;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

/**
 * Exception thrown when a requested transfer record is not found.
 * This exception maps to an HTTP 404 Not Found status.
 */
@ResponseStatus(HttpStatus.NOT_FOUND)
public class TransferNotFoundException extends ResourceNotFoundException {

    /**
     * Constructs a new TransferNotFoundException with the specified detail message.
     *
     * @param message the detail message.
     */
    public TransferNotFoundException(String message) {
        super(message);
    }

    /**
     * Constructs a new TransferNotFoundException with the specified detail message and cause.
     *
     * @param message the detail message.
     * @param cause the cause.
     */
    public TransferNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\exception\user\AuthenticationFailedException.java
================================================================================

package com.example.bankcards.exception.user;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

/**
 * Exception thrown when user authentication fails, e.g., due to incorrect credentials.
 * This exception maps to an HTTP 401 Unauthorized status.
 */
@ResponseStatus(HttpStatus.UNAUTHORIZED)
public class AuthenticationFailedException extends RuntimeException {

    /**
     * Constructs a new AuthenticationFailedException with the specified detail message.
     *
     * @param message the detail message.
     */
    public AuthenticationFailedException(String message) {
        super(message);
    }

    /**
     * Constructs a new AuthenticationFailedException with the specified detail message and cause.
     *
     * @param message the detail message.
     * @param cause the cause.
     */
    public AuthenticationFailedException(String message, Throwable cause) {
        super(message, cause);
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\exception\user\DuplicateUsernameException.java
================================================================================

package com.example.bankcards.exception.user;

import com.example.bankcards.exception.dto.ConflictException;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

/**
 * Exception thrown when an attempt is made to create a user with a username that already exists.
 * This exception maps to an HTTP 409 Conflict status.
 */
@ResponseStatus(HttpStatus.CONFLICT)
public class DuplicateUsernameException extends ConflictException {

    /**
     * Constructs a new DuplicateUsernameException with the specified detail message.
     *
     * @param message the detail message.
     */
    public DuplicateUsernameException(String message) {
        super(message);
    }

    /**
     * Constructs a new DuplicateUsernameException with the specified detail message and cause.
     *
     * @param message the detail message.
     * @param cause the cause.
     */
    public DuplicateUsernameException(String message, Throwable cause) {
        super(message, cause);
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\exception\user\TokenExpiredException.java
================================================================================

package com.example.bankcards.exception.user;

import com.example.bankcards.exception.dto.ForbiddenException;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

/**
 * Exception thrown when an authentication token is expired or otherwise invalid.
 * This typically results in an HTTP 403 Forbidden status, indicating that the request
 * cannot be processed due to an invalid or expired credential.
 */
@ResponseStatus(HttpStatus.FORBIDDEN)
public class TokenExpiredException extends ForbiddenException {

    /**
     * Constructs a new TokenExpiredException with the specified detail message.
     *
     * @param message the detail message.
     */
    public TokenExpiredException(String message) {
        super(message);
    }

    /**
     * Constructs a new TokenExpiredException with the specified detail message and cause.
     *
     * @param message the detail message.
     * @param cause the cause.
     */
    public TokenExpiredException(String message, Throwable cause) {
        super(message, cause);
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\exception\user\UserNotFoundException.java
================================================================================

package com.example.bankcards.exception.user;

import com.example.bankcards.exception.dto.ResourceNotFoundException;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

/**
 * Exception thrown when a requested user is not found.
 * This exception maps to an HTTP 404 Not Found status.
 */
@ResponseStatus(HttpStatus.NOT_FOUND)
public class UserNotFoundException extends ResourceNotFoundException {

    /**
     * Constructs a new UserNotFoundException with the specified detail message.
     *
     * @param message the detail message.
     */
    public UserNotFoundException(String message) {
        super(message);
    }

    /**
     * Constructs a new UserNotFoundException with the specified detail message and cause.
     *
     * @param message the detail message.
     * @param cause the cause.
     */
    public UserNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\initializer\AdminInitializer.java
================================================================================

package com.example.bankcards.initializer;

import com.example.bankcards.model.entity.User;
import com.example.bankcards.model.entity.enums.Role;
import com.example.bankcards.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.CommandLineRunner;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Component;

/**
 * Component that initializes a default administrator user if no admin user
 * exists in the database upon application startup.
 * This class implements {@link CommandLineRunner} to execute logic right after the
 * Spring application context has been loaded.
 */
@Component
@RequiredArgsConstructor
@Slf4j
public class AdminInitializer implements CommandLineRunner {
    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;

    /**
     * Configurable username for the default administrator.
     * Defaults to "admin" if not specified in application properties.
     */
    @Value("${app.admin.username:admin}")
    private String adminUsername;

    /**
     * Configurable password for the default administrator.
     * Defaults to "password" if not specified in application properties.
     */
    @Value("${app.admin.password:password}")
    private String adminPassword;

    /**
     * Callback method executed once the Spring application context is fully loaded.
     * It checks if any user with the {@code ROLE_ADMIN} role exists in the database.
     * If no admin user is found, it creates a new admin user with the configured
     * username and password, and saves it to the database.
     *
     * @param args Command line arguments (not used in this implementation).
     * @throws Exception if an error occurs during user creation or database interaction.
     */
    @Override
    public void run(String... args) throws Exception {
        if (!userRepository.existsByRole(Role.ROLE_ADMIN)) {
            User adminUser = new User();
            adminUser.setUsername(adminUsername);
            adminUser.setPassword(passwordEncoder.encode(adminPassword));
            adminUser.setRole(Role.ROLE_ADMIN);
            adminUser.setEmail(adminUsername + "@gmail.com");
            userRepository.save(adminUser);
            log.info("Admin user created: {}", adminUsername);
        } else {
            log.info("Admin user already exists: {}", adminUsername);
        }
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\model\dto\account\AccountCreateRequest.java
================================================================================

package com.example.bankcards.model.dto.account;

import com.example.bankcards.model.entity.enums.AccountType;
import jakarta.validation.constraints.NotNull;
import lombok.Data;

/**
 * Request DTO for creating a new bank account.
 */
@Data
public class AccountCreateRequest {

    @NotNull(message = "Account type is required")
    private AccountType accountType;

    // UserId не требуется, если мы создаем счет для аутентифицированного пользователя,
    // но оставим его для удобства администрирования, если потребуется.
    private Long userId;
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\model\dto\account\AccountResponseDto.java
================================================================================

package com.example.bankcards.model.dto.account;

import com.example.bankcards.model.entity.enums.AccountType;
import lombok.Data;
import java.math.BigDecimal;
import java.time.LocalDateTime;

/**
 * Response DTO containing account details.
 */
@Data
public class AccountResponseDto {
    private Long id;
    private String accountNumber;
    private BigDecimal balance;
    private AccountType accountType;
    private Long userId;
    private LocalDateTime createdAt;
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\model\dto\auth\AuthResponseDto.java
================================================================================

package com.example.bankcards.model.dto.auth;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.*;

/**
 * DTO for authentication response, containing JWT and refresh token.
 */
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@Schema(description = "DTO for authentication response, containing access tokens.")
public class AuthResponseDto {
    @Schema(description = "Access token (JWT) for authenticated requests.", example = "eyJhbGciOiJIUzI1Ni...")
    private String accessToken;
    @Schema(description = "Refresh token (JWT) for obtaining a new access token.", example = "eyJhbGciOiJIUzI1Ni...")
    private String refreshToken;
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\model\dto\auth\LoginRequest.java
================================================================================

package com.example.bankcards.model.dto.auth;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Getter;
import lombok.Setter;

/**
 * DTO for user login request.
 */
@Getter
@Setter
@Schema(description = "DTO for user login request.")
public class LoginRequest {
    @NotBlank(message = "Username cannot be empty")
    @Size(min=3, max = 50, message = "Username must be between 3 and 50 characters")
    @Schema(description = "Username for login.", example = "testuser")
    private String username;

    @NotBlank(message = "Password cannot be empty")
    @Size(min = 8, max = 100, message = "Password must be between 8 and 100 characters")
    @Schema(description = "User password.", example = "password123")
    private String password;
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\model\dto\auth\RefreshRequest.java
================================================================================

package com.example.bankcards.model.dto.auth;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotBlank;
import lombok.Getter;
import lombok.Setter;

/**
 * DTO for refresh token request.
 */
@Getter
@Setter
@Schema(description = "DTO for refresh token request.")
public class RefreshRequest {
    @NotBlank
    @Schema(description = "Refresh token used to obtain a new access token.", example = "eyJhbGciOiJIUzI1Ni...")
    private String refreshToken;
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\model\dto\auth\RegisterRequest.java
================================================================================

package com.example.bankcards.model.dto.auth;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Getter;
import lombok.Setter;

/**
 * DTO for new user registration request.
 */
@Getter
@Setter
@Schema(description = "DTO for new user registration request.")
public class RegisterRequest {
    @NotBlank(message = "Username cannot be empty")
    @Size(min = 3, max = 50, message = "Username must be between 3 and 50 characters")
    @Schema(description = "Username for registration.", example = "newuser")
    private String username;

    @NotBlank(message = "Email cannot be empty")
    @Email(message = "Invalid email format")
    @Schema(description = "User's email address.", example = "newuser@example.com")
    private String email;

    @NotBlank(message = "Password cannot be empty")
    @Size(min = 8, max = 100, message = "Password must be between 8 and 100 characters")
    @Schema(description = "Password for the new user.", example = "securepassword")
    private String password;
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\model\dto\card\BalanceChangeRequest.java
================================================================================

package com.example.bankcards.model.dto.card;

import lombok.Data;
import java.math.BigDecimal;

@Data
public class BalanceChangeRequest {
    private BigDecimal amount;
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\model\dto\card\CardCreateRequest.java
================================================================================

package com.example.bankcards.model.dto.card;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;
import jakarta.validation.constraints.PositiveOrZero;
import lombok.*;

import java.math.BigDecimal;
import java.time.LocalDate;

/**
 * DTO for creating a new card.
 */
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@Schema(description = "DTO for creating a new bank card request.")
public class CardCreateRequest {
    @NotBlank(message = "Card number is required")
    @Schema(description = "Unique bank card number.", example = "1234567890123456")
    private String cardNumber;

    @NotBlank(message = "Card holder name is required")
    @Schema(description = "Name of the card holder.", example = "JOHN DOE")
    private String cardHolder;

    @NotNull(message = "Expiry date is required")
    @Schema(description = "Card expiration date in YYYY-MM-DD format.", example = "2028-12-31")
    private LocalDate expiryDate;

    @NotNull(message = "Initial balance is required")
    @PositiveOrZero(message = "Initial balance must be positive")
    @Schema(description = "Initial balance of the card.", example = "1000.00")
    private BigDecimal balance;

    @NotNull(message = "User ID is required")
    @Schema(description = "ID of the user to whom the card belongs.", example = "1")
    private Long userId;
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\model\dto\card\CardResponseDto.java
================================================================================

package com.example.bankcards.model.dto.card;

import com.example.bankcards.model.entity.enums.CardStatus;
import io.swagger.v3.oas.annotations.media.Schema;
import lombok.*;

import java.math.BigDecimal;
import java.time.LocalDate;

/**
 * DTO for card response.
 */
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@Schema(description = "DTO for card response, representing bank card information.")
public class CardResponseDto {
    @Schema(description = "Unique card identifier.", example = "1")
    private Long id;
    @Schema(description = "Bank card number.", example = "1234567890123456")
    private String cardNumber;
    @Schema(description = "Name of the card holder.", example = "JOHN DOE")
    private String cardHolder;
    @Schema(description = "Card expiration date.", example = "2028-12-31")
    private LocalDate expiryDate;
    @Schema(description = "Current status of the card (e.g., ACTIVE, BLOCKED).", example = "ACTIVE")
    private CardStatus cardStatus;
    @Schema(description = "Current balance of the card.", example = "950.50")
    private BigDecimal balance;
    @Schema(description = "Username of the card owner.", example = "testuser")
    private String username;
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\model\dto\card\CardUpdateRequest.java
================================================================================

package com.example.bankcards.model.dto.card;

import com.example.bankcards.model.entity.enums.CardStatus;
import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Getter;
import lombok.Setter;

import java.math.BigDecimal;
import java.time.LocalDate;

/**
 * DTO for updating an existing card.
 */
@Getter
@Setter
@Schema(description = "DTO for updating bank card information request.")
public class CardUpdateRequest {
    @Schema(description = "New name of the card holder.", example = "JANE DOE")
    private String cardHolder;
    @Schema(description = "New card expiration date.", example = "2030-01-01")
    private LocalDate expiryDate;
    @Schema(description = "New status of the card (e.g., ACTIVE, BLOCKED).", example = "BLOCKED")
    private CardStatus cardStatus;
    @Schema(description = "New balance of the card.", example = "1200.00")
    private BigDecimal balance;
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\model\dto\fee\ServiceFeeResponseDto.java
================================================================================

package com.example.bankcards.model.dto.fee;

import com.example.bankcards.model.entity.enums.FeeType;
import lombok.Data;
import java.math.BigDecimal;
import java.time.LocalDateTime;

/**
 * Response DTO for displaying service fee details.
 */
@Data
public class ServiceFeeResponseDto {
    private Long id;
    private Long accountId;
    private FeeType feeType;
    private BigDecimal amount;
    private LocalDateTime dateCharged;
    private Boolean isPaid;
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\model\dto\notification\NotificationResponseDto.java
================================================================================

package com.example.bankcards.model.dto.notification;

import com.example.bankcards.model.entity.enums.NotificationType;
import lombok.Data;
import java.time.LocalDateTime;

/**
 * Response DTO for displaying notification details to the user.
 */
@Data
public class NotificationResponseDto {
    private Long id;
    private String message;
    private NotificationType type;
    private LocalDateTime createdAt;
    private Boolean isRead;
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\model\dto\ticket\TicketCreateRequest.java
================================================================================

package com.example.bankcards.model.dto.ticket;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Data;

/**
 * Request DTO for creating a new support ticket.
 */
@Data
public class TicketCreateRequest {
    @NotBlank
    @Size(max = 150)
    private String subject;

    @NotBlank
    private String description;
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\model\dto\ticket\TicketResponseDto.java
================================================================================

package com.example.bankcards.model.dto.ticket;

import com.example.bankcards.model.entity.enums.TicketPriority;
import com.example.bankcards.model.entity.enums.TicketStatus;
import lombok.Data;
import java.time.LocalDateTime;

/**
 * Response DTO for displaying support ticket details.
 */
@Data
public class TicketResponseDto {
    private Long id;
    private String subject;
    private String description;
    private TicketStatus status;
    private TicketPriority priority;
    private String createdByUsername;
    private String assignedToAdminUsername;
    private LocalDateTime createdAt;
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\model\dto\transfer\TransferRequest.java
================================================================================

package com.example.bankcards.model.dto.transfer;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;
import lombok.*;

import java.math.BigDecimal;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Schema(description = "DTO for transfer funds between cards request.")
public class TransferRequest {
    @NotNull(message = "From card ID is required")
    @Schema(description = "ID of the card from which the transfer is made.", example = "1")
    private Long fromCardId;

    @Schema(description = "Number of the card to which the transfer is made.", example = "9876543210987654")
    private String toCardNumber;

    @Schema(description = "ID of the destination card (optional, used for internal transfers).", example = "2")
    private Long toCardId;

    @NotNull(message = "Amount is required")
    @Positive(message = "Amount must be positive")
    @Schema(description = "Amount of the transfer.", example = "50.00")
    private BigDecimal amount;

    @Schema(description = "Optional description of the transfer.", example = "Payment for dinner")
    private String description;
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\model\dto\transfer\TransferResponseDto.java
================================================================================

package com.example.bankcards.model.dto.transfer;

import com.example.bankcards.model.entity.enums.TransferStatus;
import io.swagger.v3.oas.annotations.media.Schema;
import lombok.*;

import java.math.BigDecimal;
import java.time.LocalDateTime;

/**
 * DTO for transfer response.
 */
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@Schema(description = "DTO for transfer response, representing information about a completed transfer.")
public class TransferResponseDto {
    @Schema(description = "Unique transfer identifier.", example = "1")
    private Long id;
    @Schema(description = "Number of the card from which the transfer was made.", example = "1234567890123456")
    private String fromCardNumber;
    @Schema(description = "Number of the card to which the transfer was made.", example = "9876543210987654")
    private String toCardNumber;
    @Schema(description = "Amount of the transfer.", example = "50.00")
    private BigDecimal amount;
    @Schema(description = "Status of the transfer (e.g., COMPLETED, PENDING, FAILED).", example = "COMPLETED")
    private TransferStatus status;
    @Schema(description = "Date and time when the transfer occurred.", example = "2023-10-26T10:30:00")
    private LocalDateTime transferDate;
    @Schema(description = "Date and time when the transfer record was created.", example = "2023-10-26T10:29:55")
    private LocalDateTime createdAt;
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\model\dto\user\QuickTransferDto.java
================================================================================

package com.example.bankcards.model.dto.user;

import lombok.Data;

@Data
public class QuickTransferDto {
    private Long id;
    private String name;
    private String cardNumber;
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\model\dto\user\UserResponseDto.java
================================================================================

package com.example.bankcards.model.dto.user;

import com.example.bankcards.model.entity.enums.Role;
import io.swagger.v3.oas.annotations.media.Schema;
import lombok.*;

import java.math.BigDecimal;
import java.time.LocalDateTime;

/**
 * DTO for user response.
 */
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@Schema(description = "DTO for user response, representing user information.")
public class UserResponseDto {
    @Schema(description = "Unique user identifier.", example = "1")
    private Long id;
    @Schema(description = "Username.", example = "testuser")
    private String username;
    @Schema(description = "User's email address.", example = "testuser@example.com")
    private String email;
    @Schema(description = "User's role (e.g., USER, ADMIN).", example = "USER")
    private Role role;
    private BigDecimal monthlyLimit; // Новое поле
    private String avatarUrl;
    @Schema(description = "Date and time when the user account was created.", example = "2023-01-15T09:00:00")
    private LocalDateTime createdAt;
    @Schema(description = "Date and time when the user account was last updated.", example = "2023-10-20T14:45:00")
    private LocalDateTime updatedAt;
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\model\dto\user\UserUpdateRequest.java
================================================================================

package com.example.bankcards.model.dto.user;

import com.example.bankcards.model.entity.enums.Role;
import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.*;

/**
 * DTO for updating user information.
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Schema(description = "DTO for updating user information request.")
public class UserUpdateRequest {
    @NotBlank(message = "Username cannot be blank")
    @Schema(description = "New username.", example = "updateduser")
    private String username;
    @Email(message = "Invalid email format")
    @Schema(description = "New user email address.", example = "updated.email@example.com")
    private String email;
    @NotNull(message = "Role cannot be null")
    @Schema(description = "New user role (e.g., USER, ADMIN).", example = "ADMIN")
    private Role role;
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\model\entity\Account.java
================================================================================

package com.example.bankcards.model.entity;

import com.example.bankcards.model.entity.enums.AccountType;
import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;

@Entity
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Table(name = "t_accounts")
public class Account extends BasicEntity {

    @Column(unique = true, nullable = false, length = 20)
    private String accountNumber;

    @Column(nullable = false, precision = 19, scale = 2)
    private BigDecimal balance = BigDecimal.ZERO;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private AccountType accountType;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @OneToMany(mappedBy = "account", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<Card> cards = new ArrayList<>();

    @OneToMany(mappedBy = "account", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<Transaction> transactions = new ArrayList<>();
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\model\entity\BasicEntity.java
================================================================================

package com.example.bankcards.model.entity;

import jakarta.persistence.Column;
import jakarta.persistence.EntityListeners;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.MappedSuperclass;
import jakarta.validation.constraints.NotNull;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.Comment;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;

@MappedSuperclass
@Getter
@Setter
@EntityListeners(AuditingEntityListener.class)
public class BasicEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Comment("Identifier")
    @Column(nullable = false, name = "id", unique = true, columnDefinition = "BIGINT")
    private Long id;

    @NotNull
    @Comment("Format ISO 8601: YYYY-MM-DD hh:mm:ss.000000")
    @Column(nullable = false, name = "created_at", columnDefinition = "TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP")
    private LocalDateTime createdAt = LocalDateTime.now();

    @LastModifiedDate
    @NotNull
    @Comment("Format ISO 8601: YYYY-MM-DD hh:mm:ss.000000")
    @Column(nullable = false, name = "updated_at", columnDefinition = "TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP")
    private LocalDateTime updateAt = LocalDateTime.now();

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || !this.getClass().equals(o.getClass())) {
            return false;
        }
        BasicEntity that = (BasicEntity) o;
        return id != null && id.equals(that.id);
    }

    @Override
    public int hashCode() {
        return id == null ? 0 : id.hashCode();
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\model\entity\Card.java
================================================================================

package com.example.bankcards.model.entity;

import com.example.bankcards.model.entity.enums.CardStatus;
import jakarta.persistence.*;
import lombok.*;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;

/**
 * Represents a bank card in the system.
 * This entity stores details about a card, its status, balance, and its association with an account.
 * It extends {@link BasicEntity} to inherit common fields like ID and timestamps.
 */
@Entity
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@Table(name = "t_cards")
public class Card extends BasicEntity {

    /**
     * The unique (and typically encrypted/hashed) card number.
     */
    @Column(nullable = false, length = 100)
    private String cardNumber;

    /**
     * The name of the card holder as it appears on the card.
     */
    @Column(nullable = false, length = 100)
    private String cardHolder;

    /**
     * The expiry date of the card.
     */
    @Column(nullable = false)
    private LocalDate expiryDate;

    /**
     * The current status of the card (e.g., ACTIVE, BLOCKED, BLOCKED_PENDING).
     * Defaults to {@link CardStatus#ACTIVE}.
     */
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private CardStatus cardStatus = CardStatus.ACTIVE;

    /**
     * The current balance on the card.
     * Stored with a precision of 15 digits and 2 decimal places.
     * Defaults to {@link BigDecimal#ZERO}.
     */
    @Column(nullable = false, precision = 15, scale = 2)
    private BigDecimal balance = BigDecimal.ZERO;

    /**
     * The account this card is linked to. (UPDATED RELATIONSHIP)
     * Many-to-one relationship, fetched lazily.
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name="account_id", nullable = false)
    private Account account;

    // NOTE: The direct link to User has been removed as Card is now linked via Account.
    // However, since the original User entity still holds a 'cards' list, we must ensure
    // that the 'mappedBy' attribute in User is updated if we strictly follow JPA rules,
    // but since we removed 'user' field here, we must remove the 'cards' list in User.
    // For simplicity and to match the provided User entity structure, we will assume
    // the User entity's 'cards' list is now redundant or handled differently,
    // but we keep the User entity as modified above.

    /**
     * A list of transfers where this card is the recipient.
     * One-to-many relationship, fetched lazily.
     */
    @OneToMany(mappedBy="toCard", fetch = FetchType.LAZY)
    private List<Transfer> incomingTransfers = new ArrayList<>();

    /**
     * A list of transfers where this card is the sender.
     * One-to-many relationship, fetched lazily.
     */
    @OneToMany(mappedBy="fromCard", fetch = FetchType.LAZY)
    private List<Transfer> outgoingTransfers = new ArrayList<>();
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\model\entity\enums\AccountType.java
================================================================================

package com.example.bankcards.model.entity.enums;

public enum AccountType {
    CHECKING,       // Текущий счет
    SAVINGS,        // Сберегательный счет
    CREDIT_CARD     // Счет кредитной карты (если применимо)
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\model\entity\enums\CardStatus.java
================================================================================

package com.example.bankcards.model.entity.enums;

/**
 * Enumeration representing the possible statuses of a bank card.
 */
public enum CardStatus {

    /**
     * The card is active and can be used for transactions.
     */
    ACTIVE,

    /**
     * The card is blocked and cannot be used.
     */
    BLOCKED,

    /**
     * The card has expired and is no longer valid.
     */
    EXPIRED,

    /**
     * The card is pending a block operation.
     */
    PENDING_BLOCK,

    /**
     * The card is pending an unblock operation.
     */
    PENDING_UNBLOCK
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\model\entity\enums\FeeType.java
================================================================================

package com.example.bankcards.model.entity.enums;

/**
 * Defines the type of service fee charged.
 */
public enum FeeType {
    MONTHLY_MAINTENANCE, // Ежемесячное обслуживание
    ATM_FEE,             // Комиссия за банкомат
    OVERDRAFT,           // Комиссия за овердрафт
    TRANSFER_FEE         // Комиссия за перевод
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\model\entity\enums\NotificationType.java
================================================================================

package com.example.bankcards.model.entity.enums;

/**
 * Defines the severity or category of a notification.
 */
public enum NotificationType {
    INFO,       // Информационное сообщение
    ALERT,      // Важное предупреждение (например, крупная транзакция)
    SECURITY,   // Уведомление о безопасности (например, смена пароля)
    SYSTEM,
    SUCCESS// Системное уведомление
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\model\entity\enums\Role.java
================================================================================

package com.example.bankcards.model.entity.enums;

/**
 * Enumeration representing the different roles a user can have within the application.
 */
public enum Role {

    /**
     * Represents a standard user role.
     */
    ROLE_USER,

    /**
     * Represents an administrative user role with elevated privileges.
     */
    ROLE_ADMIN
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\model\entity\enums\TicketPriority.java
================================================================================

package com.example.bankcards.model.entity.enums;

public enum TicketPriority {
    LOW,
    MEDIUM,
    HIGH,
    CRITICAL
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\model\entity\enums\TicketStatus.java
================================================================================

package com.example.bankcards.model.entity.enums;

public enum TicketStatus {
    OPEN,
    IN_PROGRESS,
    CLOSED,
    RESOLVED
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\model\entity\enums\TransactionType.java
================================================================================

package com.example.bankcards.model.entity.enums;

/**
 * Defines the type of financial transaction.
 */
public enum TransactionType {
    DEBIT,          // Списание (Общее)
    CREDIT,         // Зачисление (Общее)
    PURCHASE,       // Покупка
    ATM_WITHDRAWAL, // Снятие наличных в банкомате
    FEE,            // Комиссия
    TRANSFER_IN,    // Входящий перевод
    TRANSFER_OUT    // Исходящий перевод
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\model\entity\enums\TransferStatus.java
================================================================================

package com.example.bankcards.model.entity.enums;

/**
 * Enumeration representing the possible statuses of a money transfer.
 */
public enum TransferStatus {

    /**
     * The transfer was completed successfully.
     */
    SUCCESS,

    /**
     * The transfer failed to complete.
     */
    FAILED
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\model\entity\Notification.java
================================================================================

package com.example.bankcards.model.entity;

import com.example.bankcards.model.entity.enums.NotificationType;
import jakarta.persistence.*;
import lombok.*;
import java.time.LocalDateTime;

/**
 * Represents a notification sent to a user.
 */
@Entity
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Table(name = "t_notifications")
public class Notification extends BasicEntity {

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @Column(nullable = false, columnDefinition = "TEXT")
    private String message;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private NotificationType type;

    @Column(nullable = false)
    private LocalDateTime createdAt = LocalDateTime.now();

    @Column(nullable = false)
    private Boolean isRead = false;
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\model\entity\QuickTransfer.java
================================================================================

package com.example.bankcards.model.entity;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "t_quick_transfers")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class QuickTransfer extends BasicEntity {
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @Column(nullable = false)
    private String name;

    @Column(nullable = false)
    private String cardNumber;
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\model\entity\RefreshToken.java
================================================================================

package com.example.bankcards.model.entity;

import jakarta.persistence.*;
import lombok.*;

import java.time.Instant;

/**
 * Represents a refresh token used for obtaining new access tokens without re-authentication.
 * Each refresh token is associated with a specific user and has an expiry date.
 */
@Entity
@Table(name = "refresh_tokens")
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
public class RefreshToken {

    /**
     * Unique identifier for the refresh token.
     * Auto-generated.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * The refresh token string itself.
     * Must be unique.
     */
    @Column(nullable = false, unique = true)
    private String token;

    /**
     * The expiration timestamp of the refresh token.
     */
    @Column(nullable = false)
    private Instant expiryDate;

    /**
     * The user associated with this refresh token.
     * One-to-one relationship with the {@link User} entity.
     */
    @OneToOne
    @JoinColumn(name = "user_id", referencedColumnName = "id", nullable = false)
    private User user;

    /**
     * Returns the token string when this object is converted to a string.
     *
     * @return The refresh token string.
     */
    @Override
    public String toString() {
        return token;
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\model\entity\ServiceFee.java
================================================================================

package com.example.bankcards.model.entity;

import com.example.bankcards.model.entity.enums.FeeType;
import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDateTime;

/**
 * Represents a service fee charged to an account.
 */
@Entity
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Table(name = "t_service_fees")
public class ServiceFee extends BasicEntity {

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "account_id", nullable = false)
    private Account account;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private FeeType feeType;

    @Column(nullable = false, precision = 19, scale = 2)
    private BigDecimal amount;

    @Column(nullable = false)
    private LocalDateTime dateCharged;

    @Column(nullable = false)
    private Boolean isPaid = false;
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\model\entity\SupportTicket.java
================================================================================

package com.example.bankcards.model.entity;

import com.example.bankcards.model.entity.enums.TicketPriority;
import com.example.bankcards.model.entity.enums.TicketStatus;
import jakarta.persistence.*;
import lombok.*;

/**
 * Represents a support request (ticket) submitted by a user.
 */
@Entity
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Table(name = "t_support_tickets")
public class SupportTicket extends BasicEntity {

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @Column(nullable = false, length = 150)
    private String subject;

    @Column(nullable = false, columnDefinition = "TEXT")
    private String description;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private TicketStatus status = TicketStatus.OPEN;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private TicketPriority priority = TicketPriority.MEDIUM;

    /**
     * Optional: Admin user assigned to handle the ticket.
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "admin_id")
    private User adminAssigned;
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\model\entity\Transaction.java
================================================================================

package com.example.bankcards.model.entity;

import com.example.bankcards.model.entity.enums.TransactionType;
import com.example.bankcards.model.entity.enums.TransferStatus;
import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDateTime;

/**
 * Represents a detailed financial operation (debit or credit) on an account.
 */
@Entity
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Table(name = "t_transactions")
public class Transaction extends BasicEntity {

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "account_id", nullable = false)
    private Account account;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "card_id") // Can be null if transaction is not card-related (e.g., direct deposit)
    private Card card;

    @Column(nullable = false, precision = 19, scale = 2)
    private BigDecimal amount;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private TransactionType type;

    @Column(nullable = false)
    private LocalDateTime transactionDate;

    @Column(length = 255)
    private String description;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private TransferStatus status = TransferStatus.SUCCESS; // Reuse TransferStatus for simplicity (SUCCESS/FAILED)
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\model\entity\Transfer.java
================================================================================

package com.example.bankcards.model.entity;

import com.example.bankcards.model.entity.enums.TransferStatus;
import jakarta.persistence.*;
import lombok.*;

import java.math.BigDecimal;
import java.time.LocalDateTime;

/**
 * Represents a money transfer transaction between two cards.
 * This entity stores details about the sender, receiver, amount, and status of a transfer.
 * It extends {@link BasicEntity} to inherit common fields like ID and timestamps.
 */
@Entity
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@Table(name = "t_transfers")
public class Transfer extends BasicEntity{

    /**
     * The card from which the money is transferred.
     * Many-to-one relationship with the {@link Card} entity, fetched lazily.
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "from_card_id", nullable = false)
    private Card fromCard;

    /**
     * The card to which the money is transferred.
     * Many-to-one relationship with the {@link Card} entity, fetched lazily.
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "to_card_id", nullable = false)
    private Card toCard;

    /**
     * The amount of money transferred.
     * Stored with a precision of 15 digits and 2 decimal places.
     */
    @Column(nullable = false, precision = 15, scale = 2)
    private BigDecimal amount;

    /**
     * The date and time when the transfer occurred.
     */
    @Column(nullable = false)
    private LocalDateTime transferDate;

    /**
     * The current status of the transfer (e.g., COMPLETED, FAILED, PENDING).
     */
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private TransferStatus status;
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\model\entity\User.java
================================================================================

package com.example.bankcards.model.entity;

import com.example.bankcards.model.entity.enums.Role;
import jakarta.persistence.*;
import jakarta.validation.constraints.Email;
import lombok.*;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;

@Entity
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@Table(name = "t_users")
public class User extends BasicEntity {

    @Column(unique = true, nullable = false, length = 50)
    private String username;

    @Email
    @Column(unique = true, nullable = false, length = 100)
    private String email;

    @Column(nullable = false)
    private String password;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private Role role = Role.ROLE_USER;

    // НОВОЕ ПОЛЕ: Лимит трат (по умолчанию 5000)
    @Column(name = "monthly_limit", precision = 19, scale = 2)
    private BigDecimal monthlyLimit = new BigDecimal("5000.00");

    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<Account> accounts = new ArrayList<>();

    public User(String username, String email, String password, Role role) {
        this.username = username;
        this.email = email;
        this.password = password;
        this.role = role;
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\repository\AccountRepository.java
================================================================================

package com.example.bankcards.repository;

import com.example.bankcards.model.entity.Account;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.List;
import java.util.Optional;

public interface AccountRepository extends JpaRepository<Account, Long> {
    List<Account> findByUserUsername(String username);
    Optional<Account> findByAccountNumber(String accountNumber);
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\repository\CardRepository.java
================================================================================

package com.example.bankcards.repository;

import com.example.bankcards.model.entity.Card;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import java.util.List;

/**
 * Repository interface for {@link com.example.bankcards.model.entity.Card} entities.
 * Provides methods for CRUD operations and custom queries related to bank cards.
 */
public interface CardRepository extends JpaRepository<Card, Long> {

    /**
     * Finds a paginated list of cards associated with a specific username via the Account link. (UPDATED)
     *
     * @param username The username of the user whose cards are to be retrieved.
     * @param pageable Pagination information.
     * @return A {@link Page} of {@link Card} entities belonging to the specified user.
     */
    @Query("SELECT c FROM Card c WHERE c.account.user.username = :username")
    Page<Card> findByUserUsernamePageable(@Param("username") String username, Pageable pageable);

    /**
     * Finds all cards associated with a specific username via the Account link. (UPDATED)
     *
     * @param username The username of the user whose cards are to be retrieved.
     * @return A {@link List} of {@link Card} entities belonging to the specified user.
     */
    List<Card> findByAccount_User_Username(String username); // Используем вывод запросов Spring Data JPA

    // Переименовали старый метод на новый, чтобы соответствовать новой структуре.
    // List<Card> findByUserUsername(String username); // Старый метод удален/заменен
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\repository\NotificationRepository.java
================================================================================

package com.example.bankcards.repository;

import com.example.bankcards.model.entity.Notification;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.List;

public interface NotificationRepository extends JpaRepository<Notification, Long> {
    List<Notification> findByUserUsernameOrderByCreatedAtDesc(String username);
    List<Notification> findByUserUsernameAndIsReadFalseOrderByCreatedAtDesc(String username);
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\repository\QuickTransferRepository.java
================================================================================

package com.example.bankcards.repository;

import com.example.bankcards.model.entity.QuickTransfer;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.List;

public interface QuickTransferRepository extends JpaRepository<QuickTransfer, Long> {
    List<QuickTransfer> findByUserUsername(String username);
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\repository\RefreshTokenRepository.java
================================================================================

package com.example.bankcards.repository;

import com.example.bankcards.model.entity.RefreshToken;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

/**
 * Repository interface for {@link com.example.bankcards.model.entity.RefreshToken} entities.
 * Provides methods for CRUD operations and custom queries related to refresh tokens.
 */
public interface RefreshTokenRepository extends JpaRepository<RefreshToken, Long> {

    /**
     * Finds a refresh token by its token string.
     *
     * @param token The token string of the refresh token.
     * @return An {@link Optional} containing the {@link RefreshToken} if found, otherwise empty.
     */
    Optional<RefreshToken> findByToken(String token);
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\repository\ServiceFeeRepository.java
================================================================================

package com.example.bankcards.repository;

import com.example.bankcards.model.entity.ServiceFee;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.List;

public interface ServiceFeeRepository extends JpaRepository<ServiceFee, Long> {
    List<ServiceFee> findByAccount_User_Username(String username);
    List<ServiceFee> findByAccount_IdAndIsPaidFalse(Long accountId);
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\repository\SupportTicketRepository.java
================================================================================

package com.example.bankcards.repository;

import com.example.bankcards.model.entity.SupportTicket;
import com.example.bankcards.model.entity.enums.TicketStatus;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.List;

public interface SupportTicketRepository extends JpaRepository<SupportTicket, Long> {
    // Найти все тикеты пользователя
    List<SupportTicket> findByUserUsernameOrderByCreatedAtDesc(String username);

    // Найти открытые тикеты для админов
    List<SupportTicket> findByStatusIn(List<TicketStatus> statuses);
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\repository\TransactionRepository.java
================================================================================

package com.example.bankcards.repository;

import com.example.bankcards.model.entity.Transaction;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.List;

public interface TransactionRepository extends JpaRepository<Transaction, Long> {
    // Найти все транзакции по ID счета
    List<Transaction> findByAccountId(Long accountId);

    // Найти все транзакции по имени пользователя (через связь Account -> User)
    Page<Transaction> findByAccount_User_Username(String username, Pageable pageable);
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\repository\TransferRepository.java
================================================================================

package com.example.bankcards.repository;

import com.example.bankcards.model.entity.Transfer;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

import java.util.List;

/**
 * Repository interface for {@link com.example.bankcards.model.entity.Transfer} entities.
 * Provides methods for CRUD operations and custom queries related to money transfers.
 */
public interface TransferRepository extends JpaRepository<Transfer, Long> {

    /**
     * Finds all transfers where the given username is either the sender or receiver.
     * Transfers are ordered by creation date in descending order.
     *
     * @param username The username of the user to find transfers for.
     * @return A {@link List} of {@link Transfer} entities associated with the specified user.
     */
    @Query("SELECT t FROM Transfer t WHERE t.fromCard.account.user.username = :username OR t.toCard.account.user.username = :username ORDER BY t.createdAt DESC")
    List<Transfer> findByUserUsername(@Param("username") String username);

    /**
     * Finds all transfers associated with a specific card ID, either as a source or destination card.
     * Transfers are ordered by creation date in descending order.
     *
     * @param cardId The ID of the card to find transfers for.
     * @return A {@link List} of {@link Transfer} entities associated with the specified card.
     */
    @Query("SELECT t FROM Transfer t WHERE t.fromCard.id = :cardId OR t.toCard.id = :cardId ORDER BY t.createdAt DESC")
    List<Transfer> findByCardId(@Param("cardId") Long cardId);

}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\repository\UserRepository.java
================================================================================

package com.example.bankcards.repository;

import com.example.bankcards.model.entity.User;
import com.example.bankcards.model.entity.enums.Role;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.Optional;

/**
 * Repository interface for {@link com.example.bankcards.model.entity.User} entities.
 * Provides methods for CRUD operations and custom queries related to user accounts.
 */
public interface UserRepository extends JpaRepository<User, Long> {

    /**
     * Finds a user by their username.
     *
     * @param username The username of the user to find.
     * @return An {@link Optional} containing the {@link User} if found, otherwise empty.
     */
    Optional<User> findByUsername(String username);

    /**
     * Checks if any user exists with a specific role.
     *
     * @param role The role to check for existence.
     * @return {@code true} if at least one user with the specified role exists, {@code false} otherwise.
     */
    boolean existsByRole(Role role);
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\security\JwtFilter.java
================================================================================

package com.example.bankcards.security;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.lang.NonNull;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.Arrays;
import java.util.Collections;

@Component
@RequiredArgsConstructor
public class JwtFilter extends OncePerRequestFilter {
    private final JwtUtil jwtUtil;

    @Override
    protected void doFilterInternal(@NonNull HttpServletRequest request,
                                    @NonNull HttpServletResponse response,
                                    @NonNull FilterChain chain)
            throws ServletException, IOException {

        String token = extractToken(request);

        if (token != null) {
            // Лог для отладки (потом уберешь)
            // System.out.println("JwtFilter: Токен найден для пути: " + request.getRequestURI());

            if (jwtUtil.validateToken(token)) {
                String username = jwtUtil.getUsernameFromToken(token);
                String role = jwtUtil.getRoleFromToken(token);

                SimpleGrantedAuthority authority = new SimpleGrantedAuthority(role);
                UsernamePasswordAuthenticationToken auth = new UsernamePasswordAuthenticationToken(
                        username, null, Collections.singletonList(authority));

                SecurityContextHolder.getContext().setAuthentication(auth);
            } else {
                // System.out.println("JwtFilter: Токен невалиден!");
            }
        } else {
            // System.out.println("JwtFilter: Токен НЕ найден для пути: " + request.getRequestURI());
        }
        chain.doFilter(request, response);
    }

    private String extractToken(HttpServletRequest request) {
        // 1. Сначала ищем в Cookies (для браузера)
        if (request.getCookies() != null) {
            return Arrays.stream(request.getCookies())
                    .filter(cookie -> "accessToken".equals(cookie.getName()))
                    .findFirst()
                    .map(Cookie::getValue)
                    .orElse(null);
        }

        // 2. Если нет в куках, ищем в заголовке (для Postman/API)
        String authHeader = request.getHeader("Authorization");
        if (authHeader != null && authHeader.startsWith("Bearer ")) {
            return authHeader.substring(7);
        }

        return null;
    }

    // Исключаем статику и авторизацию из фильтрации, чтобы не спамить логами
    @Override
    protected boolean shouldNotFilter(HttpServletRequest request) {
        String path = request.getRequestURI();
        return path.startsWith("/static") ||
                path.startsWith("/css") ||
                path.startsWith("/js") ||
                path.startsWith("/images") ||
                path.equals("/favicon.ico"); // Игнорируем фавиконку (твоя ошибка 500)
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\security\JwtUtil.java
================================================================================

package com.example.bankcards.security;
import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.security.Key;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.security.Keys;
import jakarta.annotation.PostConstruct;
import lombok.Getter; // Убедитесь, что Lombok импортирован
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.util.Date;
import java.util.UUID;

/**
 * Utility class for JSON Web Token (JWT) operations.
 * Handles generation, validation, and parsing of JWTs for authentication and authorization.
 */
@Component
public class JwtUtil {
    @Value("${jwt.secret}")
    private String secret;

    // Добавляем @Getter, чтобы получить доступ к времени истечения
    @Getter
    @Value("${jwt.access-token.expiration}")
    private long accessTokenExpiration;

    @Getter
    @Value("${jwt.refresh-token.expiration}")
    private long refreshTokenExpiration;
    private SecretKey key;

    /**
     * Initializes the {@link Key} object from the secret string after the bean has been constructed.
     * This method is called automatically by Spring after dependency injection is complete.
     */
    @PostConstruct
    public void init() {
        this.key = Keys.hmacShaKeyFor(secret.getBytes(StandardCharsets.UTF_8));
    }

    /**
     * Generates a new JWT access token for a given username and role.
     * The token includes the subject (username), a custom claim for role,
     * issue date, and expiration date.
     *
     * @param username the subject of the token (e.g., user's identifier).
     * @param role the role of the user, included as a custom claim.
     * @return a compact JWT string.
     */
    public String generateToken(String username, String role) {
        return Jwts.builder()
                .subject(username)
                .claim("role", role)
                .issuedAt(new Date())
                .expiration(new Date(System.currentTimeMillis() + accessTokenExpiration))
                .signWith(key)
                .compact();
    }

    /**
     * Validates a given JWT token.
     * It parses the token using the signing key and checks its integrity and expiration.
     *
     * @param token the JWT string to validate.
     * @return {@code true} if the token is valid, {@code false} otherwise.
     */
    public boolean validateToken(String token) {
        try {
            Jwts.parser()
                    .verifyWith(key)
                    .build()
                    .parseSignedClaims(token);
            return true;
        } catch (Exception e) {
            // В реальном приложении здесь стоит логировать ошибку (например, ExpiredJwtException)
            return false;
        }
    }

    /**
     * Extracts the username (subject) from a valid JWT token.
     *
     * @param token the JWT string from which to extract the username.
     * @return the username (subject) contained within the token.
     */
    public String getUsernameFromToken(String token) {
        return Jwts.parser()
                .verifyWith(key)
                .build()
                .parseSignedClaims(token)
                .getPayload()
                .getSubject();
    }

    /**
     * Extracts the role from a valid JWT token's claims.
     * The role is expected to be stored under the "role" claim.
     *
     * @param token the JWT string from which to extract the role.
     * @return the role string contained within the token's claims.
     */
    public String getRoleFromToken(String token) {
        Claims claims = Jwts.parser()
                .verifyWith(key)
                .build()
                .parseSignedClaims(token)
                .getPayload();
        return claims.get("role", String.class);
    }

    /**
     * Generates a random UUID string to be used as a refresh token.
     *
     * @return a unique string representing a refresh token.
     */
    public String generateRefreshTokenString() {
        return UUID.randomUUID().toString();
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\security\SecurityConfig.java
================================================================================

package com.example.bankcards.security;

import jakarta.servlet.http.HttpServletResponse;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.Arrays;
import java.util.List;

@Configuration
@EnableMethodSecurity
public class SecurityConfig {

    private final JwtFilter jwtFilter;

    public SecurityConfig(JwtFilter jwtFilter) {
        this.jwtFilter = jwtFilter;
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        return http
                .csrf(AbstractHttpConfigurer::disable)
                .cors(cors -> cors.configurationSource(corsConfigurationSource()))
                .authorizeHttpRequests(auth -> auth
                        // Статика (CSS, JS) доступна всем
                        .requestMatchers("/static/**", "/css/**", "/js/**", "/images/**", "/webjars/**").permitAll()

                        // Публичные страницы и эндпоинты авторизации
                        .requestMatchers("/", "/login", "/register").permitAll()
                        .requestMatchers("/api/auth/**", "/v3/**", "/swagger-ui/**").permitAll()

                        // Админская зона
                        .requestMatchers("/admin/**", "/api/admin/**").hasAuthority("ROLE_ADMIN")

                        // Пользовательская зона (Дашборд доступен и юзеру, и админу)
                        .requestMatchers("/dashboard", "/api/user/**").hasAnyAuthority("ROLE_USER", "ROLE_ADMIN")

                        .anyRequest().authenticated()
                )
                .sessionManagement(sess -> sess.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class)
                // ВАЖНО: Обработка ошибок для редиректов в браузере
                .exceptionHandling(e -> e
                        .authenticationEntryPoint((request, response, authException) -> {
                            String uri = request.getRequestURI();
                            // Если запрос к API - возвращаем 401 JSON
                            if (uri.startsWith("/api")) {
                                response.sendError(HttpServletResponse.SC_UNAUTHORIZED, authException.getMessage());
                            } else {
                                // Если запрос к странице - редирект на форму входа
                                response.sendRedirect("/login");
                            }
                        })
                        .accessDeniedHandler((request, response, accessDeniedException) -> {
                            String uri = request.getRequestURI();
                            if (uri.startsWith("/api")) {
                                response.sendError(HttpServletResponse.SC_FORBIDDEN, accessDeniedException.getMessage());
                            } else {
                                // Если прав нет (например, юзер лезет в админку) - кидаем на общий дашборд
                                response.sendRedirect("/dashboard");
                            }
                        })
                )
                .build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(List.of("http://localhost:3000", "http://127.0.0.1:3000"));
        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS", "HEAD"));
        configuration.setAllowedHeaders(List.of("*"));
        configuration.setAllowCredentials(true);
        configuration.setMaxAge(3600L);
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\service\account\AccountService.java
================================================================================

package com.example.bankcards.service.account;

import com.example.bankcards.exception.user.UserNotFoundException;
import com.example.bankcards.model.dto.account.AccountCreateRequest;
import com.example.bankcards.model.dto.account.AccountResponseDto;
import com.example.bankcards.model.entity.Account;
import com.example.bankcards.model.entity.User;
import com.example.bankcards.model.entity.enums.AccountType;
import com.example.bankcards.repository.AccountRepository;
import com.example.bankcards.repository.UserRepository;
import com.example.bankcards.util.mapper.AccountMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

/**
 * Service class for managing bank accounts.
 */
@Service
@RequiredArgsConstructor
@Slf4j
@Transactional(readOnly = true)
public class AccountService {

    private final AccountRepository accountRepository;
    private final UserRepository userRepository;
    private final AccountMapper accountMapper;

    /**
     * Creates a new bank account for a specified user.
     *
     * @param request The request containing account details.
     * @param username The username of the authenticated user creating the account.
     * @return DTO of the newly created account.
     */
    @Transactional
    public AccountResponseDto createAccount(AccountCreateRequest request, String username) {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new UserNotFoundException("User not found: " + username));

        Account account = new Account();
        account.setAccountType(request.getAccountType());
        account.setBalance(BigDecimal.ZERO);
        account.setUser(user);
        account.setAccountNumber(generateUniqueAccountNumber()); // Генерация уникального номера счета

        Account savedAccount = accountRepository.save(account);
        log.info("Created new account {} for user {}", savedAccount.getAccountNumber(), username);

        return accountMapper.toAccountResponseDto(savedAccount);
    }

    /**
     * Retrieves all accounts belonging to the authenticated user.
     *
     * @param username The username of the owner.
     * @return List of account DTOs.
     */
    public List<AccountResponseDto> getMyAccounts(String username) {
        List<Account> accounts = accountRepository.findByUserUsername(username);
        return accounts.stream()
                .map(accountMapper::toAccountResponseDto)
                .collect(Collectors.toList());
    }

    /**
     * Retrieves the total balance across all accounts for a user.
     *
     * @param username The username of the owner.
     * @return Total balance.
     */
    public BigDecimal getTotalBalanceAcrossAccounts(String username) {
        return accountRepository.findByUserUsername(username).stream()
                .map(Account::getBalance)
                .reduce(BigDecimal.ZERO, BigDecimal::add);
    }

    /**
     * Finds an existing CHECKING account for the user or creates a new one if none exists.
     * Used typically when creating a new card that needs to be linked to an account.
     *
     * @param user The user entity.
     * @return An existing or newly created default CHECKING account.
     */
    @Transactional
    public Account findOrCreateDefaultAccount(User user) {
        // Try to find an existing CHECKING account
        // Используем список accounts, который загружается лениво, но MapStruct его не использует,
        // поэтому для этой операции нам нужно убедиться, что список доступен или использовать репозиторий.
        // Поскольку User уже загружен, используем его список:

        return user.getAccounts().stream()
                .filter(a -> a.getAccountType() == AccountType.CHECKING)
                .findFirst()
                .orElseGet(() -> {
                    // If no CHECKING account exists, create one
                    Account account = new Account();
                    account.setAccountType(AccountType.CHECKING);
                    account.setBalance(BigDecimal.ZERO);
                    account.setUser(user);
                    account.setAccountNumber(generateUniqueAccountNumber());
                    log.info("Creating default CHECKING account {} for user {}", account.getAccountNumber(), user.getUsername());
                    return accountRepository.save(account);
                });
    }

    /**
     * Helper method to generate a unique account number (e.g., 16 digits).
     * NOTE: In a production environment, this requires robust, thread-safe, and collision-resistant logic.
     */
    private String generateUniqueAccountNumber() {
        // Простой пример генерации, в реальности нужна проверка на уникальность в БД
        return UUID.randomUUID().toString().replaceAll("-", "").substring(0, 16).toUpperCase();
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\service\admin\AdminUserService.java
================================================================================

package com.example.bankcards.service.admin;

import com.example.bankcards.exception.user.UserNotFoundException;
import com.example.bankcards.model.dto.user.UserResponseDto;
import com.example.bankcards.model.dto.user.UserUpdateRequest;
import com.example.bankcards.model.entity.User;
import com.example.bankcards.repository.UserRepository;
import com.example.bankcards.util.mapper.UserMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

/**
 * Service class for managing user-related operations specifically for administrators.
 * This service provides functionalities to retrieve, update, and delete user accounts.
 */
@Service
@RequiredArgsConstructor
@Slf4j
@Transactional(readOnly = true)
public class AdminUserService {
    private final UserRepository userRepository;
    private final UserMapper userMapper;

    /**
     * Retrieves a list of all registered users.
     *
     * @return A {@link List} of {@link UserResponseDto} representing all users.
     */
    public List<UserResponseDto> getAllUsers() {
        return userRepository.findAll().stream()
                .map(userMapper::toUserResponseDto)
                .collect(Collectors.toList());
    }

    /**
     * Retrieves details of a specific user by their ID.
     *
     * @param id The ID of the user to retrieve.
     * @return A {@link UserResponseDto} containing the user's details.
     * @throws UserNotFoundException if no user is found with the given ID.
     */
    public UserResponseDto getUserById(Long id) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new UserNotFoundException("User not found with ID: " + id));
        return userMapper.toUserResponseDto(user);
    }

    /**
     * Updates details of an existing user by their ID.
     *
     * @param id The ID of the user to update.
     * @param request The request containing the updated user details (username, email, role).
     * @return A {@link UserResponseDto} containing the updated user's details.
     * @throws UserNotFoundException if no user is found with the given ID.
     */
    @Transactional
    public UserResponseDto updateUser(Long id, UserUpdateRequest request) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new UserNotFoundException("User not found with ID: " + id));
        user.setUsername(request.getUsername());
        user.setUsername(request.getUsername());
        user.setEmail(request.getEmail());
        user.setRole(request.getRole());

        User updatedUser = userRepository.save(user);
        log.info("User with ID {} updated by admin.", id);
        return userMapper.toUserResponseDto(updatedUser);
    }

    /**
     * Deletes a user permanently by their ID.
     *
     * @param id The ID of the user to delete.
     * @throws UserNotFoundException if no user is found with the given ID.
     */
    @Transactional
    public void deleteUser(Long id) {
        if (!userRepository.existsById(id)) {
            throw new UserNotFoundException("User not found with ID: " + id);
        }
        userRepository.deleteById(id);
        log.info("User with ID {} deleted by admin.", id);
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\service\auth\AuthService.java
================================================================================

package com.example.bankcards.service.auth;

import com.example.bankcards.exception.user.AuthenticationFailedException;
import com.example.bankcards.exception.user.DuplicateUsernameException;
import com.example.bankcards.exception.user.TokenExpiredException;
import com.example.bankcards.model.dto.auth.AuthResponseDto;
import com.example.bankcards.model.entity.RefreshToken;
import com.example.bankcards.model.entity.User;
import com.example.bankcards.model.entity.enums.Role;
import com.example.bankcards.repository.RefreshTokenRepository;
import com.example.bankcards.repository.UserRepository;
import com.example.bankcards.security.JwtUtil;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.Instant;
import java.util.Optional;

/**
 * Service class for handling user authentication, including login, registration, and token refreshing.
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class AuthService {

    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    private final RefreshTokenRepository refreshTokenRepository;
    private final JwtUtil jwtUtil;

    /**
     * Authenticates a user with the provided username and password.
     * If authentication is successful, generates and returns an access token and a refresh token.
     *
     * @param username The username of the user attempting to log in.
     * @param password The password of the user attempting to log in.
     * @return An {@link AuthResponseDto} containing the generated access token and refresh token.
     * @throws AuthenticationFailedException if the username or password is invalid.
     */
    @Transactional
    public AuthResponseDto login(String username, String password) {
        Optional<User> userOptional = userRepository.findByUsername(username);

        if(userOptional.isPresent()) {
            User user = userOptional.get();
            if(passwordEncoder.matches(password, user.getPassword())) {
                String token = jwtUtil.generateToken(user.getUsername(), user.getRole().name());
                RefreshToken refreshToken = createAndSaveRefreshToken(user);
                log.info("Login Success for user: {}", username);
                return new AuthResponseDto(token, refreshToken.getToken());
            }
        }
        log.warn("Authentication failed for user: {}", username);
        throw new AuthenticationFailedException("Invalid username or password");
    }

    /**
     * Registers a new user with the provided username, email, and password.
     * If registration is successful, generates and returns an access token and a refresh token for the new user.
     * The new user is assigned the 'ROLE_USER' role by default.
     *
     * @param username The desired username for the new user.
     * @param email The email address for the new user.
     * @param password The desired password for the new user.
     * @return An {@link AuthResponseDto} containing the generated access token and refresh token for the new user.
     * @throws DuplicateUsernameException if a user with the provided username already exists.
     */
    @Transactional
    public AuthResponseDto register(String username,String email, String password) {
        if(userRepository.findByUsername(username).isPresent()) {
            log.warn("Registration failed: Username '{}' already exists", username);
            throw new DuplicateUsernameException("Username" + username + " already exists");
        }
        String encodedPassword = passwordEncoder.encode(password);
        User newUser = new User(username, email, encodedPassword, Role.valueOf("ROLE_USER"));
        userRepository.save(newUser);
        String token = jwtUtil.generateToken(newUser.getUsername(), newUser.getRole().name());
        RefreshToken refreshToken = createAndSaveRefreshToken(newUser);
        log.info("Register Success for user: {}", username);
        return new AuthResponseDto(token, refreshToken.getToken());
    }

    /**
     * Creates and saves a new refresh token for the given user.
     *
     * @param user The user for whom to create the refresh token.
     * @return The newly created and saved {@link RefreshToken} object.
     */
    private RefreshToken createAndSaveRefreshToken(User user) {
        RefreshToken refreshToken = new RefreshToken();
        refreshToken.setUser(user);
        refreshToken.setToken(jwtUtil.generateRefreshTokenString());
        refreshToken.setExpiryDate(Instant.now().plusMillis(jwtUtil.getRefreshTokenExpiration()));
        log.info("Refresh Token created for user: {}", user.getUsername());
        return refreshTokenRepository.save(refreshToken);
    }

    /**
     * Refreshes an access token using a provided refresh token.
     * Invalidates the old refresh token and issues a new one along with a new access token.
     *
     * @param refreshTokenString The string representation of the refresh token.
     * @return An {@link AuthResponseDto} containing the new access token and new refresh token.
     * @throws TokenExpiredException if the refresh token is not found, is invalid, or has expired,
     *                          or if the user associated with the refresh token is not found.
     */
    @Transactional
    public AuthResponseDto refreshAccessToken(String refreshTokenString) {
        Optional<RefreshToken> optionalRefreshToken = refreshTokenRepository.findByToken(refreshTokenString);
        if (optionalRefreshToken.isEmpty()) {
            throw new TokenExpiredException("Refresh Token not found or expired.");
        }
        RefreshToken refreshToken = optionalRefreshToken.get();
        if (refreshToken.getExpiryDate().isBefore(Instant.now())) {
            refreshTokenRepository.delete(refreshToken);
            throw new TokenExpiredException("Refresh Token expired.");
        }
        User user = refreshToken.getUser();
        if (user == null) {
            throw new TokenExpiredException("Refresh token not found.");
        }
        String newAccessToken = jwtUtil.generateToken(user.getUsername(), user.getRole().name());
        refreshTokenRepository.delete(refreshToken);
        RefreshToken newRefreshToken = createAndSaveRefreshToken(user);
        log.info("Access Token refreshed for user: {}", user.getUsername());

        return new AuthResponseDto(newAccessToken, newRefreshToken.getToken());
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\service\card\CardEncryptionService.java
================================================================================

package com.example.bankcards.service.card;

import com.example.bankcards.util.CardMaskingUtil;
import com.example.bankcards.util.EncryptionUtil;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

/**
 * Service class responsible for encrypting, decrypting, and masking card numbers.
 * It utilizes {@link EncryptionUtil} for cryptographic operations and {@link CardMaskingUtil} for masking.
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class CardEncryptionService {

    private final EncryptionUtil encryptionUtil;

    /**
     * Encrypts a plain card number.
     *
     * @param plainCardNumber The unencrypted card number string.
     * @return The encrypted card number string.
     * @throws IllegalArgumentException if the plain card number is null, empty, or has an invalid format.
     * @throws RuntimeException if the encryption process fails.
     */
    public String encryptCardNumber(String plainCardNumber) {
        if (plainCardNumber == null || plainCardNumber.trim().isEmpty()) {
            throw new IllegalArgumentException("Card number cannot be null or empty");
        }

        String cleanedCardNumber = plainCardNumber.replaceAll("[\\s-]", "");

        if (!CardMaskingUtil.isValidCardNumber(cleanedCardNumber)) {
            throw new IllegalArgumentException("Invalid card number format");
        }

        try {
            String encrypted = encryptionUtil.encrypt(cleanedCardNumber);
            log.debug("Card number encrypted successfully");
            return encrypted;
        } catch (Exception e) {
            log.error("Failed to encrypt card number", e);
            throw new RuntimeException("Failed to encrypt card number", e);
        }
    }

    /**
     * Decrypts an encrypted card number.
     *
     * @param encryptedCardNumber The encrypted card number string.
     * @return The decrypted (plain) card number string.
     * @throws IllegalArgumentException if the encrypted card number is null or empty.
     * @throws RuntimeException if the decryption process fails.
     */
    public String decryptCardNumber(String encryptedCardNumber) {
        if (encryptedCardNumber == null || encryptedCardNumber.trim().isEmpty()) {
            throw new IllegalArgumentException("Encrypted card number cannot be null or empty");
        }

        try {
            String decrypted = encryptionUtil.decrypt(encryptedCardNumber);
            log.debug("Card number decrypted successfully");
            return decrypted;
        } catch (Exception e) {
            log.error("Failed to decrypt card number", e);
            throw new RuntimeException("Failed to decrypt card number", e);
        }
    }

    /**
     * Retrieves a masked version of an encrypted card number.
     * The card number is first decrypted and then masked.
     *
     * @param encryptedCardNumber The encrypted card number string.
     * @return The masked card number string (e.g., "************1234"). Returns "****" if decryption fails.
     */
    public String getMaskedCardNumber(String encryptedCardNumber) {
        try {
            String plainCardNumber = decryptCardNumber(encryptedCardNumber);
            return CardMaskingUtil.maskCardNumber(plainCardNumber);
        } catch (Exception e) {
            log.error("Failed to get masked card number", e);
            return "****";
        }
    }

    /**
     * Compares a plain card number with an encrypted card number to check if they match.
     * The encrypted card number is decrypted internally for comparison.
     *
     * @param plainCardNumber The plain card number string.
     * @param encryptedCardNumber The encrypted card number string.
     * @return {@code true} if the plain card number matches the decrypted encrypted card number, {@code false} otherwise.
     */
    public boolean matchesCardNumber(String plainCardNumber, String encryptedCardNumber) {
        if (plainCardNumber == null || encryptedCardNumber == null) {
            return false;
        }

        try {
            String cleanedPlainNumber = plainCardNumber.replaceAll("[\\s-]", "");
            return encryptionUtil.matches(cleanedPlainNumber, encryptedCardNumber);
        } catch (Exception e) {
            log.error("Failed to match card numbers", e);
            return false;
        }
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\service\card\CardService.java
================================================================================

package com.example.bankcards.service.card;

import com.example.bankcards.exception.card.CardStatusException;
import com.example.bankcards.exception.user.UserNotFoundException;
import com.example.bankcards.model.dto.card.CardCreateRequest;
import com.example.bankcards.model.dto.card.CardResponseDto;
import com.example.bankcards.model.dto.card.CardUpdateRequest;
import com.example.bankcards.model.entity.Account;
import com.example.bankcards.model.entity.Card;
import com.example.bankcards.model.entity.User;
import com.example.bankcards.model.entity.enums.CardStatus;
import com.example.bankcards.exception.card.CardNotFoundException;
import com.example.bankcards.repository.CardRepository;
import com.example.bankcards.repository.UserRepository;
import com.example.bankcards.service.account.AccountService;
import com.example.bankcards.util.mapper.CardMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

/**
 * Service class for managing bank card operations.
 * This service handles the creation, retrieval, updating, deletion,
 * blocking, and activation of bank cards. It interacts with {@link CardRepository},
 * {@link UserRepository}, and {@link CardEncryptionService}.
 */
@Service
@RequiredArgsConstructor
@Slf4j
@Transactional(readOnly = true)
public class CardService {

    private final CardRepository cardRepository;
    private final UserRepository userRepository;
    private final CardEncryptionService cardEncryptionService;
    private final CardMapper cardMapper;
    private final AccountService accountService; // Injected AccountService

    /**
     * Creates a new bank card for a specified user.
     * The card number is encrypted before saving.
     *
     * @param request The {@link CardCreateRequest} containing details for the new card.
     * @return A {@link CardResponseDto} representing the newly created card with its number masked.
     * @throws UserNotFoundException if the user specified by {@code userId} in the request is not found.
     * @throws IllegalArgumentException if the card number in the request is invalid.
     * @throws RuntimeException if card number encryption fails.
     */
    @Transactional
    public CardResponseDto createCard(CardCreateRequest request) {
        User user = userRepository.findById(request.getUserId())
                .orElseThrow(() -> new UserNotFoundException("User not found"));

        // Find or create a default account for the user
        Account account = accountService.findOrCreateDefaultAccount(user);

        String encryptedCardNumber = cardEncryptionService.encryptCardNumber(request.getCardNumber());

        Card card = new Card();
        card.setCardNumber(encryptedCardNumber);
        card.setCardHolder(request.getCardHolder());
        card.setExpiryDate(request.getExpiryDate());
        card.setBalance(request.getBalance());
        card.setCardStatus(CardStatus.ACTIVE);
        card.setAccount(account); // Link card to account

        Card savedCard = cardRepository.save(card);
        log.info("Created card with ID: {}", savedCard.getId());
        CardResponseDto dto = cardMapper.toCardResponseDto(savedCard);
        dto.setCardNumber(cardEncryptionService.getMaskedCardNumber(savedCard.getCardNumber()));
        return dto;
    }

    /**
     * Retrieves a paginated list of all bank cards.
     * Card numbers in the response are masked.
     *
     * @param pageable The pagination information.
     * @return A {@link Page} of {@link CardResponseDto} representing all cards.
     */
    public Page<CardResponseDto> getAllCards(Pageable pageable) {
        Page<Card> cards = cardRepository.findAll(pageable);
        return cards.map(card -> {
            CardResponseDto dto = cardMapper.toCardResponseDto(card);
            dto.setCardNumber(cardEncryptionService.getMaskedCardNumber(card.getCardNumber()));
            return dto;
        });
    }

    /**
     * Retrieves details of a specific bank card by its ID.
     * The card number in the response is masked.
     *
     * @param id The ID of the card to retrieve.
     * @return A {@link CardResponseDto} representing the retrieved card with its number masked.
     * @throws CardNotFoundException if no card is found with the given ID.
     */
    public CardResponseDto getCardById(Long id) {
        Card card = cardRepository.findById(id)
                .orElseThrow(() -> new CardNotFoundException("Card not found"));
        CardResponseDto dto = cardMapper.toCardResponseDto(card);
        dto.setCardNumber(cardEncryptionService.getMaskedCardNumber(card.getCardNumber()));
        return dto;
    }

    /**
     * Updates details of an existing bank card.
     * Only provided fields in the request will be updated.
     * The card number in the response is masked.
     *
     * @param id The ID of the card to update.
     * @param request The {@link CardUpdateRequest} containing the fields to update.
     * @return A {@link CardResponseDto} representing the updated card with its number masked.
     * @throws CardNotFoundException if no card is found with the given ID.
     */
    @Transactional
    public CardResponseDto updateCard(Long id, CardUpdateRequest request) {
        Card card = cardRepository.findById(id)
                .orElseThrow(() -> new CardNotFoundException("Card not found"));

        if (request.getCardHolder() != null) {
            card.setCardHolder(request.getCardHolder());
        }
        if (request.getExpiryDate() != null) {
            card.setExpiryDate(request.getExpiryDate());
        }
        if (request.getCardStatus() != null) {
            card.setCardStatus(request.getCardStatus());
        }
        if (request.getBalance() != null) {
            card.setBalance(request.getBalance());
        }

        Card savedCard = cardRepository.save(card);
        log.info("Updated card with ID: {}", savedCard.getId());
        CardResponseDto dto = cardMapper.toCardResponseDto(savedCard);
        dto.setCardNumber(cardEncryptionService.getMaskedCardNumber(savedCard.getCardNumber()));
        return dto;
    }

    /**
     * Deletes a bank card permanently by its ID.
     *
     * @param id The ID of the card to delete.
     * @throws CardNotFoundException if no card is found with the given ID.
     */
    @Transactional
    public void deleteCard(Long id) {
        Card card = cardRepository.findById(id)
                .orElseThrow(() -> new CardNotFoundException("Card not found"));
        cardRepository.delete(card);
        log.info("Deleted card with ID: {}", id);
    }

    /**
     * Blocks a specific bank card by changing its status to {@code BLOCKED}.
     * The card number in the response is masked.
     *
     * @param id The ID of the card to block.
     * @return A {@link CardResponseDto} representing the blocked card with its number masked.
     * @throws CardNotFoundException if no card is found with the given ID.
     * @throws CardStatusException if the card is already blocked or pending block.
     */
    @Transactional
    public CardResponseDto blockCard(Long id) {
        Card card = cardRepository.findById(id)
                .orElseThrow(() -> new CardNotFoundException("Card not found"));

        if (card.getCardStatus() == CardStatus.BLOCKED || card.getCardStatus() == CardStatus.PENDING_BLOCK) {
            throw new CardStatusException("Card is already blocked or pending block.");
        }

        card.setCardStatus(CardStatus.BLOCKED);
        Card savedCard = cardRepository.save(card);
        log.info("Blocked card with ID: {}", id);
        CardResponseDto dto = cardMapper.toCardResponseDto(savedCard);
        dto.setCardNumber(cardEncryptionService.getMaskedCardNumber(savedCard.getCardNumber()));
        return dto;
    }

    /**
     * Activates a previously blocked or inactive bank card by changing its status to {@code ACTIVE}.
     * The card number in the response is masked.
     *
     * @param id The ID of the card to activate.
     * @return A {@link CardResponseDto} representing the activated card with its number masked.
     * @throws CardNotFoundException if no card is found with the given ID.
     * @throws CardStatusException if the card is already active or pending unblock.
     */
    @Transactional
    public CardResponseDto activateCard(Long id) {
        Card card = cardRepository.findById(id)
                .orElseThrow(() -> new CardNotFoundException("Card not found"));

        if (card.getCardStatus() == CardStatus.ACTIVE || card.getCardStatus() == CardStatus.PENDING_UNBLOCK) {
            throw new CardStatusException("Card is already active or pending unblock.");
        }

        card.setCardStatus(CardStatus.ACTIVE);
        Card savedCard = cardRepository.save(card);
        log.info("Activated card with ID: {}", id);
        CardResponseDto dto = cardMapper.toCardResponseDto(savedCard);
        dto.setCardNumber(cardEncryptionService.getMaskedCardNumber(savedCard.getCardNumber()));
        return dto;
    }

    /**
     * Approves a pending block request for a card, changing its status to BLOCKED.
     *
     * @param id The ID of the card to approve blocking for.
     * @return A {@link CardResponseDto} representing the blocked card.
     * @throws CardNotFoundException if no card is found with the given ID.
     * @throws CardStatusException if the card is not in PENDING_BLOCK state.
     */
    @Transactional
    public CardResponseDto approveBlockRequest(Long id) {
        log.info("Admin attempting to approve block request for card ID: {}", id);
        Card card = cardRepository.findById(id)
                .orElseThrow(() -> {
                    log.warn("Card not found with ID: {}", id);
                    return new CardNotFoundException("Card not found");
                });

        if (card.getCardStatus() != CardStatus.PENDING_BLOCK) {
            log.warn("Cannot approve block request for card ID: {}. Current status is not PENDING_BLOCK: {}", id, card.getCardStatus());
            throw new CardStatusException("Card is not in PENDING_BLOCK status.");
        }

        card.setCardStatus(CardStatus.BLOCKED);
        Card savedCard = cardRepository.save(card);
        log.info("Successfully approved block request for card ID: {}. New status: BLOCKED", id);
        CardResponseDto dto = cardMapper.toCardResponseDto(savedCard);
        dto.setCardNumber(cardEncryptionService.getMaskedCardNumber(savedCard.getCardNumber()));
        return dto;
    }

    /**
     * Approves a pending unblock request for a card, changing its status to ACTIVE.
     *
     * @param id The ID of the card to approve unblocking for.
     * @return A {@link CardResponseDto} representing the activated card.
     * @throws CardNotFoundException if no card is found with the given ID.
     * @throws CardStatusException if the card is not in PENDING_UNBLOCK state.
     */
    @Transactional
    public CardResponseDto approveUnblockRequest(Long id) {
        log.info("Admin attempting to approve unblock request for card ID: {}", id);
        Card card = cardRepository.findById(id)
                .orElseThrow(() -> {
                    log.warn("Card not found with ID: {}", id);
                    return new CardNotFoundException("Card not found");
                });

        if (card.getCardStatus() != CardStatus.PENDING_UNBLOCK) {
            log.warn("Cannot approve unblock request for card ID: {}. Current status is not PENDING_UNBLOCK: {}", id, card.getCardStatus());
            throw new CardStatusException("Card is not in PENDING_UNBLOCK status.");
        }

        card.setCardStatus(CardStatus.ACTIVE);
        Card savedCard = cardRepository.save(card);
        log.info("Successfully approved unblock request for card ID: {}. New status: ACTIVE", id);
        CardResponseDto dto = cardMapper.toCardResponseDto(savedCard);
        dto.setCardNumber(cardEncryptionService.getMaskedCardNumber(savedCard.getCardNumber()));
        return dto;
    }

    // ... (внутри CardService)

    @Transactional
    public CardResponseDto deposit(Long id, java.math.BigDecimal amount) {
        Card card = cardRepository.findById(id)
                .orElseThrow(() -> new CardNotFoundException("Card not found"));

        if (amount.compareTo(java.math.BigDecimal.ZERO) <= 0) {
            throw new IllegalArgumentException("Amount must be positive");
        }

        card.setBalance(card.getBalance().add(amount));
        // Также обновляем баланс счета (аккаунта), так как карта привязана к нему
        card.getAccount().setBalance(card.getAccount().getBalance().add(amount));

        Card savedCard = cardRepository.save(card);
        log.info("Deposited {} to card {}", amount, id);

        CardResponseDto dto = cardMapper.toCardResponseDto(savedCard);
        dto.setCardNumber(cardEncryptionService.getMaskedCardNumber(savedCard.getCardNumber()));
        return dto;
    }

    @Transactional
    public CardResponseDto withdraw(Long id, java.math.BigDecimal amount) {
        Card card = cardRepository.findById(id)
                .orElseThrow(() -> new CardNotFoundException("Card not found"));

        if (amount.compareTo(java.math.BigDecimal.ZERO) <= 0) {
            throw new IllegalArgumentException("Amount must be positive");
        }
        if (card.getBalance().compareTo(amount) < 0) {
            throw new com.example.bankcards.exception.card.InsufficientFundsException("Insufficient funds");
        }

        card.setBalance(card.getBalance().subtract(amount));
        card.getAccount().setBalance(card.getAccount().getBalance().subtract(amount));

        Card savedCard = cardRepository.save(card);
        log.info("Withdrew {} from card {}", amount, id);

        CardResponseDto dto = cardMapper.toCardResponseDto(savedCard);
        dto.setCardNumber(cardEncryptionService.getMaskedCardNumber(savedCard.getCardNumber()));
        return dto;
    }

    // ... внутри класса

    @Transactional
    public CardResponseDto declineRequest(Long id) {
        Card card = cardRepository.findById(id)
                .orElseThrow(() -> new CardNotFoundException("Card not found"));

        if (card.getCardStatus() == CardStatus.PENDING_BLOCK) {
            // Отклоняем блокировку -> возвращаем в ACTIVE
            card.setCardStatus(CardStatus.ACTIVE);
            log.info("Block request declined for card {}", id);
        } else if (card.getCardStatus() == CardStatus.PENDING_UNBLOCK) {
            // Отклоняем разблокировку -> возвращаем в BLOCKED
            card.setCardStatus(CardStatus.BLOCKED);
            log.info("Unblock request declined for card {}", id);
        } else {
            throw new CardStatusException("Card has no pending requests.");
        }

        Card savedCard = cardRepository.save(card);
        CardResponseDto dto = cardMapper.toCardResponseDto(savedCard);
        dto.setCardNumber(cardEncryptionService.getMaskedCardNumber(savedCard.getCardNumber()));
        return dto;
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\service\card\UserCardService.java
================================================================================

package com.example.bankcards.service.card;

import com.example.bankcards.exception.card.CardOwnershipException;
import com.example.bankcards.exception.card.CardStatusException;
import com.example.bankcards.model.dto.card.CardResponseDto;
import com.example.bankcards.model.entity.Card;
import com.example.bankcards.model.entity.enums.CardStatus;
import com.example.bankcards.exception.card.CardNotFoundException;
import com.example.bankcards.repository.CardRepository;
import com.example.bankcards.util.mapper.CardMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.util.List;

/**
 * Service class for managing bank card operations for regular users.
 * This service provides functionalities for users to view their cards,
 * request blocking/unblocking, and check their total balance.
 */
@Service
@RequiredArgsConstructor
@Slf4j
@Transactional(readOnly = true)
public class UserCardService {

    private final CardMapper cardMapper;
    private final CardRepository cardRepository;
    private final CardEncryptionService cardEncryptionService;

    /**
     * Calculates the total balance across all active bank cards owned by a specific user.
     *
     * @param username The username of the user whose total balance is to be calculated.
     * @return A {@link BigDecimal} representing the sum of balances of all active cards.
     */
    public BigDecimal getTotalBalance(String username) {
        // Использование нового метода репозитория
        List<Card> cards = cardRepository.findByAccount_User_Username(username);
        return cards.stream()
                .filter(card -> card.getCardStatus() == CardStatus.ACTIVE)
                .map(Card::getBalance)
                .reduce(BigDecimal.ZERO, BigDecimal::add);
    }

    /**
     * Submits a request to unblock a specific card owned by the authenticated user.
     * Changes the card status to {@code PENDING_UNBLOCK} to indicate a request.
     *
     * @param cardId The ID of the card to request unblocking for.
     * @param username The username of the user who owns the card.
     * @throws CardNotFoundException if no card is found with the given ID.
     * @throws CardOwnershipException if the card does not belong to the specified user.
     * @throws CardStatusException if the card is already active or in a pending unblock state.
     */
    @Transactional
    public void requestUnblock(Long cardId, String username) {
        Card card = cardRepository.findById(cardId)
                .orElseThrow(() -> new CardNotFoundException("Card not found"));

        // Проверка владения через Account
        if (!card.getAccount().getUser().getUsername().equals(username)) {
            throw new CardOwnershipException("Access denied: Card doesn't belong to user");
        }
        if (card.getCardStatus() != CardStatus.BLOCKED) {
            throw new CardStatusException("Card is not blocked");
        }
        log.info("User {} requested unblock for card {}", username, cardEncryptionService.getMaskedCardNumber(card.getCardNumber()));
        card.setCardStatus(CardStatus.PENDING_UNBLOCK);
    }

    /**
     * Submits a request to block a specific card owned by the authenticated user.
     * Changes the card status to {@code PENDING_BLOCK} to indicate a request.
     *
     * @param cardId The ID of the card to request blocking for.
     * @param username The username of the user who owns the card.
     * @throws CardNotFoundException if no card is found with the given ID.
     * @throws CardOwnershipException if the card does not belong to the specified user.
     * @throws CardStatusException if the card is already blocked or in a pending block state.
     */
    @Transactional
    public void requestBlock(Long cardId, String username) {
        Card card = cardRepository.findById(cardId)
                .orElseThrow(() -> new CardNotFoundException("Card not found"));

        // Проверка владения через Account
        if (!card.getAccount().getUser().getUsername().equals(username)) {
            throw new CardOwnershipException("Access denied: Card doesn't belong to user");
        }
        if (card.getCardStatus() == CardStatus.BLOCKED) {
            throw new CardStatusException("Card is already blocked");
        }
        log.info("User {} requested block for card {}", username, cardEncryptionService.getMaskedCardNumber(card.getCardNumber()));
        card.setCardStatus(CardStatus.PENDING_BLOCK);
    }

    /**
     * Retrieves a paginated list of bank cards owned by a specific user.
     * Card numbers in the response are masked.
     *
     * @param username The username of the user whose cards are to be retrieved.
     * @param pageable Pagination information.
     * @return A {@link Page} of {@link CardResponseDto} representing the user's cards.
     */
    public Page<CardResponseDto> getUserCards(String username, Pageable pageable) {
        // Использует метод, который был обновлен в CardRepository
        Page<Card> cardsPage = cardRepository.findByUserUsernamePageable(username, pageable);
        return cardsPage.map(card -> {
            CardResponseDto dto = cardMapper.toCardResponseDto(card);
            dto.setCardNumber(cardEncryptionService.getMaskedCardNumber(card.getCardNumber()));
            return dto;
        });
    }

    /**
     * Retrieves details of a specific bank card by its ID, ensuring it belongs to the specified user.
     * The card number in the response is masked.
     *
     * @param cardId The ID of the card to retrieve.
     * @param username The username of the user who should own the card.
     * @return A {@link CardResponseDto} representing the retrieved card.
     * @throws CardNotFoundException if no card is found with the given ID.
     * @throws CardOwnershipException if the card does not belong to the specified user.
     */
    public CardResponseDto getUserCardById(Long cardId, String username) {
        Card card = cardRepository.findById(cardId)
                .orElseThrow(() -> new CardNotFoundException("Card not found"));

        // Проверка владения через Account
        if(!card.getAccount().getUser().getUsername().equals(username)) {
            throw new CardOwnershipException("Access denied: Card doesn't belong to user");
        }
        CardResponseDto dto = cardMapper.toCardResponseDto(card);
        dto.setCardNumber(cardEncryptionService.getMaskedCardNumber(card.getCardNumber()));
        return dto;
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\service\fee\ServiceFeeService.java
================================================================================

package com.example.bankcards.service.fee;

import com.example.bankcards.exception.account.AccountNotFoundException;
import com.example.bankcards.exception.dto.ForbiddenException;
import com.example.bankcards.model.dto.fee.ServiceFeeResponseDto;
import com.example.bankcards.model.entity.Account;
import com.example.bankcards.model.entity.ServiceFee;
import com.example.bankcards.model.entity.Transaction;
import com.example.bankcards.model.entity.enums.FeeType;
import com.example.bankcards.model.entity.enums.NotificationType;
import com.example.bankcards.model.entity.enums.TransferStatus;
import com.example.bankcards.model.entity.enums.TransactionType;
import com.example.bankcards.repository.AccountRepository;
import com.example.bankcards.repository.ServiceFeeRepository;
import com.example.bankcards.repository.TransactionRepository;
import com.example.bankcards.service.notification.NotificationService;
import com.example.bankcards.util.mapper.ServiceFeeMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Service class for managing service fees and charging them to accounts.
 */
@Service
@RequiredArgsConstructor
@Slf4j
@Transactional(readOnly = true)
public class ServiceFeeService {

    private final ServiceFeeRepository serviceFeeRepository;
    private final AccountRepository accountRepository;
    private final TransactionRepository transactionRepository;
    private final ServiceFeeMapper serviceFeeMapper;
    private final NotificationService notificationService;

    /**
     * Retrieves all fees associated with the authenticated user's accounts.
     *
     * @param username The username of the user.
     * @return List of fee DTOs.
     */
    public List<ServiceFeeResponseDto> getMyFees(String username) {
        return serviceFeeRepository.findByAccount_User_Username(username).stream()
                .map(serviceFeeMapper::toServiceFeeResponseDto)
                .collect(Collectors.toList());
    }

    /**
     * Charges a specific fee to an account. This is typically an internal process.
     *
     * @param accountId The ID of the account to charge.
     * @param amount The amount of the fee.
     * @param feeType The type of fee.
     * @return The created ServiceFee entity.
     */
    @Transactional
    public ServiceFee chargeFee(Long accountId, BigDecimal amount, FeeType feeType) {
        Account account = accountRepository.findById(accountId)
                .orElseThrow(() -> new AccountNotFoundException("Account not found with ID: " + accountId));

        ServiceFee fee = new ServiceFee();
        fee.setAccount(account);
        fee.setAmount(amount);
        fee.setFeeType(feeType);
        fee.setDateCharged(LocalDateTime.now());
        fee.setIsPaid(false); // Изначально не оплачено

        ServiceFee savedFee = serviceFeeRepository.save(fee);
        log.info("Fee of {} charged to account {} (Type: {})", amount, accountId, feeType);

        // Попытка немедленного списания
        try {
            processFeePayment(savedFee);
        } catch (Exception e) {
            log.warn("Immediate payment failed for fee {}. Will remain unpaid.", savedFee.getId());
            // Уведомление пользователя о начислении (даже если не списано)
            notificationService.createNotification(
                    account.getUser().getUsername(),
                    String.format("Fee charged: %s of %.2f. Status: Pending payment.", feeType.name(), amount),
                    NotificationType.ALERT
            );
        }

        return savedFee;
    }

    /**
     * Processes the payment for a specific fee, debiting the account balance.
     *
     * @param fee The ServiceFee entity to process.
     */
    @Transactional
    public void processFeePayment(ServiceFee fee) {
        if (fee.getIsPaid()) {
            return; // Уже оплачено
        }

        Account account = fee.getAccount();
        BigDecimal amount = fee.getAmount();

        if (account.getBalance().compareTo(amount) >= 0) {
            // 1. Списание с баланса счета
            account.setBalance(account.getBalance().subtract(amount));
            accountRepository.save(account);

            // 2. Запись детальной транзакции
            recordFeeTransaction(account, amount, fee.getFeeType());

            // 3. Обновление статуса комиссии
            fee.setIsPaid(true);
            serviceFeeRepository.save(fee);

            // 4. Уведомление пользователя
            notificationService.createNotification(
                    account.getUser().getUsername(),
                    String.format("Fee paid: %s of %.2f successfully debited from account %s.",
                            fee.getFeeType().name(), amount, account.getAccountNumber()),
                    NotificationType.INFO
            );
            log.info("Fee {} successfully paid by account {}", fee.getId(), account.getId());
        } else {
            // Уведомление о недостатке средств
            notificationService.createNotification(
                    account.getUser().getUsername(),
                    String.format("Fee payment failed: Insufficient funds (%.2f) to cover %s fee of %.2f.",
                            account.getBalance(), fee.getFeeType().name(), amount),
                    NotificationType.ALERT
            );
            log.warn("Fee payment failed for account {}: Insufficient funds.", account.getId());
            throw new RuntimeException("Insufficient funds to pay the fee.");
        }
    }

    /**
     * Helper method to record the fee transaction.
     */
    private void recordFeeTransaction(Account account, BigDecimal amount, FeeType feeType) {
        Transaction transaction = new Transaction();
        transaction.setAccount(account);
        transaction.setCard(null); // Комиссия обычно не привязана к конкретной карте
        transaction.setAmount(amount);
        transaction.setType(TransactionType.FEE);
        transaction.setTransactionDate(LocalDateTime.now());
        transaction.setDescription("Service Fee: " + feeType.name());
        transaction.setStatus(TransferStatus.SUCCESS);
        transactionRepository.save(transaction);
    }

    /**
     * Retrieves all unpaid fees for a specific account (for internal use or user's dashboard).
     */
    public List<ServiceFeeResponseDto> getUnpaidFeesForAccount(Long accountId, String username) {
        Account account = accountRepository.findById(accountId)
                .orElseThrow(() -> new AccountNotFoundException("Account not found"));

        if (!account.getUser().getUsername().equals(username)) {
            throw new ForbiddenException("Access denied to this account.");
        }

        return serviceFeeRepository.findByAccount_IdAndIsPaidFalse(accountId).stream()
                .map(serviceFeeMapper::toServiceFeeResponseDto)
                .collect(Collectors.toList());
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\service\notification\NotificationService.java
================================================================================

package com.example.bankcards.service.notification;

import com.example.bankcards.exception.dto.ResourceNotFoundException;
import com.example.bankcards.model.dto.notification.NotificationResponseDto;
import com.example.bankcards.model.entity.Notification;
import com.example.bankcards.model.entity.User;
import com.example.bankcards.model.entity.enums.NotificationType;
import com.example.bankcards.repository.NotificationRepository;
import com.example.bankcards.repository.UserRepository;
import com.example.bankcards.util.mapper.NotificationMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

/**
 * Service for managing user notifications.
 */
@Service
@RequiredArgsConstructor
@Slf4j
@Transactional(readOnly = true)
public class NotificationService {

    private final NotificationRepository notificationRepository;
    private final NotificationMapper notificationMapper;
    private final UserRepository userRepository; // Needed for creating notifications internally

    /**
     * Retrieves all notifications for the authenticated user, sorted by creation date.
     *
     * @param username The username of the recipient.
     * @return List of notification DTOs.
     */
    public List<NotificationResponseDto> getMyNotifications(String username) {
        return notificationRepository.findByUserUsernameOrderByCreatedAtDesc(username).stream()
                .map(notificationMapper::toNotificationResponseDto)
                .collect(Collectors.toList());
    }

    /**
     * Retrieves only unread notifications for the authenticated user.
     *
     * @param username The username of the recipient.
     * @return List of unread notification DTOs.
     */
    public List<NotificationResponseDto> getUnreadNotifications(String username) {
        return notificationRepository.findByUserUsernameAndIsReadFalseOrderByCreatedAtDesc(username).stream()
                .map(notificationMapper::toNotificationResponseDto)
                .collect(Collectors.toList());
    }

    /**
     * Marks a specific notification as read.
     *
     * @param notificationId The ID of the notification to mark.
     * @param username The username to verify ownership.
     */
    @Transactional
    public void markAsRead(Long notificationId, String username) {
        Notification notification = notificationRepository.findById(notificationId)
                .orElseThrow(() -> new ResourceNotFoundException("Notification not found"));

        if (!notification.getUser().getUsername().equals(username)) {
            // Хотя это не ForbiddenException, мы используем ResourceNotFound, чтобы не раскрывать существование чужих уведомлений.
            throw new ResourceNotFoundException("Notification not found or access denied.");
        }

        if (!notification.getIsRead()) {
            notification.setIsRead(true);
            notificationRepository.save(notification);
            log.info("Notification {} marked as read for user {}", notificationId, username);
        }
    }

    /**
     * Internal method to create and save a new notification.
     * This method would be called by other services (e.g., TransferService, CardService)
     * when an event occurs (e.g., successful transfer, card status change).
     */
    @Transactional
    public void createNotification(String username, String message, NotificationType type) {
        User user = userRepository.findByUsername(username)
                .orElse(null); // Если пользователь не найден, просто не отправляем уведомление

        if (user != null) {
            Notification notification = new Notification();
            notification.setUser(user);
            notification.setMessage(message);
            notification.setType(type);
            notification.setIsRead(false);
            notificationRepository.save(notification);
            log.debug("Created notification for user {}: {}", username, message);
        }
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\service\support\SupportTicketService.java
================================================================================

package com.example.bankcards.service.support;

import com.example.bankcards.exception.dto.ForbiddenException;
import com.example.bankcards.exception.dto.ResourceNotFoundException;
import com.example.bankcards.exception.user.UserNotFoundException;
import com.example.bankcards.model.dto.ticket.TicketCreateRequest;
import com.example.bankcards.model.dto.ticket.TicketResponseDto;
import com.example.bankcards.model.entity.SupportTicket;
import com.example.bankcards.model.entity.User;
import com.example.bankcards.model.entity.enums.NotificationType;
import com.example.bankcards.model.entity.enums.Role;
import com.example.bankcards.model.entity.enums.TicketPriority;
import com.example.bankcards.model.entity.enums.TicketStatus;
import com.example.bankcards.repository.SupportTicketRepository;
import com.example.bankcards.repository.UserRepository;
import com.example.bankcards.service.notification.NotificationService;
import com.example.bankcards.util.mapper.TicketMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

/**
 * Service for managing user support tickets.
 */
@Service
@RequiredArgsConstructor
@Slf4j
@Transactional(readOnly = true)
public class SupportTicketService {

    private final SupportTicketRepository ticketRepository;
    private final UserRepository userRepository;
    private final TicketMapper ticketMapper;
    private final NotificationService notificationService;

    /**
     * Creates a new support ticket for the authenticated user.
     *
     * @param request The ticket details.
     * @param username The username of the creator.
     * @return DTO of the created ticket.
     */
    @Transactional
    public TicketResponseDto createTicket(TicketCreateRequest request, String username) {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new UserNotFoundException("User not found: " + username));

        SupportTicket ticket = new SupportTicket();
        ticket.setUser(user);
        ticket.setSubject(request.getSubject());
        ticket.setDescription(request.getDescription());
        ticket.setStatus(TicketStatus.OPEN);
        ticket.setPriority(TicketPriority.MEDIUM); // По умолчанию

        SupportTicket savedTicket = ticketRepository.save(ticket);
        log.info("New support ticket created by user {}. ID: {}", username, savedTicket.getId());
        return ticketMapper.toTicketResponseDto(savedTicket);
    }

    /**
     * Retrieves all tickets created by the authenticated user.
     */
    public List<TicketResponseDto> getMyTickets(String username) {
        return ticketRepository.findByUserUsernameOrderByCreatedAtDesc(username).stream()
                .map(ticketMapper::toTicketResponseDto)
                .collect(Collectors.toList());
    }

    /**
     * Retrieves a specific ticket, verifying ownership.
     */
    public TicketResponseDto getTicketById(Long ticketId, String username) {
        SupportTicket ticket = ticketRepository.findById(ticketId)
                .orElseThrow(() -> new ResourceNotFoundException("Ticket not found"));

        if (!ticket.getUser().getUsername().equals(username)) {
            throw new ForbiddenException("Access denied: You do not own this ticket.");
        }
        return ticketMapper.toTicketResponseDto(ticket);
    }

    // --- Admin/Internal Logic (Example) ---

    /**
     * Retrieves all open and in-progress tickets (Admin view).
     */
    @Transactional
    public TicketResponseDto assignTicket(Long ticketId, String adminUsername) {
        SupportTicket ticket = ticketRepository.findById(ticketId)
                .orElseThrow(() -> new ResourceNotFoundException("Ticket not found"));

        User admin = userRepository.findByUsername(adminUsername)
                .orElseThrow(() -> new UserNotFoundException("Admin user not found: " + adminUsername));

        // Проверка, что пользователь, которому назначается тикет, действительно администратор
        if (admin.getRole() != Role.ROLE_ADMIN) {
            throw new ForbiddenException("Cannot assign ticket: User " + adminUsername + " is not an administrator.");
        }

        ticket.setAdminAssigned(admin);
        ticket.setStatus(TicketStatus.IN_PROGRESS);

        SupportTicket savedTicket = ticketRepository.save(ticket);
        log.info("Support ticket {} assigned to admin {}", ticketId, adminUsername);

        // Уведомление пользователя о том, что тикет взят в работу
        notificationService.createNotification(
                ticket.getUser().getUsername(),
                String.format("Your ticket #%d has been assigned to a specialist and is now In Progress.", ticketId),
                NotificationType.INFO
        );

        return ticketMapper.toTicketResponseDto(savedTicket);
    }

    /**
     * Retrieves all open and in-progress tickets (Admin view).
     */
    public List<TicketResponseDto> getOpenTickets() {
        List<TicketStatus> openStatuses = List.of(TicketStatus.OPEN, TicketStatus.IN_PROGRESS);
        return ticketRepository.findByStatusIn(openStatuses).stream()
                .map(ticketMapper::toTicketResponseDto)
                .collect(Collectors.toList());
    }

    /**
     * Closes a ticket (Admin action).
     */
    @Transactional
    public TicketResponseDto closeTicket(Long ticketId) {
        SupportTicket ticket = ticketRepository.findById(ticketId)
                .orElseThrow(() -> new ResourceNotFoundException("Ticket not found"));

        if (ticket.getStatus() != TicketStatus.CLOSED) {
            ticket.setStatus(TicketStatus.CLOSED);
            ticket.setPriority(TicketPriority.LOW);
            SupportTicket savedTicket = ticketRepository.save(ticket);
            log.info("Support ticket {} closed by admin.", ticketId);

            // Уведомление пользователя о закрытии
            notificationService.createNotification(
                    ticket.getUser().getUsername(),
                    String.format("Your ticket #%d has been resolved and closed.", ticketId),
                    NotificationType.SUCCESS
            );

            return ticketMapper.toTicketResponseDto(savedTicket);
        }
        return ticketMapper.toTicketResponseDto(ticket);
    }


}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\service\transfer\TransferService.java
================================================================================

package com.example.bankcards.service.transfer;

import com.example.bankcards.exception.card.CardNotFoundException;
import com.example.bankcards.exception.card.CardOwnershipException;
import com.example.bankcards.exception.card.CardStatusException;
import com.example.bankcards.exception.card.InsufficientFundsException;
import com.example.bankcards.exception.dto.BadRequestException;
import com.example.bankcards.exception.dto.ForbiddenException;
import com.example.bankcards.exception.dto.ResourceNotFoundException;
import com.example.bankcards.exception.transfer.InvalidTransferException;
import com.example.bankcards.model.dto.transfer.TransferRequest;
import com.example.bankcards.model.dto.transfer.TransferResponseDto;
import com.example.bankcards.model.entity.Account;
import com.example.bankcards.model.entity.Card;
import com.example.bankcards.model.entity.Transfer;
import com.example.bankcards.model.entity.Transaction;
import com.example.bankcards.model.entity.enums.CardStatus;
import com.example.bankcards.model.entity.enums.NotificationType;
import com.example.bankcards.model.entity.enums.TransferStatus;
import com.example.bankcards.model.entity.enums.TransactionType;
import com.example.bankcards.repository.CardRepository;
import com.example.bankcards.repository.TransferRepository;
import com.example.bankcards.repository.TransactionRepository;
import com.example.bankcards.service.card.CardEncryptionService;
import com.example.bankcards.service.notification.NotificationService;
import com.example.bankcards.util.mapper.TransferMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
@Transactional(readOnly = true)
public class TransferService {

    private final CardEncryptionService cardEncryptionService;
    private final TransferRepository transferRepository;
    private final CardRepository cardRepository;
    private final TransferMapper transferMapper;
    private final TransactionRepository transactionRepository;
    private final NotificationService notificationService;

    @Transactional
    public TransferResponseDto createTransfer(TransferRequest request, String username) {
        Card fromCard = getAndValidateFromCard(request.getFromCardId(), username);

        Card toCard;
        // Логика выбора получателя: ID или Номер
        if (request.getToCardId() != null) {
            toCard = cardRepository.findById(request.getToCardId())
                    .orElseThrow(() -> new CardNotFoundException("Destination card not found with ID: " + request.getToCardId()));
            // Проверяем статус, даже если по ID нашли
            if (toCard.getCardStatus() != CardStatus.ACTIVE) {
                throw new CardStatusException("Destination card is not active.");
            }
        } else if (request.getToCardNumber() != null && !request.getToCardNumber().trim().isEmpty()) {
            toCard = getAndValidateToCard(request.getToCardNumber(), fromCard);
        } else {
            throw new BadRequestException("Destination card info (ID or Number) is missing");
        }

        if (fromCard.getId().equals(toCard.getId())) {
            throw new InvalidTransferException("Cannot transfer to the same card");
        }

        validateTransferConditions(fromCard, request.getAmount());

        Account fromAccount = fromCard.getAccount();
        Account toAccount = toCard.getAccount();

        Transfer transfer = new Transfer();
        transfer.setFromCard(fromCard);
        transfer.setToCard(toCard);
        transfer.setAmount(request.getAmount());
        transfer.setTransferDate(LocalDateTime.now());

        try {
            // 1. Балансы
            fromCard.setBalance(fromCard.getBalance().subtract(request.getAmount()));
            toCard.setBalance(toCard.getBalance().add(request.getAmount()));

            // 2. Счета
            fromAccount.setBalance(fromAccount.getBalance().subtract(request.getAmount()));
            toAccount.setBalance(toAccount.getBalance().add(request.getAmount()));

            cardRepository.save(fromCard);
            cardRepository.save(toCard);

            // 3. Транзакции
            recordTransaction(fromAccount, fromCard, request.getAmount().negate(), TransactionType.TRANSFER_OUT,
                    "Transfer to card ID " + toCard.getId());
            recordTransaction(toAccount, toCard, request.getAmount(), TransactionType.TRANSFER_IN,
                    "Transfer from card ID " + fromCard.getId());

            // 4. Сохранение перевода
            transfer.setStatus(TransferStatus.SUCCESS);
            Transfer savedTransfer = transferRepository.save(transfer);

            // 5. Уведомления (Колокольчик)
            notificationService.createNotification(
                    fromAccount.getUser().getUsername(),
                    "Списание: -" + request.getAmount() + " (Перевод)",
                    NotificationType.INFO
            );
            notificationService.createNotification(
                    toAccount.getUser().getUsername(),
                    "Пополнение: +" + request.getAmount() + " (Входящий перевод)",
                    NotificationType.SUCCESS
            );

            log.info("Transfer completed: {} -> {} amount: {}", fromCard.getId(), toCard.getId(), request.getAmount());

            return mapTransferToDto(savedTransfer);

        } catch (Exception e) {
            log.error("Transfer failed", e);
            transfer.setStatus(TransferStatus.FAILED);
            transferRepository.save(transfer);
            throw new RuntimeException("Transfer processing failed", e);
        }
    }

    private void recordTransaction(Account account, Card card, BigDecimal amount, TransactionType type, String description) {
        Transaction transaction = new Transaction();
        transaction.setAccount(account);
        transaction.setCard(card);
        transaction.setAmount(amount.abs());
        transaction.setType(type);
        transaction.setTransactionDate(LocalDateTime.now());
        transaction.setDescription(description);
        transaction.setStatus(TransferStatus.SUCCESS);
        transactionRepository.save(transaction);
    }

    private Card getAndValidateFromCard(Long fromCardId, String username) {
        Card fromCard = cardRepository.findById(fromCardId)
                .orElseThrow(() -> new CardNotFoundException("Source card not found with ID: " + fromCardId));

        if (!fromCard.getAccount().getUser().getUsername().equals(username)) {
            throw new CardOwnershipException("Access denied: Source card doesn't belong to user");
        }
        if (fromCard.getCardStatus() != CardStatus.ACTIVE) {
            throw new CardStatusException("Source card is not active.");
        }
        return fromCard;
    }

    private Card getAndValidateToCard(String toCardNumber, Card fromCard) {
        Card toCard = cardRepository.findAll().stream()
                .filter(card -> cardEncryptionService.matchesCardNumber(toCardNumber, card.getCardNumber()))
                .findFirst()
                .orElseThrow(() -> new CardNotFoundException("Destination card not found"));

        if (toCard.getCardStatus() != CardStatus.ACTIVE) {
            throw new CardStatusException("Destination card is not active.");
        }
        return toCard;
    }

    private void validateTransferConditions(Card fromCard, BigDecimal amount) {
        if (fromCard.getBalance().compareTo(amount) < 0) {
            throw new InsufficientFundsException("Insufficient funds.");
        }
    }

    private TransferResponseDto mapTransferToDto(Transfer transfer) {
        TransferResponseDto dto = transferMapper.toTransferResponseDto(transfer);
        if (transfer.getFromCard() != null) {
            dto.setFromCardNumber(cardEncryptionService.getMaskedCardNumber(transfer.getFromCard().getCardNumber()));
        }
        if (transfer.getToCard() != null) {
            dto.setToCardNumber(cardEncryptionService.getMaskedCardNumber(transfer.getToCard().getCardNumber()));
        }
        return dto;
    }

    public List<TransferResponseDto> getUserTransfers(String username) {
        List<Transfer> transfers = transferRepository.findByUserUsername(username);
        return transfers.stream().map(this::mapTransferToDto).collect(Collectors.toList());
    }

    public List<TransferResponseDto> getCardTransfers(Long cardId, String username) {
        Card card = cardRepository.findById(cardId).orElseThrow(() -> new CardNotFoundException("Card not found"));
        if (!card.getAccount().getUser().getUsername().equals(username)) {
            throw new ForbiddenException("Access denied");
        }
        return transferRepository.findByCardId(cardId).stream().map(this::mapTransferToDto).collect(Collectors.toList());
    }

    public TransferResponseDto getTransfer(Long transferId, String username) {
        Transfer transfer = transferRepository.findById(transferId).orElseThrow(() -> new ResourceNotFoundException("Transfer not found"));
        boolean isParticipant = transfer.getFromCard().getAccount().getUser().getUsername().equals(username) ||
                transfer.getToCard().getAccount().getUser().getUsername().equals(username);
        if (!isParticipant) throw new ForbiddenException("Access denied");
        return mapTransferToDto(transfer);
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\util\CardMaskingUtil.java
================================================================================

package com.example.bankcards.util;

public class CardMaskingUtil {

    public static String maskCardNumber(String cardNumber) {
        if (cardNumber == null || cardNumber.length() < 8) {
            return "**** **** **** ****";
        }

        // Убираем все нецифровые символы
        String cleaned = cardNumber.replaceAll("\\D", "");

        if (cleaned.length() < 8) {
            return "**** **** **** " + cleaned;
        }

        // Берем первые 4 и последние 4
        String first4 = cleaned.substring(0, 4);
        String last4 = cleaned.substring(cleaned.length() - 4);

        // Возвращаем красивый формат
        return first4 + " **** **** " + last4;
    }

    public static boolean isValidCardNumber(String cardNumber) {
        if (cardNumber == null) return false;
        String cleaned = cardNumber.replaceAll("\\D", "");
        if (cleaned.length() < 13 || cleaned.length() > 19) return false;
        return luhnCheck(cleaned);
    }

    private static boolean luhnCheck(String cardNumber) {
        int sum = 0;
        boolean alternate = false;
        for (int i = cardNumber.length() - 1; i >= 0; i--) {
            int n = Integer.parseInt(cardNumber.substring(i, i + 1));
            if (alternate) {
                n *= 2;
                if (n > 9) n = (n % 10) + 1;
            }
            sum += n;
            alternate = !alternate;
        }
        return (sum % 10 == 0);
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\util\EncryptionUtil.java
================================================================================

package com.example.bankcards.util;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import javax.crypto.Cipher;
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.security.SecureRandom;
import java.util.Base64;

/**
 * Utility class for performing AES/GCM encryption and decryption.
 * Uses a secret key configured via Spring properties.
 * Provides methods to encrypt, decrypt, and compare plain text with encrypted text.
 */
@Component
@Slf4j
public class EncryptionUtil {

    private static final String ALGORITHM = "AES";
    private static final String TRANSFORMATION = "AES/GCM/NoPadding";
    private static final int GCM_IV_LENGTH = 12;
    private static final int GCM_TAG_LENGTH = 16;

    @Value("${encryption.key}")
    private String encryptionKey;

    /**
     * Encrypts the given plain text using AES/GCM.
     * A random IV is generated for each encryption operation and prepended to the ciphertext.
     * The result is Base64 encoded.
     *
     * @param plainText the string to be encrypted.
     * @return the Base64 encoded encrypted string, including the IV.
     * @throws RuntimeException if an error occurs during encryption.
     */
    public String encrypt(String plainText) {
        try {
            SecretKeySpec keySpec = new SecretKeySpec(
                    encryptionKey.getBytes(StandardCharsets.UTF_8), ALGORITHM);

            // Генерируем случайный IV
            byte[] iv = new byte[GCM_IV_LENGTH];
            new SecureRandom().nextBytes(iv);

            Cipher cipher = Cipher.getInstance(TRANSFORMATION);
            GCMParameterSpec gcmParameterSpec = new GCMParameterSpec(GCM_TAG_LENGTH * 8, iv);
            cipher.init(Cipher.ENCRYPT_MODE, keySpec, gcmParameterSpec);

            byte[] encryptedText = cipher.doFinal(plainText.getBytes(StandardCharsets.UTF_8));

            byte[] encryptedWithIv = new byte[iv.length + encryptedText.length];
            System.arraycopy(iv, 0, encryptedWithIv, 0, iv.length);
            System.arraycopy(encryptedText, 0, encryptedWithIv, iv.length, encryptedText.length);

            return Base64.getEncoder().encodeToString(encryptedWithIv);

        } catch (Exception e) {
            log.error("Error during encryption: {}", e.getMessage());
            throw new RuntimeException("Failed to encrypt data", e);
        }
    }

    /**
     * Decrypts the given Base64 encoded encrypted text using AES/GCM.
     * The IV is extracted from the beginning of the decoded data.
     *
     * @param encryptedText the Base64 encoded encrypted string to be decrypted.
     * @return the decrypted plain text string.
     * @throws RuntimeException if an error occurs during decryption.
     */
    public String decrypt(String encryptedText) {
        try {
            byte[] decodedData = Base64.getDecoder().decode(encryptedText);

            byte[] iv = new byte[GCM_IV_LENGTH];
            System.arraycopy(decodedData, 0, iv, 0, iv.length);

            byte[] encrypted = new byte[decodedData.length - GCM_IV_LENGTH];
            System.arraycopy(decodedData, GCM_IV_LENGTH, encrypted, 0, encrypted.length);

            SecretKeySpec keySpec = new SecretKeySpec(
                    encryptionKey.getBytes(StandardCharsets.UTF_8), ALGORITHM);

            Cipher cipher = Cipher.getInstance(TRANSFORMATION);
            GCMParameterSpec gcmParameterSpec = new GCMParameterSpec(GCM_TAG_LENGTH * 8, iv);
            cipher.init(Cipher.DECRYPT_MODE, keySpec, gcmParameterSpec);

            byte[] decryptedText = cipher.doFinal(encrypted);
            return new String(decryptedText, StandardCharsets.UTF_8);

        } catch (Exception e) {
            log.error("Error during decryption: {}", e.getMessage());
            throw new RuntimeException("Failed to decrypt data", e);
        }
    }

    /**
     * Compares a plain text string with an encrypted text string by decrypting the latter
     * and performing a string equality check.
     *
     * @param plainText the unencrypted string to compare.
     * @param encryptedText the Base64 encoded encrypted string to compare against.
     * @return {@code true} if the decrypted text matches the plain text, {@code false} otherwise.
     *         Returns {@code false} if decryption fails.
     */
    public boolean matches(String plainText, String encryptedText) {
        try {
            String decrypted = decrypt(encryptedText);
            return plainText.equals(decrypted);
        } catch (Exception e) {
            log.warn("Error during comparison: {}", e.getMessage());
            return false;
        }
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\util\mapper\AccountMapper.java
================================================================================

package com.example.bankcards.util.mapper;

import com.example.bankcards.model.dto.account.AccountResponseDto;
import com.example.bankcards.model.entity.Account;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

@Mapper(componentModel = "spring")
public interface AccountMapper {

    @Mapping(source = "user.id", target = "userId")
    AccountResponseDto toAccountResponseDto(Account account);

    // Если потребуется маппинг для создания или обновления, можно добавить сюда.
    // Пока достаточно маппинга для ответа.
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\util\mapper\CardMapper.java
================================================================================

package com.example.bankcards.util.mapper;

import com.example.bankcards.model.dto.card.CardResponseDto;
import com.example.bankcards.model.entity.Card;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

/**
 * Mapper interface for converting between {@link com.example.bankcards.model.entity.Card} entities
 * and their corresponding DTOs ({@link com.example.bankcards.model.dto.card.CardResponseDto}).
 * This interface uses MapStruct for automatic mapping generation.
 */
@Mapper(componentModel = "spring")
public interface CardMapper {

    @Mapping(target = "cardNumber", ignore = true)
    @Mapping(target = "username", source = "account.user.username") // Corrected mapping path
    CardResponseDto toCardResponseDto(Card card);
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\util\mapper\NotificationMapper.java
================================================================================

package com.example.bankcards.util.mapper;

import com.example.bankcards.model.dto.notification.NotificationResponseDto;
import com.example.bankcards.model.entity.Notification;
import org.mapstruct.Mapper;

@Mapper(componentModel = "spring")
public interface NotificationMapper {
    NotificationResponseDto toNotificationResponseDto(Notification notification);
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\util\mapper\ServiceFeeMapper.java
================================================================================

package com.example.bankcards.util.mapper;

import com.example.bankcards.model.dto.fee.ServiceFeeResponseDto;
import com.example.bankcards.model.entity.ServiceFee;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

@Mapper(componentModel = "spring")
public interface ServiceFeeMapper {

    @Mapping(source = "account.id", target = "accountId")
    ServiceFeeResponseDto toServiceFeeResponseDto(ServiceFee serviceFee);
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\util\mapper\TicketMapper.java
================================================================================

package com.example.bankcards.util.mapper;

import com.example.bankcards.model.dto.ticket.TicketResponseDto;
import com.example.bankcards.model.entity.SupportTicket;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

@Mapper(componentModel = "spring")
public interface TicketMapper {

    @Mapping(source = "user.username", target = "createdByUsername")
    @Mapping(source = "adminAssigned.username", target = "assignedToAdminUsername")
    TicketResponseDto toTicketResponseDto(SupportTicket ticket);
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\util\mapper\TransferMapper.java
================================================================================

package com.example.bankcards.util.mapper;

import com.example.bankcards.model.dto.transfer.TransferResponseDto;
import com.example.bankcards.model.entity.Transfer;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

/**
 * Mapper interface for converting between {@link com.example.bankcards.model.entity.Transfer} entities
 * and their corresponding DTOs ({@link com.example.bankcards.model.dto.transfer.TransferResponseDto}).
 * This interface uses MapStruct for automatic mapping generation.
 */
@Mapper(componentModel = "spring")
public interface TransferMapper {

    @Mapping(target = "fromCardNumber", ignore = true)
    @Mapping(target = "toCardNumber", ignore = true)
    TransferResponseDto toTransferResponseDto(Transfer transfer);
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\java\com\example\bankcards\util\mapper\UserMapper.java
================================================================================

package com.example.bankcards.util.mapper;

import com.example.bankcards.model.dto.user.UserResponseDto;
import com.example.bankcards.model.entity.User;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.Named;

@Mapper(componentModel = "spring")
public interface UserMapper {

    @Mapping(target = "avatarUrl", source = "username", qualifiedByName = "generateAvatarUrl")
    UserResponseDto toUserResponseDto(User user);

    @Named("generateAvatarUrl")
    default String generateAvatarUrl(String username) {
        // Генерируем уникального робота для каждого юзера
        return "https://robohash.org/" + username + "?set=set1&bgset=bg2&size=150x150";
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\resources\application.yml
================================================================================

spring:
  thymeleaf:
    prefix: classpath:/templates/
    suffix: .html
    mode: HTML
    encoding: UTF-8
    cache: false # Для отладки
  config:

    import: optional:file:.env[.properties]
  datasource:
    url: jdbc:postgresql://localhost:5000/bank_db
    username: bank_user
    password: bank_pass

  liquibase:
    change-log: classpath:db/migration/changelog-master.xml

  jpa:
    hibernate:
      ddl-auto: validate

jwt:
  secret: ${JWT_SECRET}
  access-token:
    expiration: 900000
  refresh-token:
    expiration: 2592000000

app:
  admin:
    username: ${ADMIN_USERNAME}
    password: ${ADMIN_PASSWORD}

encryption:
  key: ${ENCRYPTION_KEY}
springdoc:
  swagger-ui:
    url: /v3/api-docs
    config-url: /v3/api-docs/swagger-config
    disable-swagger-default-url: true
    path: /swagger-ui.html
  api-docs:
    path: /v3/api-docs

logging:
  level:
    root: INFO
    org:
      springframework:
        web: TRACE
      thymeleaf: TRACE
server:
  port: 8081


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\resources\db\migration\changelog-master.xml
================================================================================

<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog
        xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
                                   http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-latest.xsd">

    <preConditions onFail="HALT" onFailMessage="Database preconditions failed!">
        <dbms type="postgresql"/>
        <!-- <runningAs username="ilumrhisoka"/> --> <!-- Убрано, так как имя пользователя может быть другим -->
    </preConditions>

    <include file="db/migration/changes/001-create-users-table.xml"/>
    <include file="db/migration/changes/002-create-accounts-table.xml"/>
    <include file="db/migration/changes/003-create-cards-table.xml"/>
    <include file="db/migration/changes/004-create-transactions-table.xml"/>
    <include file="db/migration/changes/005-create-service-fees-table.xml"/>
    <include file="db/migration/changes/006-create-support-tickets-table.xml"/>
    <include file="db/migration/changes/007-create-notifications-table.xml"/>
    <include file="db/migration/changes/008-create-transfers-table.xml"/>
    <include file="db/migration/changes/009-create-refresh-token-table.xml"/>
    <include file="db/migration/changes/010-add-monthly-limit-to-users.xml"/>
    <include file="db/migration/changes/011-create-quick-transfers-table.xml"/>

</databaseChangeLog>


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\resources\db\migration\changes\001-create-users-table.xml
================================================================================

<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog
        xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
                                   http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-latest.xsd">
    <changeSet id="create-users-table" author="ilumrhisoka">
        <createTable tableName="t_users">
            <column name="id" type="BIGINT" autoIncrement="true">
                <constraints primaryKey="true" nullable="false"/>
            </column>
            <column name="username" type="VARCHAR(50)">
                <constraints nullable="false" unique="true"/>
            </column>
            <column name="email" type="VARCHAR(100)">
                <constraints nullable="false" unique="true"/>
            </column>
            <column name="password" type="VARCHAR(255)">
                <constraints nullable="false"/>
            </column>
            <column name="role" type="VARCHAR(20)">
                <constraints nullable="false"/>
            </column>
            <column name="created_at" type="TIMESTAMP">
                <constraints nullable="false"/>
            </column>
            <column name="updated_at" type="TIMESTAMP"/>
        </createTable>
        <createIndex tableName="t_users" indexName="idx_user_username">
            <column name="username"/>
        </createIndex>
    </changeSet>
</databaseChangeLog>


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\resources\db\migration\changes\002-create-accounts-table.xml
================================================================================

<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog
        xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
                                   http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-latest.xsd">
    <changeSet id="create-accounts-table" author="ilumrhisoka">
        <createTable tableName="t_accounts">
            <column name="id" type="BIGINT" autoIncrement="true">
                <constraints primaryKey="true" nullable="false"/>
            </column>
            <column name="account_number" type="VARCHAR(20)">
                <constraints nullable="false" unique="true"/>
            </column>
            <column name="balance" type="DECIMAL(19, 2)">
                <constraints nullable="false"/>
            </column>
            <column name="account_type" type="VARCHAR(20)">
                <constraints nullable="false"/>
            </column>
            <column name="user_id" type="BIGINT">
                <constraints nullable="false"/>
            </column>
            <column name="created_at" type="TIMESTAMP">
                <constraints nullable="false"/>
            </column>
            <column name="updated_at" type="TIMESTAMP">
                <constraints nullable="false"/>
            </column>
        </createTable>
        <addForeignKeyConstraint baseTableName="t_accounts"
                                 baseColumnNames="user_id"
                                 referencedTableName="t_users"
                                 referencedColumnNames="id"
                                 constraintName="fk_account_user"/>
        <createIndex tableName="t_accounts" indexName="idx_account_user_id">
            <column name="user_id"/>
        </createIndex>
    </changeSet>
</databaseChangeLog>


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\resources\db\migration\changes\003-create-cards-table.xml
================================================================================

<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog
        xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
                                   http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-latest.xsd">

    <changeSet id="create-cards-table" author="ilumrhisoka">
        <createTable tableName="t_cards">
            <column name="id" type="BIGINT" autoIncrement="true">
                <constraints primaryKey="true" nullable="false"/>
            </column>
            <column name="card_number" type="VARCHAR(100)">
                <constraints nullable="false"/>
            </column>
            <column name="card_holder" type="VARCHAR(100)">
                <constraints nullable="false"/>
            </column>
            <column name="expiry_date" type="DATE">
                <constraints nullable="false"/>
            </column>
            <column name="card_status" type="VARCHAR(20)">
                <constraints nullable="false"/>
            </column>
            <column name="balance" type="DECIMAL(15, 2)">
                <constraints nullable="false"/>
            </column>
            <!-- СВЯЗЬ ИЗМЕНЕНА: Теперь ссылается на t_accounts -->
            <column name="account_id" type="BIGINT">
                <constraints nullable="false"/>
            </column>
            <column name="created_at" type="TIMESTAMP">
                <constraints nullable="false"/>
            </column>
            <column name="updated_at" type="TIMESTAMP">
                <constraints nullable="false"/>
            </column>
        </createTable>
        <addForeignKeyConstraint baseTableName="t_cards"
                                 baseColumnNames="account_id"
                                 referencedTableName="t_accounts"
                                 referencedColumnNames="id"
                                 constraintName="fk_card_account"/>
        <createIndex tableName="t_cards" indexName="idx_card_account_id">
            <column name="account_id"/>
        </createIndex>
    </changeSet>

</databaseChangeLog>


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\resources\db\migration\changes\004-create-transactions-table.xml
================================================================================

<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog
        xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
                                   http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-latest.xsd">
    <changeSet id="create-transactions-table" author="ilumrhisoka">
        <createTable tableName="t_transactions">
            <column name="id" type="BIGINT" autoIncrement="true">
                <constraints primaryKey="true" nullable="false"/>
            </column>
            <column name="account_id" type="BIGINT">
                <constraints nullable="false"/>
            </column>
            <column name="card_id" type="BIGINT">
                <constraints nullable="true"/> <!-- Может быть NULL, если транзакция не связана с картой -->
            </column>
            <column name="amount" type="DECIMAL(19, 2)">
                <constraints nullable="false"/>
            </column>
            <column name="type" type="VARCHAR(30)">
                <constraints nullable="false"/>
            </column>
            <column name="transaction_date" type="TIMESTAMP">
                <constraints nullable="false"/>
            </column>
            <column name="description" type="VARCHAR(255)">
                <constraints nullable="true"/>
            </column>
            <column name="status" type="VARCHAR(20)">
                <constraints nullable="false"/>
            </column>
            <column name="created_at" type="TIMESTAMP">
                <constraints nullable="false"/>
            </column>
            <column name="updated_at" type="TIMESTAMP">
                <constraints nullable="false"/>
            </column>
        </createTable>
        <addForeignKeyConstraint baseTableName="t_transactions"
                                 baseColumnNames="account_id"
                                 referencedTableName="t_accounts"
                                 referencedColumnNames="id"
                                 constraintName="fk_transaction_account"/>
        <addForeignKeyConstraint baseTableName="t_transactions"
                                 baseColumnNames="card_id"
                                 referencedTableName="t_cards"
                                 referencedColumnNames="id"
                                 constraintName="fk_transaction_card"/>
    </changeSet>
</databaseChangeLog>


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\resources\db\migration\changes\005-create-service-fees-table.xml
================================================================================

<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog
        xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
                                   http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-latest.xsd">
    <changeSet id="create-service-fees-table" author="ilumrhisoka">
        <createTable tableName="t_service_fees">
            <column name="id" type="BIGINT" autoIncrement="true">
                <constraints primaryKey="true" nullable="false"/>
            </column>
            <column name="account_id" type="BIGINT">
                <constraints nullable="false"/>
            </column>
            <column name="fee_type" type="VARCHAR(50)">
                <constraints nullable="false"/>
            </column>
            <column name="amount" type="DECIMAL(19, 2)">
                <constraints nullable="false"/>
            </column>
            <column name="date_charged" type="TIMESTAMP">
                <constraints nullable="false"/>
            </column>
            <column name="is_paid" type="BOOLEAN">
                <constraints nullable="false"/>
            </column>
            <column name="created_at" type="TIMESTAMP">
                <constraints nullable="false"/>
            </column>
            <column name="updated_at" type="TIMESTAMP">
                <constraints nullable="false"/>
            </column>
        </createTable>
        <addForeignKeyConstraint baseTableName="t_service_fees"
                                 baseColumnNames="account_id"
                                 referencedTableName="t_accounts"
                                 referencedColumnNames="id"
                                 constraintName="fk_fee_account"/>
    </changeSet>
</databaseChangeLog>


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\resources\db\migration\changes\006-create-support-tickets-table.xml
================================================================================

<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog
        xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
                                   http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-latest.xsd">
    <changeSet id="create-support-tickets-table" author="ilumrhisoka">
        <createTable tableName="t_support_tickets">
            <column name="id" type="BIGINT" autoIncrement="true">
                <constraints primaryKey="true" nullable="false"/>
            </column>
            <column name="user_id" type="BIGINT">
                <constraints nullable="false"/>
            </column>
            <column name="subject" type="VARCHAR(150)">
                <constraints nullable="false"/>
            </column>
            <column name="description" type="TEXT">
                <constraints nullable="false"/>
            </column>
            <column name="status" type="VARCHAR(20)">
                <constraints nullable="false"/>
            </column>
            <column name="priority" type="VARCHAR(20)">
                <constraints nullable="false"/>
            </column>
            <column name="admin_id" type="BIGINT">
                <constraints nullable="true"/> <!-- Опциональный FK для назначенного админа -->
            </column>
            <column name="created_at" type="TIMESTAMP">
                <constraints nullable="false"/>
            </column>
            <column name="updated_at" type="TIMESTAMP">
                <constraints nullable="false"/>
            </column>
        </createTable>
        <addForeignKeyConstraint baseTableName="t_support_tickets"
                                 baseColumnNames="user_id"
                                 referencedTableName="t_users"
                                 referencedColumnNames="id"
                                 constraintName="fk_ticket_user"/>
        <addForeignKeyConstraint baseTableName="t_support_tickets"
                                 baseColumnNames="admin_id"
                                 referencedTableName="t_users"
                                 referencedColumnNames="id"
                                 constraintName="fk_ticket_admin"/>
    </changeSet>
</databaseChangeLog>


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\resources\db\migration\changes\007-create-notifications-table.xml
================================================================================

<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog
        xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
                                   http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-latest.xsd">
    <changeSet id="create-notifications-table" author="ilumrhisoka">
        <createTable tableName="t_notifications">
            <column name="id" type="BIGINT" autoIncrement="true">
                <constraints primaryKey="true" nullable="false"/>
            </column>
            <column name="user_id" type="BIGINT">
                <constraints nullable="false"/>
            </column>
            <column name="message" type="TEXT">
                <constraints nullable="false"/>
            </column>
            <column name="type" type="VARCHAR(20)">
                <constraints nullable="false"/>
            </column>
            <column name="created_at" type="TIMESTAMP">
                <constraints nullable="false"/>
            </column>
            <column name="is_read" type="BOOLEAN" defaultValueBoolean="false">
                <constraints nullable="false"/>
            </column>
            <column name="updated_at" type="TIMESTAMP">
                <constraints nullable="false"/>
            </column>
        </createTable>
        <addForeignKeyConstraint baseTableName="t_notifications"
                                 baseColumnNames="user_id"
                                 referencedTableName="t_users"
                                 referencedColumnNames="id"
                                 constraintName="fk_notification_user"/>
    </changeSet>
</databaseChangeLog>


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\resources\db\migration\changes\008-create-transfers-table.xml
================================================================================

<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog
        xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
                                   http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-latest.xsd">

    <changeSet id="create-transfers-table" author="ilumrhisoka">
        <createTable tableName="t_transfers">
            <column name="id" type="BIGINT" autoIncrement="true">
                <constraints primaryKey="true" nullable="false"/>
            </column>
            <column name="from_card_id" type="BIGINT">
                <constraints nullable="false"/>
            </column>
            <column name="to_card_id" type="BIGINT">
                <constraints nullable="false"/>
            </column>
            <column name="amount" type="DECIMAL(15, 2)">
                <constraints nullable="false"/>
            </column>
            <column name="transfer_date" type="TIMESTAMP">
                <constraints nullable="false"/>
            </column>
            <column name="status" type="VARCHAR(20)">
                <constraints nullable="false"/>
            </column>
            <column name="created_at" type="TIMESTAMP">
                <constraints nullable="false"/>
            </column>
            <column name="updated_at" type="TIMESTAMP">
                <constraints nullable="false"/>
            </column>
        </createTable>
        <addForeignKeyConstraint baseTableName="t_transfers"
                                 baseColumnNames="from_card_id"
                                 referencedTableName="t_cards"
                                 referencedColumnNames="id"
                                 constraintName="fk_transfer_from_card"/>
        <addForeignKeyConstraint baseTableName="t_transfers"
                                 baseColumnNames="to_card_id"
                                 referencedTableName="t_cards"
                                 referencedColumnNames="id"
                                 constraintName="fk_transfer_to_card"/>
        <createIndex tableName="t_transfers" indexName="idx_transfer_from_card_id">
            <column name="from_card_id"/>
        </createIndex>
        <createIndex tableName="t_transfers" indexName="idx_transfer_to_card_id">
            <column name="to_card_id"/>
        </createIndex>
    </changeSet>

</databaseChangeLog>


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\resources\db\migration\changes\009-create-refresh-token-table.xml
================================================================================

<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog
        xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
                      http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.9.xsd">
    <changeSet id="1-create-refresh_tokens-table" author="ilumrhisoka">
        <comment>Создание таблицы для хранения Refresh Token</comment>
        <createTable tableName="refresh_tokens">
            <column name="id" type="BIGINT" autoIncrement="true">
                <constraints primaryKey="true" nullable="false"/>
            </column>
            <column name="token" type="VARCHAR(255)">
                <constraints nullable="false" unique="true"/>
            </column>
            <column name="expiry_date" type="TIMESTAMP">
                <constraints nullable="false"/>
            </column>
            <column name="user_id" type="BIGINT">
                <constraints nullable="false"/>
            </column>
        </createTable>
        <addForeignKeyConstraint baseTableName="refresh_tokens"
                                 baseColumnNames="user_id"
                                 referencedTableName="t_users"
                                 referencedColumnNames="id"
                                 constraintName="fk_refresh_token_user"
                                 onDelete="CASCADE"/>
    </changeSet>

</databaseChangeLog>


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\resources\db\migration\changes\010-add-monthly-limit-to-users.xml
================================================================================

<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog
        xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
                      http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.9.xsd">
    <changeSet id="1-add-monthly-limit" author="cyberbank">
        <addColumn tableName="t_users">
            <column name="monthly_limit" type="DECIMAL(19, 2)" defaultValueNumeric="5000.00"/>
        </addColumn>
    </changeSet>
</databaseChangeLog>


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\resources\db\migration\changes\011-create-quick-transfers-table.xml
================================================================================

<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog
        xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
                      http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.9.xsd">
    <changeSet id="1-create-quick-transfers" author="cyberbank">
        <createTable tableName="t_quick_transfers">
            <column name="id" type="BIGINT" autoIncrement="true">
                <constraints primaryKey="true" nullable="false"/>
            </column>
            <column name="user_id" type="BIGINT">
                <constraints nullable="false"/>
            </column>
            <column name="name" type="VARCHAR(50)">
                <constraints nullable="false"/>
            </column>
            <column name="card_number" type="VARCHAR(20)">
                <constraints nullable="false"/>
            </column>
            <column name="created_at" type="TIMESTAMP" defaultValueDate="CURRENT_TIMESTAMP"/>
            <column name="updated_at" type="TIMESTAMP"/>
        </createTable>
        <addForeignKeyConstraint baseTableName="t_quick_transfers" baseColumnNames="user_id"
                                 referencedTableName="t_users" referencedColumnNames="id"
                                 constraintName="fk_qt_user"/>
    </changeSet>
</databaseChangeLog>


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\resources\templates\admin_dashboard.html
================================================================================

<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Bank Admin • Cyber Panel</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        :root {
            --bg-dark: #0a0a0a;
            --card-bg: #111;
            --border-color: #222;
            --text-main: #e0e0e0;
            --neon-accent: #ffb700;
        }
        body { background: var(--bg-dark); color: var(--text-main); font-family: 'Inter', sans-serif; }

        .navbar-custom { background: #000; border-bottom: 1px solid var(--border-color); }
        .nav-link { color: #888; transition: 0.3s; cursor: pointer; }
        .nav-link.active { color: var(--neon-accent); font-weight: bold; background: rgba(255,183,0,0.1); border-radius: 6px; }
        .nav-link:hover { color: #fff; }

        /* Карточки и таблицы */
        .card-custom { background: var(--card-bg); border: 1px solid var(--border-color); color: var(--text-main); border-radius: 12px; }
        .table-custom { --bs-table-bg: transparent; --bs-table-color: #ccc; --bs-table-border-color: var(--border-color); }
        .table-custom th { color: #666; font-size: 0.75rem; text-transform: uppercase; letter-spacing: 1px; }
        .table-custom td { vertical-align: middle; }

        /* Модальные окна и формы */
        .modal-dark { background: #1a1a1a; color: white; border: 1px solid #333; }
        .form-control-dark, .form-select { background: #000 !important; border: 1px solid #333 !important; color: white !important; }
        .form-control-dark:focus, .form-select:focus { border-color: var(--neon-accent) !important; box-shadow: 0 0 5px rgba(255,183,0,0.3) !important; }
        .btn-close { filter: invert(1); }

        /* 3D Card */
        .credit-card-wrap { perspective: 1000px; width: 350px; height: 220px; margin: 0 auto; cursor: pointer; }
        .credit-card-inner { position: relative; width: 100%; height: 100%; text-align: center; transition: transform 0.6s; transform-style: preserve-3d; }
        .credit-card-wrap.flipped .credit-card-inner { transform: rotateY(180deg); }
        .credit-card-front, .credit-card-back { position: absolute; width: 100%; height: 100%; backface-visibility: hidden; border-radius: 15px; box-shadow: 0 4px 15px rgba(0,0,0,0.5); color: white; background: #222; border: 1px solid #333; }
        .credit-card-front { padding: 20px; display: flex; flex-direction: column; justify-content: space-between; }
        .credit-card-back { transform: rotateY(180deg); padding-top: 20px; }
        .card-number { font-family: 'Space Mono', monospace; font-size: 1.25rem; letter-spacing: 2px; }
    </style>
</head>
<body>

<nav class="navbar navbar-custom px-4 py-3">
    <div class="d-flex align-items-center gap-4">
        <a class="navbar-brand fw-bold text-white" href="#"><i class="fas fa-shield-alt me-2 text-warning"></i>ADMIN CORE</a>
        <ul class="nav gap-2">
            <li class="nav-item"><a class="nav-link active px-3" onclick="switchTab('cards')" id="tab-cards">CARDS</a></li>
            <li class="nav-item"><a class="nav-link px-3 position-relative" onclick="switchTab('tickets')" id="tab-tickets">
                TICKETS <span id="ticketBadge" class="position-absolute top-0 start-100 translate-middle badge rounded-pill bg-danger d-none">0</span>
            </a></li>
        </ul>
    </div>
    <div class="d-flex gap-2">
        <button class="btn btn-outline-warning btn-sm fw-bold" onclick="openCreateModal()"><i class="fas fa-plus me-1"></i> NEW CARD</button>
        <button onclick="logout()" class="btn btn-outline-secondary btn-sm"><i class="fas fa-sign-out-alt"></i></button>
    </div>
</nav>

<div class="container mt-4">

    <!-- Вкладка КАРТЫ -->
    <div id="section-cards">
        <div id="requestsSection" class="mb-4 d-none">
            <div class="card card-custom border-warning mb-4">
                <div class="card-header bg-warning text-dark fw-bold border-0">ATTENTION REQUIRED</div>
                <div class="card-body p-0">
                    <table class="table table-custom mb-0 align-middle">
                        <thead class="bg-dark"><tr><th class="ps-4">USER</th><th>CARD</th><th>REQUEST</th><th class="text-end pe-4">ACTION</th></tr></thead>
                        <tbody id="requestsTable"></tbody>
                    </table>
                </div>
            </div>
        </div>

        <div class="card card-custom shadow-lg">
            <div class="card-body p-0">
                <table class="table table-custom table-hover mb-0 align-middle">
                    <thead>
                    <tr><th class="ps-4">ID</th><th>USER</th><th>NUMBER</th><th>BALANCE (BYN)</th><th>STATUS</th><th class="text-end pe-4">ACTIONS</th></tr>
                    </thead>
                    <tbody id="cardsTable"><tr><td colspan="6" class="text-center p-5 text-muted">Loading Database...</td></tr></tbody>
                </table>
            </div>
        </div>
        <div class="mt-3 text-end"><button class="btn btn-dark btn-sm text-muted" onclick="loadCards()">Refresh Data</button></div>
    </div>

    <!-- Вкладка ТИКЕТЫ -->
    <div id="section-tickets" class="d-none">
        <h4 class="mb-4 text-white">Support Tickets</h4>
        <div class="row g-4" id="ticketsGrid"><div class="col-12 text-center text-muted">No open tickets</div></div>
    </div>
</div>

<!-- Modals -->
<div class="modal fade" id="createCardModal" tabindex="-1"><div class="modal-dialog"><div class="modal-content modal-dark"><div class="modal-header border-secondary"><h5 class="modal-title">Issue New Card</h5><button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button></div><div class="modal-body"><form id="createCardForm"><div class="mb-3"><label class="text-muted small">User</label><select id="userIdSelect" class="form-select" required></select></div><div class="mb-3"><label class="text-muted small">Card Number</label><div class="input-group"><input type="text" id="newCardNumber" class="form-control form-control-dark font-monospace" maxlength="16"><button class="btn btn-outline-secondary" type="button" onclick="generateRandomCardNumber()"><i class="fas fa-random"></i></button></div></div><div class="mb-3"><label class="text-muted small">Card Holder</label><input type="text" id="newCardHolder" class="form-control form-control-dark text-uppercase"></div><input type="hidden" id="realExpiryDate"><input type="hidden" id="newBalance" value="0"></form></div><div class="modal-footer border-secondary"><button class="btn btn-warning w-100 fw-bold" onclick="submitCreateCard()">CREATE CARD</button></div></div></div></div>

<div class="modal fade" id="balanceModal" tabindex="-1"><div class="modal-dialog modal-sm modal-dialog-centered"><div class="modal-content modal-dark"><div class="modal-header border-0"><h5 class="modal-title fs-6 text-muted" id="balanceModalTitle">Operation</h5><button class="btn-close btn-close-white" data-bs-dismiss="modal"></button></div><div class="modal-body"><input type="hidden" id="balanceCardId"><input type="hidden" id="balanceAction"><div class="input-group mb-3"><span class="input-group-text border-0 bg-dark text-muted">BYN</span><input type="number" id="balanceAmount" class="form-control form-control-dark fw-bold fs-4" placeholder="0.00"></div><button class="btn btn-primary w-100" onclick="submitBalanceChange()">EXECUTE</button></div></div></div></div>

<div class="modal fade" id="successCardModal" tabindex="-1"><div class="modal-dialog modal-dialog-centered"><div class="modal-content bg-transparent border-0"><div class="modal-body"><div class="credit-card-wrap" onclick="this.classList.toggle('flipped')"><div class="credit-card-inner"><div class="credit-card-front"><div class="d-flex justify-content-between align-items-center"><div style="width:40px;height:30px;background:#d4af37;border-radius:4px;"></div><i class="fas fa-wifi"></i></div><div class="card-number mt-4" id="successCardNumber">####</div><div class="mt-auto d-flex justify-content-between"><div class="card-holder" id="successCardHolder">NAME</div><div class="card-expiry" id="successCardExpiry">MM/YY</div></div></div><div class="credit-card-back"><div style="background:#000;height:40px;width:100%;margin-top:20px;"></div><div style="background:#fff;color:#000;width:80%;margin:10px auto;text-align:right;padding-right:10px;" id="successCardCvv">000</div></div></div></div><div class="text-center mt-3"><button class="btn btn-outline-light rounded-pill px-4" data-bs-dismiss="modal">Close</button></div></div></div></div></div>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
<script>
    let createModal, successModal, balanceModal;
    document.addEventListener('DOMContentLoaded', () => {
        createModal = new bootstrap.Modal(document.getElementById('createCardModal'));
        successModal = new bootstrap.Modal(document.getElementById('successCardModal'));
        balanceModal = new bootstrap.Modal(document.getElementById('balanceModal'));
        loadCards(); loadTickets();
    });

    function switchTab(tab) {
        document.querySelectorAll('.nav-link').forEach(l => l.classList.remove('active'));
        document.getElementById('tab-' + tab).classList.add('active');
        document.getElementById('section-cards').classList.add('d-none');
        document.getElementById('section-tickets').classList.add('d-none');
        document.getElementById('section-' + tab).classList.remove('d-none');
        if(tab === 'cards') loadCards();
        if(tab === 'tickets') loadTickets();
    }

    async function loadCards() {
        try {
            const response = await fetch('/api/admin/cards?page=0&size=50');
            if (response.status === 401) { window.location.href = '/login'; return; }
            const data = await response.json();
            const tbody = document.getElementById('cardsTable');
            const reqBody = document.getElementById('requestsTable');
            const reqSection = document.getElementById('requestsSection');
            tbody.innerHTML = ''; reqBody.innerHTML = ''; let hasRequests = false;

            data.content.forEach(card => {
                if(card.cardStatus.includes('PENDING')) {
                    hasRequests = true;
                    reqBody.innerHTML += `<tr><td class="ps-4 fw-bold">${card.username}</td><td class="font-monospace text-muted">${card.cardNumber}</td><td><span class="badge bg-warning text-dark">${card.cardStatus}</span></td><td class="text-end pe-4"><button class="btn btn-sm btn-success me-1" onclick="${card.cardStatus==='PENDING_BLOCK'?'approveBlock':'approveUnblock'}(${card.id})">YES</button><button class="btn btn-sm btn-outline-light" onclick="declineRequest(${card.id})">NO</button></td></tr>`;
                }
                let statusColor = card.cardStatus === 'ACTIVE' ? 'text-success' : 'text-danger';
                tbody.innerHTML += `
                    <tr><td class="ps-4 text-muted">#${card.id}</td><td>${card.username}</td><td class="font-monospace text-white">${card.cardNumber}</td><td class="fw-bold text-white">${card.balance.toFixed(2)}</td><td class="${statusColor} fw-bold">${card.cardStatus}</td>
                    <td class="text-end pe-4"><div class="btn-group btn-group-sm"><button class="btn btn-outline-secondary" onclick="openBalanceModal(${card.id}, 'deposit')">+</button><button class="btn btn-outline-secondary" onclick="openBalanceModal(${card.id}, 'withdraw')">-</button><button class="btn btn-outline-danger" onclick="deleteCard(${card.id})"><i class="fas fa-trash"></i></button>${card.cardStatus==='ACTIVE' ? `<button class="btn btn-outline-warning" onclick="blockCard(${card.id})"><i class="fas fa-lock"></i></button>` : ''}${card.cardStatus==='BLOCKED' ? `<button class="btn btn-outline-success" onclick="activateCard(${card.id})"><i class="fas fa-unlock"></i></button>` : ''}</div></td></tr>`;
            });
            if(hasRequests) reqSection.classList.remove('d-none'); else reqSection.classList.add('d-none');
        } catch (e) {}
    }

    async function loadTickets() {
        try {
            const res = await fetch('/api/admin/tickets/open');
            const tickets = await res.json();
            const grid = document.getElementById('ticketsGrid');
            const badge = document.getElementById('ticketBadge');
            if(tickets.length > 0) { badge.innerText = tickets.length; badge.classList.remove('d-none'); } else { badge.classList.add('d-none'); }
            grid.innerHTML = '';
            if(tickets.length === 0) { grid.innerHTML = '<div class="col-12 text-center text-muted py-5">No active tickets</div>'; return; }
            tickets.forEach(t => {
                let btn = t.status === 'OPEN' ? `<button class="btn btn-warning btn-sm w-100" onclick="assignTicket(${t.id})">Take Ticket</button>` : `<button class="btn btn-success btn-sm w-100" onclick="closeTicket(${t.id})">Close Ticket</button>`;
                grid.innerHTML += `<div class="col-md-4"><div class="card card-custom p-3 border-secondary"><div class="d-flex justify-content-between mb-2"><span class="badge bg-secondary">${t.status}</span><small class="text-muted">${t.createdByUsername}</small></div><h6 class="fw-bold text-white">${t.subject}</h6><p class="small text-muted bg-dark p-2 rounded">${t.description}</p>${btn}</div></div>`;
            });
        } catch(e) {}
    }

    // Reuse logic (functions are same as before)
    async function assignTicket(id) { if(confirm('Take ticket?')) { await fetch(`/api/admin/tickets/${id}/assign`, { method:'POST' }); loadTickets(); } }
    async function closeTicket(id) { if(confirm('Close ticket?')) { await fetch(`/api/admin/tickets/${id}/close`, { method:'POST' }); loadTickets(); } }
    async function approveBlock(id) { await fetch(`/api/admin/cards/${id}/approve-block`, { method: 'POST' }); loadCards(); }
    async function approveUnblock(id) { await fetch(`/api/admin/cards/${id}/approve-unblock`, { method: 'POST' }); loadCards(); }
    async function declineRequest(id) { await fetch(`/api/admin/cards/${id}/decline`, { method: 'POST' }); loadCards(); }
    async function blockCard(id) { if(confirm('Block?')) await fetch(`/api/admin/cards/${id}/block`, { method: 'POST' }); loadCards(); }
    async function activateCard(id) { await fetch(`/api/admin/cards/${id}/activate`, { method: 'POST' }); loadCards(); }
    async function deleteCard(id) { if(confirm('Delete?')) { await fetch(`/api/admin/cards/${id}`, { method: 'DELETE' }); loadCards(); }}
    function openBalanceModal(id, action) { document.getElementById('balanceCardId').value=id; document.getElementById('balanceAction').value=action; balanceModal.show(); }
    async function submitBalanceChange() { const id=document.getElementById('balanceCardId').value; const act=document.getElementById('balanceAction').value; const amt=document.getElementById('balanceAmount').value; await fetch(`/api/admin/cards/${id}/${act}`,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({amount:parseFloat(amt)})}); balanceModal.hide(); loadCards(); }
    async function openCreateModal() { const s=document.getElementById('userIdSelect'); s.innerHTML='<option>Loading...</option>'; document.getElementById('newCardNumber').value=''; const r=await fetch('/api/admin/users'); const u=await r.json(); s.innerHTML='<option disabled selected>Select User</option>'; u.forEach(x=>s.innerHTML+=`<option value="${x.id}">${x.username}</option>`); createModal.show(); }
    function generateRandomCardNumber() { let p=Math.random()>0.5?"4000":"5100"; let r=""; for(let i=0;i<11;i++) r+=Math.floor(Math.random()*10); let n=p+r; let s=0,d=true; for(let i=n.length-1;i>=0;i--){let x=parseInt(n.charAt(i)); if(d){x*=2;if(x>9)x-=9;}s+=x;d=!d;} document.getElementById('newCardNumber').value=n+((10-(s%10))%10); }
    async function submitCreateCard() { const u=document.getElementById('userIdSelect').value; const n=document.getElementById('newCardNumber').value; const h=document.getElementById('newCardHolder').value; const d=new Date(); d.setFullYear(d.getFullYear()+5); const res=await fetch('/api/admin/cards',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({userId:parseInt(u),cardNumber:n,cardHolder:h.toUpperCase(),expiryDate:d.toISOString().split('T')[0],balance:0})}); if(res.ok){ createModal.hide(); loadCards(); document.getElementById('successCardNumber').innerText=n; document.getElementById('successCardHolder').innerText=h.toUpperCase(); successModal.show(); } }
    async function logout() { await fetch('/api/auth/logout', { method: 'POST' }); window.location.href = '/login'; }
</script>
</body>
</html>


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\resources\templates\dashboard.html
================================================================================

<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>MyBank • Ultimate Cyber</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- CSS -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <!-- JS Libs -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.3.0/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vanilla-tilt/1.8.0/vanilla-tilt.min.js"></script>

    <style>
        :root {
            --bg-dark: #050505;
            --neon-blue: #00f2ff;
            --neon-purple: #bc13fe;
            --neon-green: #0aff60;
            --glass-bg: rgba(20, 20, 20, 0.9); /* Более плотный фон для читаемости */
            --glass-border: rgba(255, 255, 255, 0.15);
            --text-main: #ffffff;
            --text-sec: #cccccc;
        }

        body {
            background-color: var(--bg-dark);
            background-image:
                    linear-gradient(rgba(0, 242, 255, 0.03) 1px, transparent 1px),
                    linear-gradient(90deg, rgba(0, 242, 255, 0.03) 1px, transparent 1px);
            background-size: 50px 50px;
            font-family: 'Inter', sans-serif;
            color: var(--text-main);
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        /* --- CRITICAL CONTRAST FIXES --- */
        /* Принудительно красим весь текст в белый */
        body, h1, h2, h3, h4, h5, h6, p, span, div, label, td, th, i { color: #ffffff !important; }
        .text-muted { color: #aaaaaa !important; }
        .text-dark { color: #ffffff !important; }
        .text-info { color: var(--neon-blue) !important; }
        .text-warning { color: #ffd700 !important; }
        .text-danger { color: #ff4444 !important; }
        .text-success { color: var(--neon-green) !important; }

        /* Inputs & Selects - FORCE DARK */
        .form-control, .form-select {
            background-color: #111 !important;
            border: 1px solid #444 !important;
            color: #fff !important;
            border-radius: 12px;
        }
        .form-control:focus, .form-select:focus {
            border-color: var(--neon-blue) !important;
            background-color: #1a1a1a !important;
            box-shadow: 0 0 10px rgba(0, 242, 255, 0.2) !important;
            color: #fff !important;
        }
        .form-control::placeholder { color: #777 !important; }
        select option { background-color: #000; color: #fff; }

        /* Modals - FORCE DARK */
        .modal-content {
            background-color: #0f0f0f !important;
            border: 1px solid var(--glass-border) !important;
            color: #fff !important;
            box-shadow: 0 0 50px rgba(0,0,0,0.9);
        }
        .modal-header, .modal-footer { border-color: #333 !important; }
        .btn-close { filter: invert(1) !important; opacity: 1 !important; }

        /* --- UI COMPONENTS --- */
        .glass-card {
            background: var(--glass-bg);
            backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px);
            border: 1px solid var(--glass-border); border-radius: 24px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.6);
            transition: transform 0.3s, box-shadow 0.3s;
        }
        .glass-card:hover { transform: translateY(-4px); box-shadow: 0 0 25px rgba(0, 242, 255, 0.1); border-color: rgba(255, 255, 255, 0.3); }

        .navbar-custom { background: rgba(5, 5, 5, 0.95); border-bottom: 1px solid var(--glass-border); z-index: 1000; }

        /* LIVE TICKER (FIXED) */
        .ticker-wrap {
            width: 100%; overflow: hidden; background: #000; border-bottom: 1px solid rgba(255,255,255,0.1); height: 36px;
            display: flex; align-items: center; position: relative; z-index: 990;
        }
        .ticker { display: inline-block; white-space: nowrap; animation: ticker 40s linear infinite; }
        .ticker-item {
            display: inline-block; padding: 0 2rem; font-size: 0.85rem;
            font-family: 'Space Mono', monospace; color: var(--neon-green) !important;
        }
        @keyframes ticker { 0% { transform: translate3d(0, 0, 0); } 100% { transform: translate3d(-100%, 0, 0); } }

        /* Buttons */
        .btn-primary {
            background: linear-gradient(90deg, var(--neon-blue), #0077ff) !important; border: none;
            color: #000 !important; font-weight: 800; text-transform: uppercase; letter-spacing: 1px;
        }
        .btn-primary:hover { box-shadow: 0 0 25px rgba(0, 242, 255, 0.6); transform: scale(1.02); }
        .btn-outline-light { border-color: rgba(255,255,255,0.3); color: #ccc !important; }
        .btn-outline-light:hover { background: rgba(255,255,255,0.1); color: #fff !important; }

        /* Quick Transfers */
        .quick-avatar-wrap { text-align: center; cursor: pointer; transition: transform 0.2s; min-width: 60px; position: relative; }
        .quick-avatar-wrap:hover { transform: scale(1.1); }
        .quick-avatar-img { width: 50px; height: 50px; border-radius: 50%; background: #222; border: 2px solid var(--neon-blue); padding: 2px; }
        .quick-avatar-add { width: 50px; height: 50px; border-radius: 50%; background: rgba(255,255,255,0.1); border: 2px dashed #666; display: flex; align-items: center; justify-content: center; font-size: 1.5rem; color: #aaa !important; transition: 0.3s; }
        .quick-avatar-add:hover { border-color: var(--neon-blue); color: var(--neon-blue) !important; background: rgba(0, 242, 255, 0.1); }
        .delete-quick { position: absolute; top: -2px; right: 0; font-size: 10px; color: white !important; background: #ff4444; border-radius: 50%; width: 18px; height: 18px; display: none; align-items: center; justify-content: center; border: 1px solid #fff; }
        .quick-avatar-wrap:hover .delete-quick { display: flex; }

        /* Avatar Main */
        .cyber-avatar { width: 45px; height: 45px; border-radius: 50%; border: 2px solid var(--neon-blue); background: #000; cursor: pointer; transition: transform 0.3s; }
        .cyber-avatar:hover { transform: scale(1.1) rotate(5deg); box-shadow: 0 0 15px var(--neon-blue); }

        /* Table */
        .table-custom { --bs-table-bg: transparent; --bs-table-color: #fff; }
        .table-custom th { color: #aaa !important; border-bottom: 1px solid rgba(255,255,255,0.2); padding-bottom: 15px; font-size: 0.75rem; text-transform: uppercase; }
        .table-custom td { padding: 15px 0.5rem; vertical-align: middle; border-bottom: 1px solid rgba(255,255,255,0.05); }
        .table-custom tbody tr:hover { background-color: rgba(255, 255, 255, 0.1); }

        /* Matrix Rain Canvas */
        #matrixCanvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -2; opacity: 0.07; pointer-events: none; }

        /* Tier Badge */
        .tier-badge {
            background: #222; border: 1px solid rgba(255,255,255,0.2); color: #fff !important;
            padding: 5px 12px; border-radius: 20px; font-size: 0.7rem; font-weight: 800; text-transform: uppercase; letter-spacing: 1px;
        }
        .tier-elite { background: linear-gradient(135deg, var(--neon-blue), var(--neon-purple)); border:none; box-shadow: 0 0 15px rgba(188, 19, 254, 0.5); }

        /* Card 3D */
        .credit-card-wrap { perspective: 1000px; width: 100%; max-width: 360px; height: 220px; margin: 0 auto; cursor: pointer; }
        .credit-card-inner { position: relative; width: 100%; height: 100%; text-align: center; transition: transform 0.8s; transform-style: preserve-3d; }
        .credit-card-wrap.flipped .credit-card-inner { transform: rotateY(180deg); }
        .credit-card-front { background: linear-gradient(135deg, #111, #222); padding: 25px; border-radius: 20px; border: 1px solid rgba(255,255,255,0.2); backface-visibility: hidden; display: flex; flex-direction: column; justify-content: space-between; }
        .credit-card-back { background: #1a1a1a; padding-top: 25px; border-radius: 20px; backface-visibility: hidden; transform: rotateY(180deg); position: absolute; top:0; left:0; width:100%; height:100%; }
        .card-bottom-row { margin-right: 60px; } /* Fix overlap */
        .card-number { font-family: 'Space Mono', monospace; font-size: 1.4rem; letter-spacing: 2px; text-shadow: 0 0 8px rgba(255,255,255,0.4); text-align: left; margin-top: 10px; }

        /* Utils */
        .money-font { font-family: 'Space Mono', monospace; letter-spacing: -0.5px; }
        .blur-active .sensitive-data { filter: blur(8px); opacity: 0.6; }
        .animate-up { animation: fadeInUp 0.6s ease-out forwards; opacity: 0; transform: translateY(20px); }
        @keyframes fadeInUp { to { opacity: 1; transform: translateY(0); } }
        .delay-1 { animation-delay: 0.1s; } .delay-2 { animation-delay: 0.2s; } .delay-3 { animation-delay: 0.3s; }
        .pulse-dot { display: inline-block; width: 8px; height: 8px; background: #0aff60; border-radius: 50%; animation: pulse-green 2s infinite; box-shadow: 0 0 10px #0aff60; }
        @keyframes pulse-green { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }

        /* Dropdown Fix */
        .dropdown-menu { background-color: #1a1a1a !important; border: 1px solid #444 !important; }
        .dropdown-item { color: #fff !important; border-bottom: 1px solid #333; }
        .dropdown-item:hover { background-color: #333 !important; }
    </style>
</head>
<body id="appBody">

<canvas id="matrixCanvas"></canvas>

<nav class="navbar navbar-expand-lg navbar-dark navbar-custom px-4 py-3 sticky-top">
    <div class="container-fluid">
        <a class="navbar-brand fw-bold fs-4 d-flex align-items-center gap-2" href="#">
            <div class="d-flex align-items-center justify-content-center" style="width:32px; height:32px; background: var(--neon-blue); border-radius:8px; color:black;">
                <i class="fas fa-bolt text-dark"></i>
            </div>
            <span style="letter-spacing: -0.5px;">CYBER<span style="color: var(--neon-blue) !important">BANK</span></span>
        </a>

        <div class="d-flex align-items-center gap-3">
            <button class="btn btn-sm btn-outline-light rounded-pill px-3 border-secondary" onclick="openSupportModal()">
                <i class="fas fa-headset me-2"></i>Help
            </button>

            <div class="d-none d-md-flex align-items-center px-3 py-2 rounded-pill" style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2);">
                <span class="fw-bold money-font sensitive-data text-white" id="navTotalBalance">--.--</span>
                <span class="ms-1 text-info small">BYN</span>
                <button class="btn btn-link btn-sm text-white ms-2 p-0 opacity-75 hover-opacity-100" onclick="togglePrivacy()" title="Скрыть суммы">
                    <i class="fas fa-eye" id="privacyIcon"></i>
                </button>
            </div>

            <div class="dropdown">
                <button class="btn btn-dark rounded-circle position-relative border border-secondary d-flex align-items-center justify-content-center" style="width: 42px; height: 42px;" data-bs-toggle="dropdown" onclick="markNotificationsRead()">
                    <i class="far fa-bell text-white"></i>
                    <span id="notifBadge" class="position-absolute top-0 start-100 translate-middle p-1 bg-danger border border-dark rounded-circle d-none"></span>
                </button>
                <ul class="dropdown-menu dropdown-menu-end shadow-lg" id="notifList">
                    <li><span class="dropdown-item text-muted text-center py-3">Нет новых уведомлений</span></li>
                </ul>
            </div>

            <img id="userAvatar" src="" class="cyber-avatar" title="Ваш профиль">

            <button onclick="logout()" class="btn btn-outline-danger btn-sm rounded-pill px-4 fw-bold">EXIT</button>
        </div>
    </div>
</nav>

<!-- LIVE TICKER -->
<div class="ticker-wrap">
    <div class="ticker">
        <span class="ticker-item">USD/BYN: <span id="tick-usd" class="text-white">...</span></span>
        <span class="ticker-item">EUR/BYN: <span id="tick-eur" class="text-white">...</span></span>
        <span class="ticker-item">RUB/BYN: <span id="tick-rub" class="text-white">...</span></span>
        <span class="ticker-item text-info">BTC: $98,150 ▲</span>
        <span class="ticker-item text-info">ETH: $3,520 ▼</span>
        <span class="ticker-item text-warning">MYBANK: ONLINE</span>
    </div>
</div>

<div class="container py-5">
    <div class="row mb-5 align-items-end animate-up">
        <div class="col-lg-8">
            <div class="d-flex align-items-center gap-3 mb-1">
                <h1 class="fw-bold mb-0 display-5" id="greetingText">Dashboard</h1>
                <span class="tier-badge" id="userTierBadge">LOADING...</span>
            </div>
            <p class="text-muted fs-6 mb-0" id="currentDateDisplay">Загрузка даты...</p>
            <div class="mt-2 small text-muted"><i class="fas fa-keyboard me-1"></i> Hotkeys: <span class="badge bg-secondary border border-light text-white">T</span> Transfer <span class="badge bg-secondary border border-light text-white">H</span> History</div>
        </div>
        <div class="col-lg-4 text-lg-end">
            <button onclick="openTransferModal()" class="btn btn-lg rounded-pill shadow-lg px-5 w-100 w-lg-auto fw-bold btn-primary">
                <i class="fas fa-paper-plane me-2"></i>ПЕРЕВОД
            </button>
        </div>
    </div>

    <div class="row g-4 mb-5">
        <!-- Cards List -->
        <div class="col-lg-8" id="cardsList">
            <div class="glass-card p-5 text-center text-muted">
                <div class="spinner-border text-info mb-3" role="status"></div>
                <div>Загрузка данных...</div>
            </div>
        </div>

        <!-- Sidebar -->
        <div class="col-lg-4">

            <!-- Quick Transfer (Backend) -->
            <div class="glass-card p-4 mb-4 animate-up delay-1">
                <h6 class="text-uppercase text-muted mb-3 fw-bold small"><i class="fas fa-bolt me-2 text-warning"></i>Быстрый перевод</h6>
                <div class="d-flex gap-3 overflow-x-auto pb-2 align-items-start" id="quickTransferList">
                    <div class="text-center text-muted w-100 py-2 small">Загрузка...</div>
                </div>
            </div>

            <!-- Spending Limit -->
            <div class="glass-card p-4 mb-4 animate-up delay-1">
                <div class="d-flex justify-content-between align-items-center mb-2">
                    <h6 class="text-uppercase text-muted mb-0 fw-bold small"><i class="fas fa-wallet me-2"></i>Лимит (Мес.)</h6>
                    <span class="badge bg-dark border border-secondary sensitive-data text-white" id="spendingAmount">0 BYN</span>
                </div>
                <div class="progress mb-2" style="height: 6px; background: rgba(255,255,255,0.1);">
                    <div class="progress-bar bg-info" id="spendingBar" style="width: 0%;"></div>
                </div>
                <div class="d-flex justify-content-between align-items-center">
                    <small class="text-muted" style="font-size: 0.7rem;" id="spendingPercent">0%</small>
                    <div class="d-flex align-items-center">
                        <small class="text-muted sensitive-data me-2" style="font-size: 0.7rem;">Макс: <span id="limitDisplay">...</span> BYN</small>
                        <button class="btn btn-link btn-sm p-0 text-info" onclick="changeLimit()" title="Изменить">
                            <i class="fas fa-pencil-alt"></i>
                        </button>
                    </div>
                </div>
            </div>

            <!-- Analytics -->
            <div class="glass-card p-4 mb-4 animate-up delay-2 js-tilt">
                <h6 class="text-uppercase text-muted mb-3 fw-bold small"><i class="fas fa-chart-pie me-2"></i>Статистика</h6>
                <div style="height: 180px; position: relative;">
                    <canvas id="financeChart"></canvas>
                    <div id="chartCenterText" class="d-none" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; pointer-events: none;">
                        <small class="text-muted text-uppercase" style="font-size: 0.6rem;">Статус</small>
                        <div class="fw-bold text-white">Active</div>
                    </div>
                    <div id="chartNoData" class="d-none" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; width: 100%;">
                        <i class="fas fa-ban fa-2x mb-2 text-muted opacity-50"></i>
                        <div class="small text-muted">Нет данных</div>
                    </div>
                </div>
            </div>

            <!-- Rates -->
            <div class="glass-card p-4 animate-up delay-3">
                <div class="d-flex justify-content-between align-items-center mb-3">
                    <h6 class="text-uppercase text-muted mb-0 fw-bold small"><i class="fas fa-globe me-2"></i>Рынок (NBRB)</h6>
                    <div class="pulse-dot"></div>
                </div>
                <div class="d-flex justify-content-between mb-2 p-2 rounded" style="background: rgba(255,255,255,0.05);">
                    <div class="d-flex align-items-center gap-2"><img src="https://flagcdn.com/w20/us.png" class="rounded-circle" width="20"><span class="fw-bold text-white">USD</span></div>
                    <span class="money-font text-info" id="rate-usd">...</span>
                </div>
                <div class="d-flex justify-content-between mb-2 p-2 rounded" style="background: rgba(255,255,255,0.05);">
                    <div class="d-flex align-items-center gap-2"><img src="https://flagcdn.com/w20/eu.png" class="rounded-circle" width="20"><span class="fw-bold text-white">EUR</span></div>
                    <span class="money-font text-info" id="rate-eur">...</span>
                </div>
                <div class="d-flex justify-content-between p-2 rounded" style="background: rgba(255,255,255,0.05);">
                    <div class="d-flex align-items-center gap-2"><img src="https://flagcdn.com/w20/ru.png" class="rounded-circle" width="20"><span class="fw-bold text-white">RUB</span></div>
                    <span class="money-font text-info" id="rate-rub">...</span>
                </div>
            </div>
        </div>
    </div>

    <!-- History -->
    <div class="row animate-up delay-3">
        <div class="col-12">
            <div class="glass-card p-4">
                <h5 class="mb-4 fw-bold text-white">Последние транзакции</h5>
                <div class="table-responsive">
                    <table class="table table-custom align-middle mb-0">
                        <thead>
                        <tr>
                            <th class="ps-3">Тип</th>
                            <th>Описание</th>
                            <th>Дата</th>
                            <th class="text-end pe-3">Сумма (BYN)</th>
                        </tr>
                        </thead>
                        <tbody id="historyList"><tr><td colspan="4" class="text-center py-4 text-muted">Загрузка...</td></tr></tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Modal: View Card -->
<div class="modal fade" id="viewCardModal" tabindex="-1"><div class="modal-dialog modal-dialog-centered"><div class="modal-content"><div class="modal-body text-center p-4"><div class="credit-card-wrap" onclick="this.classList.toggle('flipped')"><div class="credit-card-inner"><div class="credit-card-front"><div class="d-flex justify-content-between align-items-center"><div class="card-chip" style="width:45px;height:35px;background:linear-gradient(135deg,#d4af37,#f9d976);border-radius:6px;box-shadow:inset 0 1px 3px rgba(0,0,0,0.3);"></div><i class="fas fa-wifi fa-lg opacity-75"></i></div><div class="card-number mt-3 sensitive-data" id="modalCardNumber" onclick="copyCardNumber(event)" style="cursor:copy">####</div><div class="d-flex justify-content-between align-items-end mt-auto card-bottom-row"><div class="text-start"><div class="small opacity-50" style="font-size:0.6rem;">HOLDER</div><div class="card-holder text-uppercase" id="modalCardHolder">NAME</div></div><div class="text-end"><div class="small opacity-50" style="font-size:0.6rem;">EXPIRES</div><div class="card-holder sensitive-data" id="modalCardExpiry">MM/YY</div></div></div><img id="modalCardLogo" src="" style="position:absolute;bottom:20px;right:20px;width:50px;filter:drop-shadow(0 2px 2px rgba(0,0,0,0.5));"></div><div class="credit-card-back"><div style="background:#000;height:45px;width:100%;margin-top:20px;"></div><div class="d-flex justify-content-end px-4 mt-3"><div class="bg-white text-dark d-flex align-items-center justify-content-end px-2 sensitive-data" style="width:60px;height:30px;font-family:'Space Mono';font-style:italic;" id="modalCardCvv">000</div></div></div></div></div><div class="mt-4"><h2 class="fw-bold text-info money-font mb-1 sensitive-data" id="modalCardBalance">0.00 BYN</h2><div class="mb-4 small text-muted" id="modalCardStatus">ACTIVE</div><div id="modalActions" class="d-grid gap-2 col-8 mx-auto"></div></div></div></div></div></div>
<div class="modal fade" id="transferModal" tabindex="-1"><div class="modal-dialog modal-dialog-centered"><div class="modal-content"><div class="modal-header"><h5 class="modal-title fw-bold">Перевод средств</h5><button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button></div><div class="modal-body p-4"><form id="transferForm"><div class="mb-3"><label class="small text-muted mb-1">С карты</label><select id="transferFromCard" class="form-select"></select></div><div class="d-flex bg-dark rounded p-1 mb-3 border border-secondary"><button type="button" class="btn btn-sm flex-fill text-white" id="btnTypeOthers" onclick="toggleTransferType('others')" style="background: rgba(255,255,255,0.1)">Клиенту</button><button type="button" class="btn btn-sm flex-fill text-muted" id="btnTypeSelf" onclick="toggleTransferType('self')">Свои счета</button></div><div class="mb-3"><label class="small text-muted mb-1">Получатель</label><div id="targetInputContainer"><input type="text" id="transferToCardInput" class="form-control money-font" placeholder="0000 0000 0000 0000" maxlength="19"></div><div id="targetSelectContainer" class="d-none"><select id="transferToCardSelect" class="form-select"></select></div></div><div class="mb-4"><label class="small text-muted mb-1">Сумма (BYN)</label><input type="number" id="transferAmount" class="form-control fs-4 fw-bold text-info money-font" placeholder="0.00"></div><button type="button" class="btn btn-primary w-100 rounded-pill py-2" onclick="submitTransfer()">Отправить</button></form></div></div></div></div>
<div class="modal fade" id="supportModal" tabindex="-1"><div class="modal-dialog modal-lg modal-dialog-centered"><div class="modal-content"><div class="modal-header"><h5 class="modal-title fw-bold">Поддержка</h5><button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button></div><div class="modal-body p-0"><div class="row g-0"><div class="col-md-5 border-end border-secondary" style="height: 400px; overflow-y: auto;"><div class="p-3 border-bottom border-secondary bg-dark sticky-top d-flex justify-content-between"><span class="small fw-bold text-muted">ИСТОРИЯ</span><button class="btn btn-sm btn-link text-info p-0" onclick="loadMyTickets()"><i class="fas fa-sync"></i></button></div><div id="ticketsList" class="list-group list-group-flush"></div></div><div class="col-md-7 p-4"><h6 class="fw-bold mb-3">Новый вопрос</h6><input type="text" id="ticketSubject" class="form-control mb-3" placeholder="Тема"><textarea id="ticketDesc" class="form-control mb-3" rows="6" placeholder="Описание проблемы..."></textarea><div class="text-end"><button type="button" class="btn btn-primary px-4 rounded-pill" onclick="createTicket()">Создать</button></div></div></div></div></div></div></div>
<div id="copyToast" class="position-fixed bottom-0 start-50 translate-middle-x mb-4 bg-white text-dark px-4 py-2 rounded-pill fw-bold opacity-0 shadow-lg" style="z-index: 9999; transition: opacity 0.3s; border: 1px solid var(--neon-blue);"><i class="fas fa-check-circle text-success me-2"></i>Скопировано в буфер</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/js/bootstrap.bundle.min.js"></script>

<script>
    let viewModal, transferModal, supportModal, financeChart;
    const VISA_LOGO = "https://upload.wikimedia.org/wikipedia/commons/thumb/5/5e/Visa_Inc._logo.svg/1200px-Visa_Inc._logo.svg.png";
    const MC_LOGO = "https://upload.wikimedia.org/wikipedia/commons/thumb/2/2a/Mastercard-logo.svg/1280px-Mastercard-logo.svg.png";
    let myCards = [], allTransactions = [], transferMode = 'others', currentRates = { USD: 0, EUR: 0, RUB: 0 }, isPrivacyOn = false, currentExpenses = 0, monthlyLimit = 5000;

    document.addEventListener('DOMContentLoaded', () => {
        if (typeof bootstrap === 'undefined') return;
        viewModal = new bootstrap.Modal(document.getElementById('viewCardModal'));
        transferModal = new bootstrap.Modal(document.getElementById('transferModal'));
        supportModal = new bootstrap.Modal(document.getElementById('supportModal'));
        try { VanillaTilt.init(document.querySelectorAll(".js-tilt")); } catch(e) {}

        // Hotkeys
        document.addEventListener('keydown', (e) => {
            if(e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            if(e.key.toLowerCase() === 't') openTransferModal();
            if(e.key.toLowerCase() === 'h') { document.getElementById('historyList').scrollIntoView({behavior: 'smooth'}); }
        });

        initMatrix();
        updateGreeting();
        loadProfileAndData();
        loadNotifications();
        loadQuickTransfers(); // Load from BACKEND
        fetchNBRBRates();
    });

    // --- QUICK TRANSFER LOGIC (BACKEND INTEGRATION) ---
    async function loadQuickTransfers() {
        const list = document.getElementById('quickTransferList');
        try {
            const res = await fetch('/api/user/quick-transfers');
            if(res.ok) {
                const data = await res.json();
                renderQuickTransfers(data);
            } else {
                renderQuickTransfers([]);
            }
        } catch(e) { console.error("QT Error", e); }
    }

    function renderQuickTransfers(transfers) {
        const list = document.getElementById('quickTransferList');
        list.innerHTML = '';

        transfers.forEach(qt => {
            const avatarUrl = `https://robohash.org/${qt.name}?set=set1&bgset=bg2`;
            const item = document.createElement('div');
            item.className = 'quick-avatar-wrap';
            item.innerHTML = `
                <img src="${avatarUrl}" class="quick-avatar-img">
                <span class="quick-avatar-name">${qt.name}</span>
                <i class="fas fa-times delete-quick" onclick="deleteQuickTransfer(${qt.id}, event)"></i>
            `;
            item.onclick = (e) => {
                if(!e.target.classList.contains('delete-quick')) {
                    openQuickTransfer(qt.cardNumber);
                }
            };
            list.appendChild(item);
        });

        // Add Button
        const addButton = document.createElement('div');
        addButton.className = 'quick-avatar-wrap';
        addButton.innerHTML = `<div class="quick-avatar-add"><i class="fas fa-plus"></i></div><span class="quick-avatar-name" style="color:var(--neon-blue)">New</span>`;
        addButton.onclick = addQuickTransfer;
        list.appendChild(addButton);
    }

    async function addQuickTransfer() {
        const name = prompt("Имя контакта:");
        if (!name) return;
        const card = prompt("Номер карты:");
        if (!card || card.length < 16) { alert("Некорректный номер"); return; }

        try {
            const res = await fetch('/api/user/quick-transfers', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({name: name, cardNumber: card})
            });
            if(res.ok) { loadQuickTransfers(); } else { alert("Ошибка сохранения"); }
        } catch(e) { alert("Ошибка сети"); }
    }

    async function deleteQuickTransfer(id, e) {
        e.stopPropagation();
        if(confirm("Удалить контакт?")) {
            try {
                await fetch(`/api/user/quick-transfers/${id}`, { method: 'DELETE' });
                loadQuickTransfers();
            } catch(e) { alert("Ошибка удаления"); }
        }
    }

    function openQuickTransfer(cardNumber) {
        openTransferModal();
        toggleTransferType('others');
        document.getElementById('transferToCardInput').value = cardNumber;
    }

    // --- MAIN LOGIC ---
    async function loadProfileAndData() {
        try {
            const profileRes = await fetch('/api/user/profile');
            if (profileRes.ok) {
                const profile = await profileRes.json();
                document.getElementById('userAvatar').src = profile.avatarUrl;
                monthlyLimit = profile.monthlyLimit || 5000;
                document.getElementById('limitDisplay').innerText = monthlyLimit;
            }
            loadData();
        } catch(e) { console.error("Profile load error", e); }
    }

    async function changeLimit() {
        const newLimit = prompt("Установите лимит трат на месяц (BYN):", monthlyLimit);
        if (newLimit !== null && newLimit.trim() !== "") {
            const parsed = parseFloat(newLimit);
            if (!isNaN(parsed) && parsed >= 0) {
                try {
                    const res = await fetch('/api/user/profile/limit', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ limit: parsed }) });
                    if (res.ok) { monthlyLimit = parsed; document.getElementById('limitDisplay').innerText = monthlyLimit; updateSpendingWidget(currentExpenses); alert("Лимит обновлен!"); }
                    else { alert("Ошибка сохранения"); }
                } catch(e) { alert("Ошибка сети"); }
            } else { alert("Введите корректное число."); }
        }
    }

    function togglePrivacy() {
        isPrivacyOn = !isPrivacyOn;
        const body = document.body;
        const icon = document.getElementById('privacyIcon');
        if (isPrivacyOn) { body.classList.add('blur-active'); icon.classList.remove('fa-eye'); icon.classList.add('fa-eye-slash'); }
        else { body.classList.remove('blur-active'); icon.classList.remove('fa-eye-slash'); icon.classList.add('fa-eye'); }
    }

    function updateGreeting() {
        const now = new Date(); const h = now.getHours(); const t = document.getElementById('greetingText');
        if(h<6) t.innerText='Доброй ночи'; else if(h<12) t.innerText='Доброе утро'; else if(h<18) t.innerText='Добрый день'; else t.innerText='Добрый вечер';
        const dateOptions = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
        document.getElementById('currentDateDisplay').innerText = now.toLocaleDateString('ru-RU', dateOptions);
    }

    function updateUserTier(balance) {
        const badge = document.getElementById('userTierBadge');
        badge.className = 'tier-badge';
        if (balance > 10000) { badge.innerText = 'CYBER ELITE'; badge.classList.add('tier-elite'); }
        else if (balance > 1000) { badge.innerText = 'PLATINUM'; badge.classList.add('tier-platinum'); }
        else if (balance > 100) { badge.innerText = 'GOLD'; badge.classList.add('tier-gold'); }
        else { badge.innerText = 'STANDARD'; }
    }

    async function loadData() {
        const container = document.getElementById('cardsList');
        try {
            const balRes = await fetch('/api/user/cards/balance');
            if (balRes.status === 401 || balRes.status === 403) { window.location.href = '/login'; return; }
            const bal = await balRes.json();
            animateValue("navTotalBalance", 0, bal || 0, 1000);
            updateUserTier(bal || 0);

            const cardRes = await fetch('/api/user/cards?page=0&size=50');
            const data = await cardRes.json();
            myCards = data.content;

            if (!myCards || myCards.length === 0) {
                container.innerHTML = '<div class="glass-card p-5 text-center text-muted">Нет активных карт</div>';
                loadHistory(); return;
            }

            let html = '';
            for (let i = 0; i < myCards.length; i += 2) {
                html += '<div class="row g-4 mb-4">';
                html += generateCardHtml(myCards[i], i);
                if (i + 1 < myCards.length) html += generateCardHtml(myCards[i+1], i+1);
                html += '</div>';
            }
            container.innerHTML = html;
            loadHistory();
        } catch(e) { container.innerHTML = '<div class="glass-card p-5 text-center text-danger">Ошибка</div>'; }
    }

    function generateCardHtml(card, index) {
        const firstDigit = card.cardNumber.trim().charAt(0);
        const logoClass = (firstDigit === '5') ? 'fa-cc-mastercard' : 'fa-cc-visa';
        let opacity = card.cardStatus === 'ACTIVE' ? '1' : '0.6';
        let glow = card.cardStatus === 'ACTIVE' ? 'box-shadow: 0 0 15px rgba(0, 242, 255, 0.1);' : '';
        let badgeColor = card.cardStatus === 'ACTIVE' ? 'bg-success' : 'bg-danger';
        return `
            <div class="col-md-6 animate-up delay-${(index % 3) + 1}">
                <div class="glass-card h-100 p-4 position-relative cursor-pointer" onclick="openCardModal('${card.id}')" style="opacity:${opacity}; ${glow}">
                    <div class="d-flex justify-content-between align-items-center mb-4">
                        <i class="fab ${logoClass} fa-2x text-white"></i>
                        <span class="badge ${badgeColor}">${card.cardStatus}</span>
                    </div>
                    <h5 class="font-monospace mb-2 text-white fw-bold sensitive-data" style="letter-spacing:2px; text-shadow: 0 0 5px rgba(255,255,255,0.3)">
                        **** ${card.cardNumber.slice(-4)}
                    </h5>
                    <div class="mt-3">
                        <span class="text-muted small text-uppercase" style="font-size: 0.65rem; letter-spacing: 1px;">Баланс</span>
                        <h3 class="fw-bold text-white mb-0 money-font sensitive-data">${card.balance.toFixed(2)} <span class="fs-6 text-info">BYN</span></h3>
                    </div>
                </div>
            </div>`;
    }

    async function loadHistory() {
        const tbody = document.getElementById('historyList');
        try {
            const r = await fetch('/api/user/transfers/my');
            if (r.ok) {
                const l = await r.json();
                allTransactions = [];
                let inc = 0, exp = 0;
                l.forEach(t => {
                    const isMineSender = myCards.some(c => c.cardNumber.endsWith(t.fromCardNumber.slice(-4)));
                    const isMineReceiver = myCards.some(c => c.cardNumber.endsWith(t.toCardNumber.slice(-4)));
                    if (isMineSender && isMineReceiver) {
                        allTransactions.push({type: 'self', desc: 'Между счетами', date: t.transferDate, amount: t.amount});
                    } else if (isMineSender) {
                        exp += t.amount; allTransactions.push({type: 'out', desc: 'Перевод клиенту', date: t.transferDate, amount: t.amount});
                    } else if (isMineReceiver) {
                        inc += t.amount; allTransactions.push({type: 'in', desc: 'Входящий перевод', date: t.transferDate, amount: t.amount});
                    }
                });
                currentExpenses = exp;
                allTransactions.sort((a, b) => new Date(b.date) - new Date(a.date));
                renderHistory(allTransactions); renderChart(inc, exp); updateSpendingWidget(exp);
            } else { tbody.innerHTML = '<tr><td colspan="4" class="text-center py-4 text-muted">Ошибка</td></tr>'; }
        } catch(e) { tbody.innerHTML = '<tr><td colspan="4" class="text-center py-4 text-muted">Ошибка</td></tr>'; }
    }

    function updateSpendingWidget(expenses) {
        const limit = parseFloat(monthlyLimit) || 5000;
        const percent = Math.min((expenses / limit) * 100, 100);
        document.getElementById('spendingAmount').innerText = expenses.toFixed(2) + ' BYN';
        document.getElementById('spendingPercent').innerText = percent.toFixed(0) + '%';
        const bar = document.getElementById('spendingBar');
        bar.style.width = percent + '%';
        if (percent > 90) bar.className = 'progress-bar bg-danger';
        else if (percent > 75) bar.className = 'progress-bar bg-warning';
        else bar.className = 'progress-bar bg-info';
    }

    function renderHistory(l) {
        const t = document.getElementById('historyList'); t.innerHTML = '';
        if (l.length === 0) { t.innerHTML = '<tr><td colspan="4" class="text-center py-4 text-muted">Операций не найдено</td></tr>'; return; }
        l.slice(0, 10).forEach(x => {
            let c, s, icon;
            if (x.type === 'out') { c = 'text-danger'; s = '-'; icon = '<i class="fas fa-arrow-up text-danger"></i>'; }
            else if (x.type === 'in') { c = 'text-info'; s = '+'; icon = '<i class="fas fa-arrow-down text-info"></i>'; }
            else { c = 'text-secondary'; s = ''; icon = '<i class="fas fa-exchange-alt text-secondary"></i>'; }
            t.innerHTML += `<tr><td class="ps-3">${icon}</td><td>${x.desc}</td><td class="text-muted small">${new Date(x.date).toLocaleDateString()}</td><td class="text-end pe-3 fw-bold money-font sensitive-data ${c}">${s}${x.amount.toFixed(2)}</td></tr>`;
        });
    }

    function renderChart(inc, exp) {
        const ctxCanvas = document.getElementById('financeChart');
        const noData = document.getElementById('chartNoData');
        const centerText = document.getElementById('chartCenterText');
        if(financeChart) financeChart.destroy();
        if(inc === 0 && exp === 0) { ctxCanvas.classList.add('d-none'); centerText.classList.add('d-none'); noData.classList.remove('d-none'); return; }
        ctxCanvas.classList.remove('d-none'); centerText.classList.remove('d-none'); noData.classList.add('d-none');
        const ctx = ctxCanvas.getContext('2d');
        financeChart = new Chart(ctx, { type: 'doughnut', data: { labels: ['Доходы', 'Расходы'], datasets: [{ data: [inc, exp], backgroundColor: ['#0aff60', '#ff3366'], borderWidth: 0, borderRadius: 20, spacing: 5 }] }, options: { responsive: true, maintainAspectRatio: false, cutout: '85%', plugins: { legend: { display: false } }, animation: { animateScale: true } } });
    }

    // Matrix Rain
    function initMatrix() { const c=document.getElementById('matrixCanvas'),x=c.getContext('2d'); c.width=window.innerWidth;c.height=window.innerHeight; const l="01", s=14, cl=c.width/s, d=[]; for(let i=0;i<cl;i++)d[i]=1; setInterval(()=>{x.fillStyle='rgba(0,0,0,0.05)';x.fillRect(0,0,c.width,c.height);x.fillStyle='#0F0';x.font=s+'px monospace';for(let i=0;i<d.length;i++){x.fillText(l[Math.floor(Math.random()*2)],i*s,d[i]*s);if(d[i]*s>c.height&&Math.random()>0.975)d[i]=0;d[i]++;}},50); }

    // Helpers
    async function fetchNBRBRates() { try{ const r=await fetch('https://api.nbrb.by/exrates/rates?periodicity=0'); const d=await r.json(); const u=d.find(c=>c.Cur_Abbreviation==='USD'); const e=d.find(c=>c.Cur_Abbreviation==='EUR'); const ru=d.find(c=>c.Cur_Abbreviation==='RUB'); if(u) { document.getElementById('rate-usd').innerText=u.Cur_OfficialRate.toFixed(4); document.getElementById('tick-usd').innerText=u.Cur_OfficialRate.toFixed(4); } if(e) { document.getElementById('rate-eur').innerText=e.Cur_OfficialRate.toFixed(4); document.getElementById('tick-eur').innerText=e.Cur_OfficialRate.toFixed(4); } if(ru) { document.getElementById('rate-rub').innerText=ru.Cur_OfficialRate.toFixed(4); document.getElementById('tick-rub').innerText=ru.Cur_OfficialRate.toFixed(4); } }catch(e){ document.getElementById('rate-usd').innerText="N/A"; } }
    async function createTicket() { const s = document.getElementById('ticketSubject').value; const d = document.getElementById('ticketDesc').value; if(!s || !d) { alert('Заполните поля!'); return; } try { const res = await fetch('/api/user/tickets', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({subject: s, description: d}) }); if (res.ok) { document.getElementById('createTicketForm').reset(); loadMyTickets(); alert('Тикет создан'); } } catch(e) { alert('Ошибка сети'); } }
    function openTransferModal() { const s=document.getElementById('transferFromCard'); s.innerHTML=''; const a=myCards.filter(c=>c.cardStatus==='ACTIVE'); if(a.length===0) {alert("Нет активных карт"); return;} a.forEach(c=>s.innerHTML+=`<option value="${c.id}">**** ${c.cardNumber.slice(-4)} (${c.balance} BYN)</option>`); toggleTransferType('others'); document.getElementById('transferAmount').value=''; document.getElementById('transferToCardInput').value=''; transferModal.show(); }
    function toggleTransferType(t) { transferMode=t; const bo=document.getElementById('btnTypeOthers'), bs=document.getElementById('btnTypeSelf'), ic=document.getElementById('targetInputContainer'), sc=document.getElementById('targetSelectContainer'); if(t==='others'){ bo.style.background='rgba(255,255,255,0.1)';bo.classList.replace('text-muted','text-white'); bs.style.background='transparent';bs.classList.replace('text-white','text-muted'); ic.classList.remove('d-none'); sc.classList.add('d-none'); } else{ bs.style.background='rgba(255,255,255,0.1)';bs.classList.replace('text-muted','text-white'); bo.style.background='transparent';bo.classList.replace('text-white','text-muted'); ic.classList.add('d-none'); sc.classList.remove('d-none'); updateMyCardsTarget(); } }
    function updateMyCardsTarget() { if(transferMode!=='self')return; const fid=document.getElementById('transferFromCard').value; const t=document.getElementById('transferToCardSelect'); t.innerHTML='<option disabled selected>Карта зачисления</option>'; myCards.filter(c=>c.id!=fid&&c.cardStatus==='ACTIVE').forEach(c=>{ t.innerHTML+=`<option value="${c.id}">**** ${c.cardNumber.slice(-4)}</option>`; }); }
    async function submitTransfer() { const fid=document.getElementById('transferFromCard').value; const amt=document.getElementById('transferAmount').value; let pl={fromCardId:parseInt(fid),amount:parseFloat(amt),description:"Web Transfer"}; if(transferMode==='others'){ const n=document.getElementById('transferToCardInput').value.replace(/\s/g,''); if(n.length<16)return; pl.toCardNumber=n; } else { const tid=document.getElementById('transferToCardSelect').value; pl.toCardId=parseInt(tid); } try{ const r=await fetch('/api/user/transfers',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(pl)}); if(r.ok){ transferModal.hide(); confetti({origin:{y:0.7},colors:['#00f2ff','#bc13fe']}); loadData(); loadNotifications(); }else{ alert('Ошибка'); } }catch(e){} }
    function openCardModal(id) { const c=myCards.find(x=>x.id==id); if(!c)return; document.getElementById('modalCardNumber').innerText=c.cardNumber; document.getElementById('modalCardHolder').innerText=c.cardHolder; if(c.expiryDate)document.getElementById('modalCardExpiry').innerText=c.expiryDate.split('-')[1]+'/'+c.expiryDate.split('-')[0].slice(-2); document.getElementById('modalCardBalance').innerText=c.balance.toFixed(2)+' BYN'; document.getElementById('modalCardCvv').innerText=Math.floor(Math.random()*899)+100; document.getElementById('modalCardLogo').src=c.cardNumber.trim().startsWith('5')?MC_LOGO:VISA_LOGO; document.getElementById('modalCardStatus').innerText=c.cardStatus; const a=document.getElementById('modalActions'); a.innerHTML=''; if(c.cardStatus==='ACTIVE')a.innerHTML=`<button onclick="sendRequest('${c.id}','block')" class="btn btn-outline-danger w-100">BLOCK</button>`; else if(c.cardStatus==='BLOCKED')a.innerHTML=`<button onclick="sendRequest('${c.id}','unblock')" class="btn btn-outline-success w-100">UNBLOCK</button>`; else a.innerHTML=`<button class="btn btn-outline-secondary disabled w-100">PENDING</button>`; viewModal.show(); }
    async function sendRequest(id,t) { if(confirm('Confirm?')){ await fetch(`/api/user/cards/${t}/${id}`,{method:'POST'}); viewModal.hide(); loadData(); } }
    function copyCardNumber(e) { navigator.clipboard.writeText(e.target.innerText.replace(/\s/g,'')); const t=document.getElementById('copyToast'); t.classList.remove('opacity-0'); setTimeout(()=>t.classList.add('opacity-0'),2000); }
    function animateValue(id,s,e,d) { const o=document.getElementById(id); if(!o)return; let st=null; const step=(ts)=>{ if(!st)st=ts; const p=Math.min((ts-st)/d,1); o.innerHTML=(p*(e-s)+s).toFixed(2); if(p<1)window.requestAnimationFrame(step); }; window.requestAnimationFrame(step); }
    function openSupportModal() { loadMyTickets(); supportModal.show(); }
    async function loadMyTickets() { const c=document.getElementById('ticketsList'); c.innerHTML='<div class="text-center p-3 small text-muted">Загрузка...</div>'; try{ const r=await fetch('/api/user/tickets'); const t=await r.json(); c.innerHTML=''; if(t.length===0){c.innerHTML='<div class="text-center p-4 text-muted small">Обращений нет</div>';return;} t.forEach(x=>{ c.innerHTML+=`<div class="list-group-item bg-transparent border-secondary text-white"><div class="d-flex justify-content-between"><span class="badge ${x.status==='OPEN'?'bg-success':'bg-secondary'}">${x.status}</span><small class="text-muted">${new Date(x.createdAt).toLocaleDateString()}</small></div><div class="mt-1 small">${x.subject}</div></div>`; }); }catch(e){ c.innerHTML='<div class="text-center text-danger small">Ошибка</div>'; } }
    async function loadNotifications() { try{ const r=await fetch('/api/user/notifications/unread'); if(r.ok){ const n=await r.json(); const b=document.getElementById('notifBadge'); const l=document.getElementById('notifList'); if(n.length>0){ b.classList.remove('d-none'); l.innerHTML=''; n.forEach(x=>{ l.innerHTML+=`<li><a class="dropdown-item" href="#">${x.message}</a></li>`; }); } } }catch(e){} }
    async function markNotificationsRead() { document.getElementById('notifBadge').classList.add('d-none'); }
    async function logout() { await fetch('/api/auth/logout',{method:'POST'}); window.location.href='/login'; }
</script>
</body>
</html>


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\resources\templates\fragments\scripts.html
================================================================================

<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<body>

<th:block th:fragment="scripts">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

    <script>
        const API_BASE_URL = '/api';

        // --- Token Management ---

        function setToken(accessToken, refreshToken) {
            localStorage.setItem('accessToken', accessToken);
            localStorage.setItem('refreshToken', refreshToken);
        }

        function getToken() {
            return localStorage.getItem('accessToken');
        }

        function clearToken() {
            localStorage.removeItem('accessToken');
            localStorage.removeItem('refreshToken');
        }

        // --- Generic API Fetcher ---

        async function apiFetch(url, method = 'GET', body = null) {
            const token = getToken();
            const headers = {
                'Content-Type': 'application/json'
            };

            if (token) {
                headers['Authorization'] = `Bearer ${token}`;
            }

            const options = {
                method: method,
                headers: headers
            };

            if (body) {
                options.body = JSON.stringify(body);
            }

            const response = await fetch(API_BASE_URL + url, options);

            if (response.status === 401 || response.status === 403) {
                // Handle unauthorized access (e.g., token expired)
                clearToken();
                alert("Session expired or unauthorized. Please log in again.");
                window.location.href = '/login';
                return null;
            }

            if (!response.ok) {
                // Try to parse error message from response body
                let errorData = {};
                try {
                    errorData = await response.json();
                } catch (e) {
                    errorData = { message: `HTTP error! Status: ${response.status} - ${response.statusText}` };
                }
                throw new Error(errorData.message || errorData.error || 'Unknown API Error');
            }

            // Handle 204 No Content
            if (response.status === 204) {
                return {};
            }

            return response.json();
        }

        // --- Common UI Functions ---

        function showMessage(type, message) {
            const container = document.getElementById('messageContainer');
            if (!container) return;

            const alertHtml = `
                <div class="alert alert-${type} alert-dismissible fade show" role="alert">
                    ${message}
                    <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
                </div>
            `;
            container.innerHTML = alertHtml;
        }

        function logout() {
            clearToken();
            window.location.href = '/login';
        }
    </script>
</th:block>

</body>
</html>


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\resources\templates\login.html
================================================================================

<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Вход • CyberBank</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        body {
            background-color: #050505;
            background-image: radial-gradient(circle at 50% -20%, #1a1a2e, #000);
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            color: white;
        }
        .orb { position: absolute; border-radius: 50%; filter: blur(80px); z-index: -1; opacity: 0.4; animation: float 10s infinite ease-in-out alternate; }
        .orb-1 { width: 300px; height: 300px; background: #bc13fe; top: 10%; left: 20%; }
        .orb-2 { width: 400px; height: 400px; background: #00f2ff; bottom: 10%; right: 20%; animation-delay: -5s; }
        @keyframes float { from { transform: translate(0, 0); } to { transform: translate(30px, 30px); } }

        .login-card {
            width: 100%; max-width: 400px;
            background: rgba(255, 255, 255, 0.03);
            backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 24px; padding: 3rem 2rem;
            box-shadow: 0 25px 50px rgba(0,0,0,0.5);
        }
        .form-control { background: rgba(0, 0, 0, 0.4); border: 1px solid rgba(255, 255, 255, 0.1); color: #fff; padding: 12px 15px; border-radius: 12px; }
        .form-control:focus { background: rgba(0, 0, 0, 0.6); color: #fff; border-color: #00f2ff; box-shadow: 0 0 15px rgba(0, 242, 255, 0.2); }
        .form-control::placeholder { color: rgba(255, 255, 255, 0.3); }

        /* Исправленный цвет лейблов */
        .form-label-custom { color: #ccc; font-size: 0.85rem; margin-bottom: 5px; display: block; margin-left: 5px; }

        .btn-neon { background: linear-gradient(90deg, #00f2ff, #00a8ff); border: none; color: #000; font-weight: 700; padding: 12px; border-radius: 12px; transition: 0.3s; text-transform: uppercase; letter-spacing: 1px; }
        .btn-neon:hover { box-shadow: 0 0 30px rgba(0, 242, 255, 0.4); color: #000; transform: scale(1.02); }
        .link-light-opacity { color: rgba(255,255,255,0.5); text-decoration: none; transition: 0.2s; }
        .link-light-opacity:hover { color: #fff; }
    </style>
</head>
<body>
<div class="orb orb-1"></div><div class="orb orb-2"></div>
<div class="login-card">
    <div class="text-center mb-5"><h2 class="fw-bold mb-1">Welcome Back</h2><p class="text-muted small">Войдите в свой цифровой аккаунт</p></div>
    <div id="error-msg" class="alert alert-danger d-none bg-danger bg-opacity-25 border-danger text-white text-center small py-2"></div>
    <form id="loginForm">
        <div class="mb-3">
            <span class="form-label-custom">Имя пользователя</span>
            <input type="text" id="username" class="form-control" placeholder="Username" required>
        </div>
        <div class="mb-4">
            <span class="form-label-custom">Пароль</span>
            <input type="password" id="password" class="form-control" placeholder="••••••••" required>
        </div>
        <button type="submit" class="btn btn-neon w-100 mb-3">Войти</button>
        <div class="text-center"><a href="/register" class="link-light-opacity small">Нет аккаунта? Создать</a></div>
    </form>
</div>
<script>
    document.getElementById('loginForm').addEventListener('submit', async (e) => {
        e.preventDefault();
        const u = document.getElementById('username').value, p = document.getElementById('password').value, err = document.getElementById('error-msg');
        err.classList.add('d-none');
        try {
            const res = await fetch('/api/auth/login', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ username: u, password: p }) });
            if (res.ok) window.location.href = '/'; else { err.textContent = 'Неверный логин или пароль'; err.classList.remove('d-none'); }
        } catch (e) { err.textContent = 'Ошибка сети'; err.classList.remove('d-none'); }
    });
</script>
</body>
</html>


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\main\resources\templates\register.html
================================================================================

<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Регистрация • CyberBank</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        body {
            background-color: #050505;
            background-image: radial-gradient(circle at 50% -20%, #1a1a2e, #000);
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            color: white;
        }
        .orb { position: absolute; border-radius: 50%; filter: blur(80px); z-index: -1; opacity: 0.4; animation: float 10s infinite ease-in-out alternate; }
        .orb-1 { width: 300px; height: 300px; background: #0aff60; top: 10%; right: 20%; }
        .orb-2 { width: 400px; height: 400px; background: #00a8ff; bottom: 10%; left: 20%; animation-delay: -5s; }
        @keyframes float { from { transform: translate(0, 0); } to { transform: translate(30px, 30px); } }

        .register-card {
            width: 100%; max-width: 400px;
            background: rgba(255, 255, 255, 0.03);
            backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 24px; padding: 3rem 2rem;
            box-shadow: 0 25px 50px rgba(0,0,0,0.5);
        }
        .form-control { background: rgba(0, 0, 0, 0.4); border: 1px solid rgba(255, 255, 255, 0.1); color: #fff; padding: 12px 15px; border-radius: 12px; }
        .form-control:focus { background: rgba(0, 0, 0, 0.6); color: #fff; border-color: #0aff60; box-shadow: 0 0 15px rgba(10, 255, 96, 0.2); }
        .form-control::placeholder { color: rgba(255, 255, 255, 0.3); }

        /* Исправленный цвет лейблов */
        .form-label-custom { color: #ccc; font-size: 0.85rem; margin-bottom: 5px; display: block; margin-left: 5px; }

        .btn-neon-green { background: linear-gradient(90deg, #0aff60, #00d2ff); border: none; color: #000; font-weight: 700; padding: 12px; border-radius: 12px; transition: 0.3s; text-transform: uppercase; letter-spacing: 1px; }
        .btn-neon-green:hover { box-shadow: 0 0 30px rgba(10, 255, 96, 0.4); color: #000; transform: scale(1.02); }
        .link-light-opacity { color: rgba(255,255,255,0.5); text-decoration: none; transition: 0.2s; }
        .link-light-opacity:hover { color: #fff; }
    </style>
</head>
<body>
<div class="orb orb-1"></div><div class="orb orb-2"></div>
<div class="register-card">
    <div class="text-center mb-4"><h2 class="fw-bold mb-1">Join Us</h2><p class="text-muted small">Создайте новый аккаунт</p></div>
    <div id="error-msg" class="alert alert-danger d-none bg-danger bg-opacity-25 border-danger text-white text-center small py-2"></div>
    <div id="success-msg" class="alert alert-success d-none bg-success bg-opacity-25 border-success text-white text-center small py-2"></div>
    <form id="registerForm">
        <div class="mb-3">
            <span class="form-label-custom">Username</span>
            <input type="text" id="username" class="form-control" placeholder="Придумайте логин" required>
        </div>
        <div class="mb-3">
            <span class="form-label-custom">Email</span>
            <input type="email" id="email" class="form-control" placeholder="name@example.com" required>
        </div>
        <div class="mb-4">
            <span class="form-label-custom">Пароль</span>
            <input type="password" id="password" class="form-control" placeholder="••••••••" required>
        </div>
        <button type="submit" class="btn btn-neon-green w-100 mb-3">Зарегистрироваться</button>
        <div class="text-center"><a href="/login" class="link-light-opacity small">Уже есть аккаунт? Войти</a></div>
    </form>
</div>
<script>
    document.getElementById('registerForm').addEventListener('submit', async (e) => {
        e.preventDefault();
        const u = document.getElementById('username').value, em = document.getElementById('email').value, p = document.getElementById('password').value, err = document.getElementById('error-msg'), succ = document.getElementById('success-msg');
        err.classList.add('d-none'); succ.classList.add('d-none');
        try {
            const res = await fetch('/api/auth/register', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ username: u, email: em, password: p }) });
            if (res.ok) { succ.textContent = 'Аккаунт создан! Входим...'; succ.classList.remove('d-none'); setTimeout(() => window.location.href = '/', 1500); }
            else { const txt = await res.text(); err.textContent = 'Ошибка: ' + (txt || 'Проверьте данные'); err.classList.remove('d-none'); }
        } catch (e) { err.textContent = 'Ошибка сети'; err.classList.remove('d-none'); }
    });
</script>
</body>
</html>


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\test\java\com\example\bankcards\controller\admin\AdminCardControllerTest.java
================================================================================

package com.example.bankcards.controller.admin;

import com.example.bankcards.exception.card.CardNotFoundException;
import com.example.bankcards.exception.user.UserNotFoundException;
import com.example.bankcards.model.dto.card.CardCreateRequest;
import com.example.bankcards.model.dto.card.CardResponseDto;
import com.example.bankcards.model.dto.card.CardUpdateRequest;
import com.example.bankcards.model.entity.enums.CardStatus;
import com.example.bankcards.security.JwtUtil;
import com.example.bankcards.security.SecurityConfig;
import com.example.bankcards.service.card.CardService;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.context.annotation.Import;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.http.MediaType;
import org.springframework.security.test.context.support.WithMockUser;
import org.springframework.test.context.bean.override.mockito.MockitoBean;
import org.springframework.test.web.servlet.MockMvc;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.Collections;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyLong;
import static org.mockito.BDDMockito.given;
import static org.mockito.Mockito.doNothing;
import static org.mockito.Mockito.doThrow;
import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.csrf;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@Import(SecurityConfig.class)
@WebMvcTest(AdminCardController.class)
class AdminCardControllerTest {

    @MockitoBean
    private JwtUtil jwtUtil;

    @Autowired
    private MockMvc mockMvc;

    @MockitoBean
    private CardService cardService;

    @Autowired
    private ObjectMapper objectMapper;

    private CardResponseDto testCardResponseDto;
    private CardCreateRequest validCardCreateRequest;
    private CardUpdateRequest validCardUpdateRequest;

    @BeforeEach
    void setUp() {
        testCardResponseDto = new CardResponseDto();
        testCardResponseDto.setId(1L);
        testCardResponseDto.setCardNumber("masked-1234");
        testCardResponseDto.setCardHolder("Test User");
        testCardResponseDto.setExpiryDate(LocalDate.of(2025, 12, 31));
        testCardResponseDto.setBalance(BigDecimal.valueOf(1000.00));
        testCardResponseDto.setCardStatus(CardStatus.ACTIVE);
        testCardResponseDto.setUsername("testUsername");

        validCardCreateRequest = new CardCreateRequest();
        validCardCreateRequest.setUserId(1L);
        validCardCreateRequest.setCardNumber("1234567890123456");
        validCardCreateRequest.setCardHolder("New Card Holder");
        validCardCreateRequest.setExpiryDate(LocalDate.of(2026, 1, 1));
        validCardCreateRequest.setBalance(BigDecimal.valueOf(500.00));

        validCardUpdateRequest = new CardUpdateRequest();
        validCardUpdateRequest.setCardHolder("Updated Holder");
        validCardUpdateRequest.setCardStatus(CardStatus.BLOCKED);
    }

    @Test
    @WithMockUser(authorities = "ROLE_ADMIN")
    void createCard_shouldReturnCreated() throws Exception {
        given(cardService.createCard(any(CardCreateRequest.class))).willReturn(testCardResponseDto);

        mockMvc.perform(post("/api/admin/cards")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(validCardCreateRequest)).with(csrf()))
                .andExpect(status().isCreated())
                .andExpect(jsonPath("$.id").value(testCardResponseDto.getId()))
                .andExpect(jsonPath("$.cardNumber").value(testCardResponseDto.getCardNumber()));
    }

    @Test
    @WithMockUser(authorities = "ROLE_ADMIN")
    void createCard_withInvalidData_shouldReturnBadRequest() throws Exception {
        // Missing card number
        CardCreateRequest invalidRequest = new CardCreateRequest();
        invalidRequest.setUserId(1L);
        invalidRequest.setCardHolder("Invalid User");
        invalidRequest.setExpiryDate(LocalDate.of(2026, 1, 1));
        invalidRequest.setBalance(BigDecimal.valueOf(100.00));

        mockMvc.perform(post("/api/admin/cards")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(invalidRequest)).with(csrf()))
                .andExpect(status().isBadRequest());
    }

    @Test
    @WithMockUser(authorities = "ROLE_ADMIN")
    void createCard_whenUserNotFound_shouldReturnNotFound() throws Exception {
        given(cardService.createCard(any(CardCreateRequest.class)))
                .willThrow(new UserNotFoundException("User not found"));

        mockMvc.perform(post("/api/admin/cards")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(validCardCreateRequest)).with(csrf()))
                .andExpect(status().isNotFound());
    }

    @Test
    @WithMockUser(authorities = "ROLE_ADMIN")
    void getAllCards_shouldReturnOkAndPageOfCards() throws Exception {
        Pageable pageable = PageRequest.of(0, 10);
        Page<CardResponseDto> cardPage = new PageImpl<>(Collections.singletonList(testCardResponseDto), pageable, 1);
        given(cardService.getAllCards(any(Pageable.class))).willReturn(cardPage);

        mockMvc.perform(get("/api/admin/cards")
                        .param("page", "0")
                        .param("size", "10")
                        .contentType(MediaType.APPLICATION_JSON).with(csrf()))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.content[0].id").value(testCardResponseDto.getId()));
    }

    @Test
    @WithMockUser(authorities = "ROLE_ADMIN")
    void getCardById_shouldReturnOkAndCard() throws Exception {
        given(cardService.getCardById(anyLong())).willReturn(testCardResponseDto);

        mockMvc.perform(get("/api/admin/cards/{id}", 1L)
                        .contentType(MediaType.APPLICATION_JSON).with(csrf()))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.id").value(testCardResponseDto.getId()));
    }

    @Test
    @WithMockUser(authorities = "ROLE_ADMIN")
    void getCardById_whenCardNotFound_shouldReturnNotFound() throws Exception {
        given(cardService.getCardById(anyLong())).willThrow(new CardNotFoundException("Card not found"));

        mockMvc.perform(get("/api/admin/cards/{id}", 99L)
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isNotFound());
    }

    @Test
    @WithMockUser(authorities = "ROLE_ADMIN")
    void updateCard_shouldReturnOkAndUpdatedCard() throws Exception {
        CardResponseDto updatedDto = new CardResponseDto();
        updatedDto.setId(1L);
        updatedDto.setCardHolder(validCardUpdateRequest.getCardHolder());
        updatedDto.setCardStatus(validCardUpdateRequest.getCardStatus());
        given(cardService.updateCard(anyLong(), any(CardUpdateRequest.class))).willReturn(updatedDto);

        mockMvc.perform(put("/api/admin/cards/{id}", 1L)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(validCardUpdateRequest)).with(csrf()))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.cardHolder").value(updatedDto.getCardHolder()));
    }

    @Test
    @WithMockUser(authorities = "ROLE_ADMIN")
    void updateCard_whenCardNotFound_shouldReturnNotFound() throws Exception {
        given(cardService.updateCard(anyLong(), any(CardUpdateRequest.class)))
                .willThrow(new CardNotFoundException("Card not found"));

        mockMvc.perform(put("/api/admin/cards/{id}", 99L)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(validCardUpdateRequest)).with(csrf()))
                .andExpect(status().isNotFound());
    }

    @Test
    @WithMockUser(authorities = "ROLE_ADMIN")
    void deleteCard_shouldReturnNoContent() throws Exception {
        doNothing().when(cardService).deleteCard(anyLong());

        mockMvc.perform(delete("/api/admin/cards/{id}", 1L).with(csrf()))
                .andExpect(status().isNoContent());
    }

    @Test
    @WithMockUser(authorities = "ROLE_ADMIN")
    void deleteCard_whenCardNotFound_shouldReturnNotFound() throws Exception {
        doThrow(new CardNotFoundException("Card not found")).when(cardService).deleteCard(anyLong());

        mockMvc.perform(delete("/api/admin/cards/{id}", 99L).with(csrf()))
                .andExpect(status().isNotFound());
    }

    @Test
    @WithMockUser(authorities = "ROLE_ADMIN")
    void blockCard_shouldReturnOkAndBlockedCard() throws Exception {
        CardResponseDto blockedDto = new CardResponseDto();
        blockedDto.setId(1L);
        blockedDto.setCardStatus(CardStatus.BLOCKED);
        given(cardService.blockCard(anyLong())).willReturn(blockedDto);

        mockMvc.perform(post("/api/admin/cards/{id}/block", 1L).with(csrf()))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.cardStatus").value(CardStatus.BLOCKED.name()));
    }

    @Test
    @WithMockUser(authorities = "ROLE_ADMIN")
    void blockCard_whenCardNotFound_shouldReturnNotFound() throws Exception {
        given(cardService.blockCard(anyLong())).willThrow(new CardNotFoundException("Card not found"));

        mockMvc.perform(post("/api/admin/cards/{id}/block", 99L).with(csrf()))
                .andExpect(status().isNotFound());
    }

    @Test
    @WithMockUser(authorities = "ROLE_ADMIN")
    void activateCard_shouldReturnOkAndActivatedCard() throws Exception {
        CardResponseDto activatedDto = new CardResponseDto();
        activatedDto.setId(1L);
        activatedDto.setCardStatus(CardStatus.ACTIVE);
        given(cardService.activateCard(anyLong())).willReturn(activatedDto);

        mockMvc.perform(post("/api/admin/cards/{id}/activate", 1L).with(csrf()))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.cardStatus").value(CardStatus.ACTIVE.name()));
    }

    @Test
    @WithMockUser(authorities = "ROLE_ADMIN")
    void activateCard_whenCardNotFound_shouldReturnNotFound() throws Exception {
        given(cardService.activateCard(anyLong())).willThrow(new CardNotFoundException("Card not found"));

        mockMvc.perform(post("/api/admin/cards/{id}/activate", 99L).with(csrf()))
                .andExpect(status().isNotFound());
    }

    @Test
    @WithMockUser(authorities = "ROLE_USER")
    void createCard_asUser_shouldReturnForbidden() throws Exception {
        mockMvc.perform(post("/api/admin/cards")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(validCardCreateRequest)).with(csrf()))
                .andExpect(status().isForbidden());
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\test\java\com\example\bankcards\controller\admin\AdminUserControllerTest.java
================================================================================

package com.example.bankcards.controller.admin;

import com.example.bankcards.exception.user.UserNotFoundException;
import com.example.bankcards.model.dto.user.UserResponseDto;
import com.example.bankcards.model.dto.user.UserUpdateRequest;
import com.example.bankcards.model.entity.enums.Role;
import com.example.bankcards.security.JwtUtil;
import com.example.bankcards.security.SecurityConfig;
import com.example.bankcards.service.admin.AdminUserService;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.context.annotation.Import;
import org.springframework.http.MediaType;
import org.springframework.security.test.context.support.WithMockUser;
import org.springframework.test.context.bean.override.mockito.MockitoBean;
import org.springframework.test.web.servlet.MockMvc;

import java.util.Collections;
import java.util.List;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyLong;
import static org.mockito.BDDMockito.given;
import static org.mockito.Mockito.doNothing;
import static org.mockito.Mockito.doThrow;
import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.csrf;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@Import(SecurityConfig.class)
@WebMvcTest(AdminUserController.class)
class AdminUserControllerTest {


    @MockitoBean
    private JwtUtil jwtUtil;

    @Autowired
    private MockMvc mockMvc;

    @MockitoBean
    private AdminUserService adminUserService;

    @Autowired
    private ObjectMapper objectMapper;

    private UserResponseDto testUserResponseDto;
    private UserUpdateRequest validUserUpdateRequest;

    @BeforeEach
    void setUp() {
        testUserResponseDto = new UserResponseDto();
        testUserResponseDto.setId(1L);
        testUserResponseDto.setUsername("testuser");
        testUserResponseDto.setEmail("test@example.com");
        testUserResponseDto.setRole(Role.ROLE_USER);

        validUserUpdateRequest = new UserUpdateRequest("updatedUser", "updated@example.com", Role.ROLE_ADMIN);
    }

    @Test
    @WithMockUser(roles = "ADMIN")
    void getAllUsers_shouldReturnOkAndListOfUsers() throws Exception {
        List<UserResponseDto> users = Collections.singletonList(testUserResponseDto);
        given(adminUserService.getAllUsers()).willReturn(users);

        mockMvc.perform(get("/api/admin/users")
                        .contentType(MediaType.APPLICATION_JSON)
                        .with(csrf()))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$[0].username").value(testUserResponseDto.getUsername()));
    }

    @Test
    @WithMockUser(roles = "ADMIN")
    void getUserById_shouldReturnOkAndUser() throws Exception {
        given(adminUserService.getUserById(anyLong())).willReturn(testUserResponseDto);

        mockMvc.perform(get("/api/admin/users/{id}", 1L)
                        .contentType(MediaType.APPLICATION_JSON)
                        .with(csrf()))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.id").value(testUserResponseDto.getId()));
    }

    @Test
    @WithMockUser(roles = "ADMIN")
    void getUserById_whenUserNotFound_shouldReturnNotFound() throws Exception {
        given(adminUserService.getUserById(anyLong())).willThrow(new UserNotFoundException("User not found"));

        mockMvc.perform(get("/api/admin/users/{id}", 99L)
                        .contentType(MediaType.APPLICATION_JSON)
                        .with(csrf()))
                .andExpect(status().isNotFound());
    }

    @Test
    @WithMockUser(roles = "ADMIN")
    void updateUser_shouldReturnOkAndUpdatedUser() throws Exception {
        UserResponseDto updatedDto = new UserResponseDto();
        updatedDto.setId(1L);
        updatedDto.setUsername(validUserUpdateRequest.getUsername());
        updatedDto.setEmail(validUserUpdateRequest.getEmail());
        updatedDto.setRole(validUserUpdateRequest.getRole());

        given(adminUserService.updateUser(anyLong(), any(UserUpdateRequest.class))).willReturn(updatedDto);

        mockMvc.perform(put("/api/admin/users/{id}", 1L)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(validUserUpdateRequest))
                        .with(csrf()))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.username").value(updatedDto.getUsername()))
                .andExpect(jsonPath("$.email").value(updatedDto.getEmail()))
                .andExpect(jsonPath("$.role").value(updatedDto.getRole().name()));
    }

    @Test
    @WithMockUser(roles = "ADMIN")
    void updateUser_withInvalidData_shouldReturnBadRequest() throws Exception {
        UserUpdateRequest invalidRequest = new UserUpdateRequest("", "invalid-email", null); // Invalid data
        mockMvc.perform(put("/api/admin/users/{id}", 1L)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(invalidRequest))
                        .with(csrf()))
                .andExpect(status().isBadRequest());
    }

    @Test
    @WithMockUser(roles = "ADMIN")
    void updateUser_whenUserNotFound_shouldReturnNotFound() throws Exception {
        given(adminUserService.updateUser(anyLong(), any(UserUpdateRequest.class)))
                .willThrow(new UserNotFoundException("User not found"));

        mockMvc.perform(put("/api/admin/users/{id}", 99L)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(validUserUpdateRequest))
                        .with(csrf()))
                .andExpect(status().isNotFound());
    }

    @Test
    @WithMockUser(roles = "ADMIN")
    void deleteUser_shouldReturnNoContent() throws Exception {
        doNothing().when(adminUserService).deleteUser(anyLong());

        mockMvc.perform(delete("/api/admin/users/{id}", 1L)
                        .with(csrf()))
                .andExpect(status().isNoContent());
    }

    @Test
    @WithMockUser(roles = "ADMIN")
    void deleteUser_whenUserNotFound_shouldReturnNotFound() throws Exception {
        doThrow(new UserNotFoundException("User not found")).when(adminUserService).deleteUser(anyLong());

        mockMvc.perform(delete("/api/admin/users/{id}", 99L)
                        .with(csrf()))
                .andExpect(status().isNotFound());
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\test\java\com\example\bankcards\controller\auth\AuthControllerTest.java
================================================================================

package com.example.bankcards.controller.auth;

import com.example.bankcards.exception.user.AuthenticationFailedException;
import com.example.bankcards.model.dto.auth.AuthResponseDto;
import com.example.bankcards.model.dto.auth.LoginRequest;
import com.example.bankcards.model.dto.auth.RefreshRequest;
import com.example.bankcards.model.dto.auth.RegisterRequest;
import com.example.bankcards.model.entity.User;
import com.example.bankcards.repository.UserRepository;
import com.example.bankcards.service.auth.AuthService;
import com.example.bankcards.security.JwtUtil;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.http.MediaType;
import org.springframework.test.context.bean.override.mockito.MockitoBean;
import org.springframework.test.web.servlet.MockMvc;

import java.util.Optional;

import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.BDDMockito.given;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@WebMvcTest(AuthController.class)
@AutoConfigureMockMvc(addFilters = false)
class AuthControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private ObjectMapper objectMapper;

    @MockitoBean
    private AuthService authService;

    @MockitoBean
    private UserRepository userRepository;

    @MockitoBean
    private JwtUtil jwtUtil;

    @Test
    void login_withValidCredentials_shouldReturnTokens() throws Exception {
        LoginRequest loginRequest = new LoginRequest();
        loginRequest.setUsername("testuser");
        loginRequest.setPassword("password");

        AuthResponseDto authResponse = new AuthResponseDto("access-token", "refresh-token");
        given(authService.login("testuser", "password")).willReturn(authResponse);

        mockMvc.perform(post("/api/auth/login")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(loginRequest)))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.accessToken").value("access-token"))
                .andExpect(jsonPath("$.refreshToken").value("refresh-token"));
    }

    @Test
    void login_withInvalidCredentials_shouldReturnUnauthorized() throws Exception {
        LoginRequest loginRequest = new LoginRequest();
        loginRequest.setUsername("testuser");
        loginRequest.setPassword("wrongpassword");

        given(authService.login(anyString(), anyString())).willThrow(new AuthenticationFailedException("Invalid username or password"));

        mockMvc.perform(post("/api/auth/login")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(loginRequest)))
                .andExpect(status().isUnauthorized());
    }

    @Test
    void register_withValidData_shouldReturnCreatedAndTokens() throws Exception {
        RegisterRequest registerRequest = new RegisterRequest();
        registerRequest.setUsername("testuser");
        registerRequest.setEmail("new@example.com");
        registerRequest.setPassword("password");

        AuthResponseDto authResponse = new AuthResponseDto("access-token", "refresh-token");

        given(authService.register(anyString(), anyString(), anyString())).willReturn(authResponse);

        given(userRepository.findByUsername("newuser")).willReturn(Optional.of(new User()));

        mockMvc.perform(post("/api/auth/register")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(registerRequest)))
                .andExpect(status().isCreated())
                .andExpect(jsonPath("$.accessToken").value("access-token"))
                .andExpect(jsonPath("$.refreshToken").value("refresh-token"));
    }

    @Test
    void register_withInvalidData_shouldReturnBadRequest() throws Exception {
        RegisterRequest registerRequest = new RegisterRequest();
        registerRequest.setUsername("testuser");
        registerRequest.setPassword("password");

        mockMvc.perform(post("/api/auth/register")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(registerRequest)))
                .andExpect(status().isBadRequest());
    }

    @Test
    void refreshToken_withValidToken_shouldReturnOkAndTokens() throws Exception {
        RefreshRequest refreshRequest = new RefreshRequest();
        refreshRequest.setRefreshToken("valid-refresh-token");

        AuthResponseDto expectedResponse = new AuthResponseDto("new-access-token", "new-refresh-token");

        given(authService.refreshAccessToken(anyString())).willReturn(expectedResponse);

        mockMvc.perform(post("/api/auth/refresh-token")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(refreshRequest)))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.accessToken").value("new-access-token"))
                .andExpect(jsonPath("$.refreshToken").value("new-refresh-token"));
    }

    @Test
    void refreshToken_withMissingToken_shouldReturnBadRequest() throws Exception {
        RefreshRequest refreshRequest = new RefreshRequest();
        refreshRequest.setRefreshToken(null);

        mockMvc.perform(post("/api/auth/refresh-token")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(refreshRequest)))
                .andExpect(status().isBadRequest());
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\test\java\com\example\bankcards\controller\user\TransferControllerTest.java
================================================================================

package com.example.bankcards.controller.user;

import com.example.bankcards.exception.card.CardNotFoundException;
import com.example.bankcards.exception.dto.ForbiddenException;
import com.example.bankcards.exception.card.InsufficientFundsException; // Assuming this exception
import com.example.bankcards.exception.transfer.TransferNotFoundException; // Assuming this exception
import com.example.bankcards.model.dto.transfer.TransferRequest;
import com.example.bankcards.model.dto.transfer.TransferResponseDto;
import com.example.bankcards.security.JwtUtil;
import com.example.bankcards.security.SecurityConfig;
import com.example.bankcards.service.transfer.TransferService;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.context.annotation.Import;
import org.springframework.http.MediaType;
import org.springframework.security.test.context.support.WithMockUser;
import org.springframework.test.context.bean.override.mockito.MockitoBean;
import org.springframework.test.web.servlet.MockMvc;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.Collections;
import java.util.List;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyLong;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.BDDMockito.given;
import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.csrf;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@Import(SecurityConfig.class)
@WebMvcTest(TransferController.class)
class TransferControllerTest {

    @MockitoBean
    private JwtUtil jwtUtil;

    @Autowired
    private MockMvc mockMvc;

    @MockitoBean
    private TransferService transferService;

    @Autowired
    private ObjectMapper objectMapper;

    private TransferRequest validTransferRequest;
    private TransferResponseDto testTransferResponseDto;
    private final String TEST_USERNAME = "testuser";

    @BeforeEach
    void setUp() {
        validTransferRequest = new TransferRequest();
        validTransferRequest.setFromCardId(1L);
        validTransferRequest.setToCardNumber("1234567890987654");
        validTransferRequest.setAmount(BigDecimal.valueOf(100.00));

        testTransferResponseDto = new TransferResponseDto();
        testTransferResponseDto.setId(1L);
        testTransferResponseDto.setFromCardNumber("123");
        testTransferResponseDto.setToCardNumber("masked-7654");
        testTransferResponseDto.setAmount(BigDecimal.valueOf(100.00));
        testTransferResponseDto.setTransferDate(LocalDateTime.now());
    }

    @Test
    @WithMockUser(username = TEST_USERNAME, authorities = "ROLE_USER")
    void createTransfer_shouldReturnCreated() throws Exception {
        given(transferService.createTransfer(any(TransferRequest.class), eq(TEST_USERNAME)))
                .willReturn(testTransferResponseDto);

        mockMvc.perform(post("/api/user/transfers")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(validTransferRequest)).with(csrf()))
                .andExpect(status().isCreated())
                .andExpect(jsonPath("$.id").value(testTransferResponseDto.getId()))
                .andExpect(jsonPath("$.amount").value(testTransferResponseDto.getAmount()));
    }

    @Test
    @WithMockUser(username = TEST_USERNAME, authorities = "ROLE_USER")
    void createTransfer_withInvalidData_shouldReturnBadRequest() throws Exception {
        TransferRequest invalidRequest = new TransferRequest(); // Missing required fields
        invalidRequest.setFromCardId(1L);
        invalidRequest.setAmount(BigDecimal.valueOf(-10.00)); // Invalid amount

        mockMvc.perform(post("/api/user/transfers")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(invalidRequest)).with(csrf()))
                .andExpect(status().isBadRequest());
    }

    @Test
    @WithMockUser(username = TEST_USERNAME, authorities = "ROLE_USER")
    void createTransfer_whenCardNotFound_shouldReturnNotFound() throws Exception {
        given(transferService.createTransfer(any(TransferRequest.class), eq(TEST_USERNAME)))
                .willThrow(new CardNotFoundException("Card not found"));

        mockMvc.perform(post("/api/user/transfers")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(validTransferRequest)).with(csrf()))
                .andExpect(status().isNotFound());
    }

    @Test
    @WithMockUser(username = TEST_USERNAME, authorities = "ROLE_USER")
    void createTransfer_whenForbidden_shouldReturnForbidden() throws Exception {
        given(transferService.createTransfer(any(TransferRequest.class), eq(TEST_USERNAME)))
                .willThrow(new ForbiddenException("Access denied"));

        mockMvc.perform(post("/api/user/transfers")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(validTransferRequest)).with(csrf()))
                .andExpect(status().isForbidden());
    }

    @Test
    @WithMockUser(username = TEST_USERNAME, authorities = "ROLE_USER")
    void createTransfer_whenInsufficientFunds_shouldReturnBadRequest() throws Exception {
        given(transferService.createTransfer(any(TransferRequest.class), eq(TEST_USERNAME)))
                .willThrow(new InsufficientFundsException("Insufficient funds"));

        mockMvc.perform(post("/api/user/transfers")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(validTransferRequest)).with(csrf()))
                .andExpect(status().isBadRequest());
    }

    @Test
    @WithMockUser(username = TEST_USERNAME, authorities = "ROLE_USER")
    void getMyTransfers_shouldReturnOkAndListOfTransfers() throws Exception {
        List<TransferResponseDto> transfers = Collections.singletonList(testTransferResponseDto);
        given(transferService.getUserTransfers(eq(TEST_USERNAME))).willReturn(transfers);

        mockMvc.perform(get("/api/user/transfers/my")
                        .contentType(MediaType.APPLICATION_JSON).with(csrf()))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$[0].id").value(testTransferResponseDto.getId()));
    }

    @Test
    @WithMockUser(username = TEST_USERNAME, authorities = "ROLE_USER")
    void getCardTransfers_shouldReturnOkAndListOfTransfers() throws Exception {
        List<TransferResponseDto> transfers = Collections.singletonList(testTransferResponseDto);
        given(transferService.getCardTransfers(anyLong(), eq(TEST_USERNAME))).willReturn(transfers);

        mockMvc.perform(get("/api/user/transfers/card/{cardId}", 1L)
                        .contentType(MediaType.APPLICATION_JSON).with(csrf()))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$[0].id").value(testTransferResponseDto.getId()));
    }

    @Test
    @WithMockUser(username = TEST_USERNAME, authorities = "ROLE_USER")
    void getCardTransfers_whenCardNotFound_shouldReturnNotFound() throws Exception {
        given(transferService.getCardTransfers(anyLong(), eq(TEST_USERNAME)))
                .willThrow(new CardNotFoundException("Card not found"));

        mockMvc.perform(get("/api/user/transfers/card/{cardId}", 99L)
                        .contentType(MediaType.APPLICATION_JSON).with(csrf()))
                .andExpect(status().isNotFound());
    }

    @Test
    @WithMockUser(username = TEST_USERNAME, authorities = "ROLE_USER")
    void getCardTransfers_whenForbidden_shouldReturnForbidden() throws Exception {
        given(transferService.getCardTransfers(anyLong(), eq(TEST_USERNAME)))
                .willThrow(new ForbiddenException("Access denied"));

        mockMvc.perform(get("/api/user/transfers/card/{cardId}", 1L)
                        .contentType(MediaType.APPLICATION_JSON).with(csrf()))
                .andExpect(status().isForbidden());
    }

    @Test
    @WithMockUser(username = TEST_USERNAME, authorities = "ROLE_USER")
    void getTransfer_shouldReturnOkAndTransfer() throws Exception {
        given(transferService.getTransfer(anyLong(), eq(TEST_USERNAME))).willReturn(testTransferResponseDto);

        mockMvc.perform(get("/api/user/transfers/{transferId}", 1L)
                        .contentType(MediaType.APPLICATION_JSON).with(csrf()))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.id").value(testTransferResponseDto.getId()));
    }

    @Test
    @WithMockUser(username = TEST_USERNAME, authorities = "ROLE_USER")
    void getTransfer_whenTransferNotFound_shouldReturnNotFound() throws Exception {
        given(transferService.getTransfer(anyLong(), eq(TEST_USERNAME)))
                .willThrow(new TransferNotFoundException("Transfer not found"));

        mockMvc.perform(get("/api/user/transfers/{transferId}", 99L)
                        .contentType(MediaType.APPLICATION_JSON).with(csrf()))
                .andExpect(status().isNotFound());
    }

    @Test
    @WithMockUser(username = TEST_USERNAME, authorities = "ROLE_USER")
    void getTransfer_whenForbidden_shouldReturnForbidden() throws Exception {
        given(transferService.getTransfer(anyLong(), eq(TEST_USERNAME)))
                .willThrow(new ForbiddenException("Access denied"));

        mockMvc.perform(get("/api/user/transfers/{transferId}", 1L)
                        .contentType(MediaType.APPLICATION_JSON).with(csrf()))
                .andExpect(status().isForbidden());
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\test\java\com\example\bankcards\controller\user\UserCardControllerTest.java
================================================================================

package com.example.bankcards.controller.user;

import com.example.bankcards.exception.card.CardStatusException;
import com.example.bankcards.exception.card.CardNotFoundException;
import com.example.bankcards.exception.dto.ForbiddenException;
import com.example.bankcards.model.dto.card.CardResponseDto;
import com.example.bankcards.model.entity.enums.CardStatus;
import com.example.bankcards.security.JwtUtil;
import com.example.bankcards.security.SecurityConfig;
import com.example.bankcards.service.card.UserCardService;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.context.annotation.Import;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.http.MediaType;
import org.springframework.security.test.context.support.WithMockUser;
import org.springframework.test.context.bean.override.mockito.MockitoBean;
import org.springframework.test.web.servlet.MockMvc;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.Collections;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyLong;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.BDDMockito.given;
import static org.mockito.Mockito.doNothing;
import static org.mockito.Mockito.doThrow;
import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.csrf;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@Import(SecurityConfig.class)
@WebMvcTest(UserCardController.class)
class UserCardControllerTest {

    @MockitoBean
    private JwtUtil jwtUtil;

    @Autowired
    private MockMvc mockMvc;

    @MockitoBean
    private UserCardService userCardService;

    @Autowired
    private ObjectMapper objectMapper;

    private CardResponseDto testCardResponseDto;
    private final String TEST_USERNAME = "testuser";

    @BeforeEach
    void setUp() {
        testCardResponseDto = new CardResponseDto();
        testCardResponseDto.setId(1L);
        testCardResponseDto.setCardNumber("masked-1234");
        testCardResponseDto.setCardHolder("Test User");
        testCardResponseDto.setExpiryDate(LocalDate.of(2025, 12, 31));
        testCardResponseDto.setBalance(BigDecimal.valueOf(1000.00));
        testCardResponseDto.setCardStatus(CardStatus.ACTIVE);
        testCardResponseDto.setUsername(TEST_USERNAME);
    }

    @Test
    @WithMockUser(username = TEST_USERNAME, authorities = "ROLE_USER")
    void getUserCards_shouldReturnOkAndPageOfCards() throws Exception {
        Pageable pageable = PageRequest.of(0, 10);
        Page<CardResponseDto> cardPage = new PageImpl<>(Collections.singletonList(testCardResponseDto), pageable, 1);
        given(userCardService.getUserCards(eq(TEST_USERNAME), any(Pageable.class))).willReturn(cardPage);

        mockMvc.perform(get("/api/user/cards")
                        .param("page", "0")
                        .param("size", "10")
                        .contentType(MediaType.APPLICATION_JSON).with(csrf()))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.content[0].id").value(testCardResponseDto.getId()));
    }

    @Test
    @WithMockUser(username = TEST_USERNAME, authorities = "ROLE_USER")
    void getCardById_shouldReturnOkAndCard() throws Exception {
        given(userCardService.getUserCardById(anyLong(), eq(TEST_USERNAME))).willReturn(testCardResponseDto);

        mockMvc.perform(get("/api/user/cards/{cardId}", 1L)
                        .contentType(MediaType.APPLICATION_JSON).with(csrf()))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.id").value(testCardResponseDto.getId()));
    }

    @Test
    @WithMockUser(username = TEST_USERNAME, authorities = "ROLE_USER")
    void getCardById_whenCardNotFound_shouldReturnNotFound() throws Exception {
        given(userCardService.getUserCardById(anyLong(), eq(TEST_USERNAME)))
                .willThrow(new CardNotFoundException("Card not found"));

        mockMvc.perform(get("/api/user/cards/{cardId}", 99L)
                        .contentType(MediaType.APPLICATION_JSON).with(csrf()))
                .andExpect(status().isNotFound());
    }

    @Test
    @WithMockUser(username = TEST_USERNAME, authorities = "ROLE_USER")
    void getCardById_whenForbidden_shouldReturnForbidden() throws Exception {
        given(userCardService.getUserCardById(anyLong(), eq(TEST_USERNAME)))
                .willThrow(new ForbiddenException("Access denied"));

        mockMvc.perform(get("/api/user/cards/{cardId}", 1L)
                        .contentType(MediaType.APPLICATION_JSON).with(csrf()))
                .andExpect(status().isForbidden());
    }

    @Test
    @WithMockUser(username = TEST_USERNAME, authorities = "ROLE_USER")
    void requestBlockCard_shouldReturnOk() throws Exception {
        doNothing().when(userCardService).requestBlock(anyLong(), eq(TEST_USERNAME));

        mockMvc.perform(post("/api/user/cards/block/{cardId}", 1L).with(csrf()))
                .andExpect(status().isOk());
    }

    @Test
    @WithMockUser(username = TEST_USERNAME, authorities = "ROLE_USER")
    void requestBlockCard_whenCardNotFound_shouldReturnNotFound() throws Exception {
        doThrow(new CardNotFoundException("Card not found")).when(userCardService).requestBlock(anyLong(), eq(TEST_USERNAME));

        mockMvc.perform(post("/api/user/cards/block/{cardId}", 99L).with(csrf()))
                .andExpect(status().isNotFound());
    }

    @Test
    @WithMockUser(username = TEST_USERNAME, authorities = "ROLE_USER")
    void requestBlockCard_whenForbidden_shouldReturnForbidden() throws Exception {
        doThrow(new ForbiddenException("Access denied")).when(userCardService).requestBlock(anyLong(), eq(TEST_USERNAME));

        mockMvc.perform(post("/api/user/cards/block/{cardId}", 1L).with(csrf()))
                .andExpect(status().isForbidden());
    }

    @Test
    @WithMockUser(username = TEST_USERNAME, authorities = "ROLE_USER")
    void requestBlockCard_whenCardAlreadyBlocked_shouldReturnBadRequest() throws Exception {
        doThrow(new CardStatusException("Card is already blocked")).when(userCardService).requestBlock(anyLong(), eq(TEST_USERNAME));

        mockMvc.perform(post("/api/user/cards/block/{cardId}", 1L).with(csrf()))
                .andExpect(status().isBadRequest());
    }

    @Test
    @WithMockUser(username = TEST_USERNAME, authorities = "ROLE_USER")
    void requestUnblockCard_shouldReturnOk() throws Exception {
        doNothing().when(userCardService).requestUnblock(anyLong(), eq(TEST_USERNAME));

        mockMvc.perform(post("/api/user/cards/unblock/{cardId}", 1L).with(csrf()))
                .andExpect(status().isOk());
    }

    @Test
    @WithMockUser(username = TEST_USERNAME, authorities = "ROLE_USER")
    void requestUnblockCard_whenCardNotFound_shouldReturnNotFound() throws Exception {
        doThrow(new CardNotFoundException("Card not found")).when(userCardService).requestUnblock(anyLong(), eq(TEST_USERNAME));

        mockMvc.perform(post("/api/user/cards/unblock/{cardId}", 99L).with(csrf()))
                .andExpect(status().isNotFound());
    }

    @Test
    @WithMockUser(username = TEST_USERNAME, authorities = "ROLE_USER")
    void requestUnblockCard_whenForbidden_shouldReturnForbidden() throws Exception {
        doThrow(new ForbiddenException("Access denied")).when(userCardService).requestUnblock(anyLong(), eq(TEST_USERNAME));

        mockMvc.perform(post("/api/user/cards/unblock/{cardId}", 1L).with(csrf()))
                .andExpect(status().isForbidden());
    }

    @Test
    @WithMockUser(username = TEST_USERNAME, authorities = "ROLE_USER")
    void requestUnblockCard_whenCardNotBlocked_shouldReturnBadRequest() throws Exception {
        doThrow(new CardStatusException("Card is not blocked")).when(userCardService).requestUnblock(anyLong(), eq(TEST_USERNAME));

        mockMvc.perform(post("/api/user/cards/unblock/{cardId}", 1L).with(csrf()))
                .andExpect(status().isBadRequest());
    }

    @Test
    @WithMockUser(username = TEST_USERNAME, authorities = "ROLE_USER")
    void getBalance_shouldReturnOkAndBalance() throws Exception {
        BigDecimal totalBalance = BigDecimal.valueOf(2500.00);
        given(userCardService.getTotalBalance(eq(TEST_USERNAME))).willReturn(totalBalance);

        mockMvc.perform(get("/api/user/cards/balance")
                        .contentType(MediaType.APPLICATION_JSON).with(csrf()))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$").value(totalBalance));
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\test\java\com\example\bankcards\service\admin\AdminUserServiceTest.java
================================================================================

package com.example.bankcards.service.admin;

import com.example.bankcards.exception.user.UserNotFoundException;
import com.example.bankcards.model.dto.user.UserResponseDto;
import com.example.bankcards.model.dto.user.UserUpdateRequest;
import com.example.bankcards.model.entity.User;
import com.example.bankcards.model.entity.enums.Role;
import com.example.bankcards.repository.UserRepository;
import com.example.bankcards.util.mapper.UserMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.Collections;
import java.util.List;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class AdminUserServiceTest {

    @Mock
    private UserRepository userRepository;

    @Mock
    private UserMapper userMapper;

    @InjectMocks
    private AdminUserService adminUserService;

    private User testUser;
    private UserResponseDto testUserResponseDto;

    @BeforeEach
    void setUp() {
        testUser = new User("testuser", "test@example.com", "password", Role.ROLE_USER);
        testUser.setId(1L);

        testUserResponseDto = new UserResponseDto();
        testUserResponseDto.setId(1L);
        testUserResponseDto.setUsername("testuser");
        testUserResponseDto.setEmail("test@example.com");
        testUserResponseDto.setRole(Role.ROLE_USER);
    }

    @Test
    void getAllUsers_shouldReturnUserList() {
        when(userRepository.findAll()).thenReturn(Collections.singletonList(testUser));
        when(userMapper.toUserResponseDto(testUser)).thenReturn(testUserResponseDto);

        List<UserResponseDto> result = adminUserService.getAllUsers();

        assertFalse(result.isEmpty());
        assertEquals(1, result.size());
        assertEquals("testuser", result.get(0).getUsername());
        verify(userRepository).findAll();
        verify(userMapper).toUserResponseDto(testUser);
    }

    @Test
    void getUserById_whenUserExists_shouldReturnUser() {
        when(userRepository.findById(1L)).thenReturn(Optional.of(testUser));
        when(userMapper.toUserResponseDto(testUser)).thenReturn(testUserResponseDto);

        UserResponseDto result = adminUserService.getUserById(1L);

        assertNotNull(result);
        assertEquals(1L, result.getId());
        verify(userRepository).findById(1L);
        verify(userMapper).toUserResponseDto(testUser);
    }

    @Test
    void getUserById_whenUserDoesNotExist_shouldThrowUserNotFoundException() {
        when(userRepository.findById(99L)).thenReturn(Optional.empty());

        assertThrows(UserNotFoundException.class, () -> {
            adminUserService.getUserById(99L);
        });
        verify(userRepository).findById(99L);
        verifyNoInteractions(userMapper);
    }

    @Test
    void updateUser_whenUserExists_shouldUpdateAndReturnUser() {
        UserUpdateRequest updateRequest = new UserUpdateRequest("updatedUser", "updated@example.com", Role.ROLE_ADMIN);
        User updatedTestUser = new User("updatedUser", "updated@example.com", "password", Role.ROLE_ADMIN);
        updatedTestUser.setId(1L);
        UserResponseDto updatedUserResponseDto = new UserResponseDto();
        updatedUserResponseDto.setId(1L);
        updatedUserResponseDto.setUsername("updatedUser");
        updatedUserResponseDto.setEmail("updated@example.com");
        updatedUserResponseDto.setRole(Role.ROLE_ADMIN);

        when(userRepository.findById(1L)).thenReturn(Optional.of(testUser));
        when(userRepository.save(any(User.class))).thenReturn(updatedTestUser);
        when(userMapper.toUserResponseDto(updatedTestUser)).thenReturn(updatedUserResponseDto);

        UserResponseDto result = adminUserService.updateUser(1L, updateRequest);

        assertNotNull(result);
        assertEquals("updatedUser", result.getUsername());
        assertEquals("updated@example.com", result.getEmail());
        assertEquals(Role.ROLE_ADMIN, result.getRole());

        assertEquals("updatedUser", testUser.getUsername());
        assertEquals("updated@example.com", testUser.getEmail());
        assertEquals(Role.ROLE_ADMIN, testUser.getRole());

        verify(userRepository).findById(1L);
        verify(userRepository).save(testUser);
        verify(userMapper).toUserResponseDto(updatedTestUser);
    }

    @Test
    void updateUser_whenUserDoesNotExist_shouldThrowUserNotFoundException() {
        UserUpdateRequest updateRequest = new UserUpdateRequest();
        when(userRepository.findById(99L)).thenReturn(Optional.empty());

        assertThrows(UserNotFoundException.class, () -> {
            adminUserService.updateUser(99L, updateRequest);
        });
        verify(userRepository).findById(99L);
        verifyNoInteractions(userMapper);
        verify(userRepository, never()).save(any(User.class));
    }

    @Test
    void deleteUser_whenUserExists_shouldCallDeleteById() {
        when(userRepository.existsById(1L)).thenReturn(true);
        doNothing().when(userRepository).deleteById(1L);

        adminUserService.deleteUser(1L);

        verify(userRepository).existsById(1L);
        verify(userRepository).deleteById(1L);
    }

    @Test
    void deleteUser_whenUserDoesNotExist_shouldThrowUserNotFoundException() {
        when(userRepository.existsById(99L)).thenReturn(false);

        assertThrows(UserNotFoundException.class, () -> {
            adminUserService.deleteUser(99L);
        });
        verify(userRepository).existsById(99L);
        verify(userRepository, never()).deleteById(anyLong());
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\test\java\com\example\bankcards\service\AuthServiceTest.java
================================================================================

package com.example.bankcards.service;

import com.example.bankcards.exception.user.AuthenticationFailedException;
import com.example.bankcards.exception.user.DuplicateUsernameException;
import com.example.bankcards.model.dto.auth.AuthResponseDto;
import com.example.bankcards.model.entity.RefreshToken;
import com.example.bankcards.model.entity.User;
import com.example.bankcards.model.entity.enums.Role;
import com.example.bankcards.repository.RefreshTokenRepository;
import com.example.bankcards.repository.UserRepository;
import com.example.bankcards.security.JwtUtil;
import com.example.bankcards.service.auth.AuthService;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.security.crypto.password.PasswordEncoder;

import java.time.Instant;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class AuthServiceTest {

    @Mock
    private UserRepository userRepository;
    @Mock
    private PasswordEncoder passwordEncoder;
    @Mock
    private RefreshTokenRepository refreshTokenRepository;
    @Mock
    private JwtUtil jwtUtil;

    @InjectMocks
    private AuthService authService;

    private User testUser;

    @BeforeEach
    void setUp() {
        testUser = new User("testuser", "test@example.com", "encodedPassword", Role.ROLE_USER);
        testUser.setId(1L);
    }

    @Test
    void login_withValidCredentials_shouldReturnAuthResponseDto() {
        when(userRepository.findByUsername("testuser")).thenReturn(Optional.of(testUser));
        when(passwordEncoder.matches("password", "encodedPassword")).thenReturn(true);
        when(jwtUtil.generateToken(anyString(), anyString())).thenReturn("accessToken");
        when(jwtUtil.generateRefreshTokenString()).thenReturn("refreshTokenString");
        when(jwtUtil.getRefreshTokenExpiration()).thenReturn(3600000L);
        when(refreshTokenRepository.save(any(RefreshToken.class))).thenAnswer(invocation -> invocation.getArgument(0));

        AuthResponseDto response = authService.login("testuser", "password");

        assertNotNull(response);
        assertEquals("accessToken", response.getAccessToken());
        assertNotNull(response.getRefreshToken());
        verify(userRepository).findByUsername("testuser");
        verify(passwordEncoder).matches("password", "encodedPassword");
        verify(refreshTokenRepository).save(any(RefreshToken.class));
    }

    @Test
    void login_withInvalidUsername_shouldThrowAuthenticationFailedException() {
        when(userRepository.findByUsername("wronguser")).thenReturn(Optional.empty());

        assertThrows(AuthenticationFailedException.class, () -> {
            authService.login("wronguser", "password");
        });
        verify(userRepository).findByUsername("wronguser");
        verify(passwordEncoder, never()).matches(anyString(), anyString());
    }

    @Test
    void login_withInvalidPassword_shouldThrowAuthenticationFailedException() {
        when(userRepository.findByUsername("testuser")).thenReturn(Optional.of(testUser));
        when(passwordEncoder.matches("wrongpassword", "encodedPassword")).thenReturn(false);

        assertThrows(AuthenticationFailedException.class, () -> {
            authService.login("testuser", "wrongpassword");
        });
        verify(userRepository).findByUsername("testuser");
        verify(passwordEncoder).matches("wrongpassword", "encodedPassword");
    }

    @Test
    void register_withNewUsername_shouldReturnAuthResponseDto() {
        when(userRepository.findByUsername("newuser")).thenReturn(Optional.empty());
        when(passwordEncoder.encode("newpassword")).thenReturn("encodedNewPassword");
        when(userRepository.save(any(User.class))).thenAnswer(invocation -> {
            User user = invocation.getArgument(0);
            user.setId(2L);
            return user;
        });
        when(jwtUtil.generateToken(anyString(), anyString())).thenReturn("accessToken");
        when(jwtUtil.generateRefreshTokenString()).thenReturn("refreshTokenString");
        when(jwtUtil.getRefreshTokenExpiration()).thenReturn(3600000L);
        when(refreshTokenRepository.save(any(RefreshToken.class))).thenAnswer(invocation -> invocation.getArgument(0));

        AuthResponseDto response = authService.register("newuser", "new@example.com", "newpassword");

        assertNotNull(response);
        assertEquals("accessToken", response.getAccessToken());
        assertNotNull(response.getRefreshToken());
        verify(userRepository).findByUsername("newuser");
        verify(passwordEncoder).encode("newpassword");
        verify(userRepository).save(any(User.class));
        verify(refreshTokenRepository).save(any(RefreshToken.class));
    }

    @Test
    void register_withExistingUsername_shouldThrowDuplicateUsernameException() {
        when(userRepository.findByUsername("testuser")).thenReturn(Optional.of(testUser));

        assertThrows(DuplicateUsernameException.class, () -> {
            authService.register("testuser", "test@example.com", "password");
        });
        verify(userRepository).findByUsername("testuser");
        verify(userRepository, never()).save(any(User.class));
    }

    @Test
    void refreshAccessToken_withValidToken_shouldReturnNewAuthResponseDto() {
        RefreshToken refreshToken = new RefreshToken(1L, "validToken", Instant.now().plusSeconds(3600), testUser);
        when(refreshTokenRepository.findByToken("validToken")).thenReturn(Optional.of(refreshToken));
        when(jwtUtil.generateToken(anyString(), anyString())).thenReturn("newAccessToken");
        when(jwtUtil.generateRefreshTokenString()).thenReturn("newRefreshTokenString");
        when(jwtUtil.getRefreshTokenExpiration()).thenReturn(3600000L);
        when(refreshTokenRepository.save(any(RefreshToken.class))).thenAnswer(invocation -> invocation.getArgument(0));

        AuthResponseDto response = authService.refreshAccessToken("validToken");

        assertNotNull(response);
        assertEquals("newAccessToken", response.getAccessToken());
        assertNotNull(response.getRefreshToken());
        verify(refreshTokenRepository).findByToken("validToken");
        verify(refreshTokenRepository).delete(refreshToken);
        verify(refreshTokenRepository).save(any(RefreshToken.class));
    }

    @Test
    void refreshAccessToken_withInvalidToken_shouldThrowRuntimeException() {
        when(refreshTokenRepository.findByToken("invalidToken")).thenReturn(Optional.empty());

        assertThrows(RuntimeException.class, () -> {
            authService.refreshAccessToken("invalidToken");
        });
    }

    @Test
    void refreshAccessToken_withExpiredToken_shouldThrowRuntimeException() {
        RefreshToken expiredToken = new RefreshToken(1L, "expiredToken", Instant.now().minusSeconds(3600), testUser);
        when(refreshTokenRepository.findByToken("expiredToken")).thenReturn(Optional.of(expiredToken));

        assertThrows(RuntimeException.class, () -> {
            authService.refreshAccessToken("expiredToken");
        });
        verify(refreshTokenRepository).delete(expiredToken);
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\test\java\com\example\bankcards\service\card\CardServiceTest.java
================================================================================

package com.example.bankcards.service.card;

import com.example.bankcards.exception.card.CardNotFoundException;
import com.example.bankcards.exception.user.UserNotFoundException;
import com.example.bankcards.model.dto.card.CardCreateRequest;
import com.example.bankcards.model.dto.card.CardResponseDto;
import com.example.bankcards.model.dto.card.CardUpdateRequest;
import com.example.bankcards.model.entity.Card;
import com.example.bankcards.model.entity.User;
import com.example.bankcards.model.entity.enums.CardStatus;
import com.example.bankcards.model.entity.enums.Role;
import com.example.bankcards.repository.CardRepository;
import com.example.bankcards.repository.UserRepository;
import com.example.bankcards.util.mapper.CardMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.security.core.userdetails.UsernameNotFoundException;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.Collections;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class CardServiceTest {

    @Mock
    private CardRepository cardRepository;

    @Mock
    private UserRepository userRepository;

    @Mock
    private CardEncryptionService cardEncryptionService;

    @Mock
    private CardMapper cardMapper;

    @InjectMocks
    private CardService cardService;

    private User testUser;
    private Card testCard;
    private CardResponseDto testCardResponseDto;

    @BeforeEach
    void setUp() {
        testUser = new User("testuser", "test@example.com", "password", Role.ROLE_USER);
        testUser.setId(1L);

        testCard = new Card();
        testCard.setId(1L);
        testCard.setCardNumber("encrypted-1234");
        testCard.setCardHolder("Test User");
        testCard.setExpiryDate(LocalDate.of(2025, 12, 31));
        testCard.setBalance(BigDecimal.valueOf(1000.00));
        testCard.setCardStatus(CardStatus.ACTIVE);
        testCard.setUser(testUser);

        testCardResponseDto = new CardResponseDto();
        testCardResponseDto.setId(1L);
        testCardResponseDto.setCardNumber("masked-1234");
        testCardResponseDto.setCardHolder("Test User");
        testCardResponseDto.setExpiryDate(LocalDate.of(2025, 12, 31));
        testCardResponseDto.setBalance(BigDecimal.valueOf(1000.00));
        testCardResponseDto.setCardStatus(CardStatus.ACTIVE);
        testCardResponseDto.setUsername(testUser.getUsername());
    }

    @Test
    void createCard_shouldReturnCardResponseDto() {
        CardCreateRequest request = new CardCreateRequest(
                "1234567890123456",
                "Test User",
                LocalDate.of(2025, 12, 31),
                BigDecimal.valueOf(500.00),
                1L
        );

        CardResponseDto mapperReturnDto = new CardResponseDto();
        mapperReturnDto.setId(1L);
        mapperReturnDto.setCardHolder("Test User");
        mapperReturnDto.setExpiryDate(LocalDate.of(2025, 12, 31));
        mapperReturnDto.setBalance(BigDecimal.valueOf(1000.00));
        mapperReturnDto.setCardStatus(CardStatus.ACTIVE);
        mapperReturnDto.setUsername(testUser.getUsername());

        when(userRepository.findById(1L)).thenReturn(Optional.of(testUser));
        when(cardEncryptionService.encryptCardNumber(request.getCardNumber())).thenReturn("encrypted-1234");
        when(cardRepository.save(any(Card.class))).thenReturn(testCard);

        when(cardMapper.toCardResponseDto(any(Card.class))).thenReturn(mapperReturnDto);
        when(cardEncryptionService.getMaskedCardNumber("encrypted-1234")).thenReturn("masked-1234");


        CardResponseDto result = cardService.createCard(request);

        assertNotNull(result);
        assertEquals(testCardResponseDto.getId(), result.getId());
        assertEquals(testCardResponseDto.getCardHolder(), result.getCardHolder());
        assertEquals(testCardResponseDto.getCardNumber(), result.getCardNumber());
        verify(userRepository).findById(1L);
        verify(cardEncryptionService).encryptCardNumber("1234567890123456");
        verify(cardRepository).save(any(Card.class));
        verify(cardMapper).toCardResponseDto(any(Card.class));
        verify(cardEncryptionService).getMaskedCardNumber("encrypted-1234");
    }

    @Test
    void createCard_whenUserNotFound_shouldThrowUsernameNotFoundException() {
        CardCreateRequest request = new CardCreateRequest(
                "1234567890123456",
                "Test User",
                LocalDate.of(2025, 12, 31),
                BigDecimal.valueOf(500.00),
                99L
        );

        when(userRepository.findById(99L)).thenReturn(Optional.empty());

        assertThrows(UserNotFoundException.class, () -> cardService.createCard(request));
        verify(userRepository).findById(99L);
        verifyNoInteractions(cardEncryptionService, cardRepository, cardMapper);
    }

    @Test
    void getAllCards_shouldReturnPageOfCardResponseDto() {
        Pageable pageable = PageRequest.of(0, 10);
        Page<Card> cardPage = new PageImpl<>(Collections.singletonList(testCard), pageable, 1);

        CardResponseDto mapperReturnDto = new CardResponseDto();
        mapperReturnDto.setId(1L);
        mapperReturnDto.setCardHolder("Test User");
        mapperReturnDto.setExpiryDate(LocalDate.of(2025, 12, 31));
        mapperReturnDto.setBalance(BigDecimal.valueOf(1000.00));
        mapperReturnDto.setCardStatus(CardStatus.ACTIVE);
        mapperReturnDto.setUsername(testUser.getUsername());

        when(cardRepository.findAll(pageable)).thenReturn(cardPage);
        when(cardMapper.toCardResponseDto(testCard)).thenReturn(mapperReturnDto);
        when(cardEncryptionService.getMaskedCardNumber("encrypted-1234")).thenReturn("masked-1234");

        Page<CardResponseDto> result = cardService.getAllCards(pageable);

        assertNotNull(result);
        assertFalse(result.isEmpty());
        assertEquals(1, result.getTotalElements());
        assertEquals(testCardResponseDto.getId(), result.getContent().get(0).getId());
        assertEquals(testCardResponseDto.getCardNumber(), result.getContent().get(0).getCardNumber());
        verify(cardRepository).findAll(pageable);
        verify(cardMapper).toCardResponseDto(testCard);
        verify(cardEncryptionService).getMaskedCardNumber("encrypted-1234");
    }

    @Test
    void getCardById_whenCardExists_shouldReturnCardResponseDto() {
        CardResponseDto mapperReturnDto = new CardResponseDto();
        mapperReturnDto.setId(1L);
        mapperReturnDto.setCardHolder("Test User");
        mapperReturnDto.setExpiryDate(LocalDate.of(2025, 12, 31));
        mapperReturnDto.setBalance(BigDecimal.valueOf(1000.00));
        mapperReturnDto.setCardStatus(CardStatus.ACTIVE);
        mapperReturnDto.setUsername(testUser.getUsername());

        when(cardRepository.findById(1L)).thenReturn(Optional.of(testCard));
        when(cardMapper.toCardResponseDto(testCard)).thenReturn(mapperReturnDto);
        when(cardEncryptionService.getMaskedCardNumber("encrypted-1234")).thenReturn("masked-1234");

        CardResponseDto result = cardService.getCardById(1L);

        assertNotNull(result);
        assertEquals(testCardResponseDto.getId(), result.getId());
        assertEquals(testCardResponseDto.getCardNumber(), result.getCardNumber());
        verify(cardRepository).findById(1L);
        verify(cardMapper).toCardResponseDto(testCard);
        verify(cardEncryptionService).getMaskedCardNumber("encrypted-1234");
    }

    @Test
    void getCardById_whenCardDoesNotExist_shouldThrowCardNotFoundException() {
        when(cardRepository.findById(99L)).thenReturn(Optional.empty());

        assertThrows(CardNotFoundException.class, () -> cardService.getCardById(99L));
        verify(cardRepository).findById(99L);
        verifyNoInteractions(cardMapper, cardEncryptionService);
    }

    @Test
    void updateCard_shouldUpdateAndReturnCardResponseDto() {
        CardUpdateRequest request = new CardUpdateRequest();
        request.setCardHolder("Updated Holder");
        request.setCardStatus(CardStatus.BLOCKED);
        request.setBalance(BigDecimal.valueOf(1200.00));

        testCard.setCardHolder(request.getCardHolder());
        testCard.setCardStatus(request.getCardStatus());
        testCard.setBalance(request.getBalance());

        CardResponseDto mapperReturnDto = new CardResponseDto();
        mapperReturnDto.setId(testCard.getId());
        mapperReturnDto.setCardHolder(testCard.getCardHolder());
        mapperReturnDto.setCardStatus(testCard.getCardStatus());
        mapperReturnDto.setBalance(testCard.getBalance());
        mapperReturnDto.setExpiryDate(testCard.getExpiryDate());
        mapperReturnDto.setUsername(testCard.getUser().getUsername());

        when(cardRepository.findById(1L)).thenReturn(Optional.of(testCard));
        when(cardRepository.save(any(Card.class))).thenReturn(testCard);
        when(cardMapper.toCardResponseDto(any(Card.class))).thenReturn(mapperReturnDto);
        when(cardEncryptionService.getMaskedCardNumber("encrypted-1234")).thenReturn("masked-1234");

        CardResponseDto result = cardService.updateCard(1L, request);

        assertNotNull(result);
        assertEquals("Updated Holder", result.getCardHolder());
        assertEquals(CardStatus.BLOCKED, result.getCardStatus());
        assertEquals(BigDecimal.valueOf(1200.00), result.getBalance());
        assertEquals("masked-1234", result.getCardNumber());
        verify(cardRepository).findById(1L);
        verify(cardRepository).save(testCard);
        verify(cardMapper).toCardResponseDto(any(Card.class));
        verify(cardEncryptionService).getMaskedCardNumber("encrypted-1234");
    }

    @Test
    void updateCard_whenCardDoesNotExist_shouldThrowCardNotFoundException() {
        CardUpdateRequest request = new CardUpdateRequest();
        when(cardRepository.findById(99L)).thenReturn(Optional.empty());

        assertThrows(CardNotFoundException.class, () -> cardService.updateCard(99L, request));
        verify(cardRepository).findById(99L);
        verifyNoMoreInteractions(cardRepository, cardMapper, cardEncryptionService);
    }

    @Test
    void deleteCard_shouldDeleteCard() {
        when(cardRepository.findById(1L)).thenReturn(Optional.of(testCard));
        doNothing().when(cardRepository).delete(testCard);

        cardService.deleteCard(1L);

        verify(cardRepository).findById(1L);
        verify(cardRepository).delete(testCard);
    }

    @Test
    void deleteCard_whenCardDoesNotExist_shouldThrowCardNotFoundException() {
        when(cardRepository.findById(99L)).thenReturn(Optional.empty());

        assertThrows(CardNotFoundException.class, () -> cardService.deleteCard(99L));
        verify(cardRepository).findById(99L);
        verify(cardRepository, never()).delete(any(Card.class));
    }

    @Test
    void blockCard_shouldSetStatusToBlockedAndReturnDto() {
        testCard.setCardStatus(CardStatus.BLOCKED);

        CardResponseDto mapperReturnDto = new CardResponseDto();
        mapperReturnDto.setId(testCard.getId());
        mapperReturnDto.setCardStatus(testCard.getCardStatus());
        mapperReturnDto.setCardHolder(testCard.getCardHolder());
        mapperReturnDto.setExpiryDate(testCard.getExpiryDate());
        mapperReturnDto.setBalance(testCard.getBalance());
        mapperReturnDto.setUsername(testCard.getUser().getUsername());

        when(cardRepository.findById(1L)).thenReturn(Optional.of(testCard));
        when(cardRepository.save(any(Card.class))).thenReturn(testCard);
        when(cardMapper.toCardResponseDto(any(Card.class))).thenReturn(mapperReturnDto);
        when(cardEncryptionService.getMaskedCardNumber("encrypted-1234")).thenReturn("masked-1234");

        CardResponseDto result = cardService.blockCard(1L);

        assertNotNull(result);
        assertEquals(CardStatus.BLOCKED, result.getCardStatus());
        assertEquals("masked-1234", result.getCardNumber());
        verify(cardRepository).findById(1L);
        verify(cardRepository).save(testCard);
        assertEquals(CardStatus.BLOCKED, testCard.getCardStatus());
        verify(cardEncryptionService).getMaskedCardNumber("encrypted-1234");
    }

    @Test
    void blockCard_whenCardDoesNotExist_shouldThrowCardNotFoundException() {
        when(cardRepository.findById(99L)).thenReturn(Optional.empty());

        assertThrows(CardNotFoundException.class, () -> cardService.blockCard(99L));
        verify(cardRepository).findById(99L);
        verify(cardRepository, never()).save(any(Card.class));
        verifyNoInteractions(cardMapper, cardEncryptionService);
    }

    @Test
    void activateCard_shouldSetStatusToActiveAndReturnDto() {
        testCard.setCardStatus(CardStatus.BLOCKED);
        testCard.setCardStatus(CardStatus.ACTIVE);

        CardResponseDto mapperReturnDto = new CardResponseDto();
        mapperReturnDto.setId(testCard.getId());
        mapperReturnDto.setCardStatus(testCard.getCardStatus());
        mapperReturnDto.setCardHolder(testCard.getCardHolder());
        mapperReturnDto.setExpiryDate(testCard.getExpiryDate());
        mapperReturnDto.setBalance(testCard.getBalance());
        mapperReturnDto.setUsername(testUser.getUsername());

        when(cardRepository.findById(1L)).thenReturn(Optional.of(testCard));
        when(cardRepository.save(any(Card.class))).thenReturn(testCard);
        when(cardMapper.toCardResponseDto(any(Card.class))).thenReturn(mapperReturnDto);
        when(cardEncryptionService.getMaskedCardNumber("encrypted-1234")).thenReturn("masked-1234");

        CardResponseDto result = cardService.activateCard(1L);

        assertNotNull(result);
        assertEquals(CardStatus.ACTIVE, result.getCardStatus());
        assertEquals("masked-1234", result.getCardNumber());
        verify(cardRepository).findById(1L);
        verify(cardRepository).save(testCard);
        assertEquals(CardStatus.ACTIVE, testCard.getCardStatus());
        verify(cardEncryptionService).getMaskedCardNumber("encrypted-1234");
    }

    @Test
    void activateCard_whenCardDoesNotExist_shouldThrowCardNotFoundException() {
        when(cardRepository.findById(99L)).thenReturn(Optional.empty());

        assertThrows(CardNotFoundException.class, () -> cardService.activateCard(99L));
        verify(cardRepository).findById(99L);
        verify(cardRepository, never()).save(any(Card.class));
        verifyNoInteractions(cardMapper, cardEncryptionService);
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\test\java\com\example\bankcards\service\card\UserCardServiceTest.java
================================================================================

package com.example.bankcards.service.card;

import com.example.bankcards.exception.card.CardNotFoundException;
import com.example.bankcards.exception.card.CardStatusException;
import com.example.bankcards.exception.dto.ForbiddenException;
import com.example.bankcards.model.dto.card.CardResponseDto;
import com.example.bankcards.model.entity.Card;
import com.example.bankcards.model.entity.User;
import com.example.bankcards.model.entity.enums.CardStatus;
import com.example.bankcards.model.entity.enums.Role;
import com.example.bankcards.repository.CardRepository;
import com.example.bankcards.util.mapper.CardMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.Collections;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class UserCardServiceTest {

    @Mock
    private CardRepository cardRepository;

    @Mock
    private CardMapper cardMapper;

    @Mock
    private CardEncryptionService cardEncryptionService;

    @InjectMocks
    private UserCardService userCardService;

    private User testUser;
    private User anotherUser;
    private Card activeCard;
    private Card blockedCard;
    private CardResponseDto activeCardResponseDto;

    @BeforeEach
    void setUp() {
        testUser = new User("testuser", "test@example.com", "password", Role.ROLE_USER);
        testUser.setId(1L);

        anotherUser = new User("anotheruser", "another@example.com", "password", Role.ROLE_USER);
        anotherUser.setId(2L);

        activeCard = new Card();
        activeCard.setId(1L);
        activeCard.setCardNumber("encrypted-1111");
        activeCard.setCardHolder("Test User");
        activeCard.setExpiryDate(LocalDate.of(2025, 12, 31));
        activeCard.setBalance(BigDecimal.valueOf(1000.00));
        activeCard.setCardStatus(CardStatus.ACTIVE);
        activeCard.setUser(testUser);

        blockedCard = new Card();
        blockedCard.setId(2L);
        blockedCard.setCardNumber("encrypted-2222");
        blockedCard.setCardHolder("Test User");
        blockedCard.setExpiryDate(LocalDate.of(2026, 1, 1));
        blockedCard.setBalance(BigDecimal.valueOf(500.00));
        blockedCard.setCardStatus(CardStatus.BLOCKED);
        blockedCard.setUser(testUser);

        activeCardResponseDto = new CardResponseDto();
        activeCardResponseDto.setId(1L);
        activeCardResponseDto.setCardNumber("masked-1111");
        activeCardResponseDto.setCardHolder("Test User");
        activeCardResponseDto.setExpiryDate(LocalDate.of(2025, 12, 31));
        activeCardResponseDto.setBalance(BigDecimal.valueOf(1000.00));
        activeCardResponseDto.setCardStatus(CardStatus.ACTIVE);
        activeCardResponseDto.setUsername(testUser.getUsername());
    }

    @Test
    void getTotalBalance_whenNoActiveCards_shouldReturnZero() {
        when(cardRepository.findByUserUsername("testuser")).thenReturn(Collections.singletonList(blockedCard));

        BigDecimal totalBalance = userCardService.getTotalBalance("testuser");

        assertNotNull(totalBalance);
        assertEquals(BigDecimal.ZERO, totalBalance);
        verify(cardRepository).findByUserUsername("testuser");
    }

    @Test
    void getTotalBalance_whenNoCardsForUser_shouldReturnZero() {
        when(cardRepository.findByUserUsername("nonexistentuser")).thenReturn(Collections.emptyList());

        BigDecimal totalBalance = userCardService.getTotalBalance("nonexistentuser");

        assertNotNull(totalBalance);
        assertEquals(BigDecimal.ZERO, totalBalance);
        verify(cardRepository).findByUserUsername("nonexistentuser");
    }

    @Test
    void requestUnblock_whenCardNotFound_shouldThrowCardNotFoundException() {
        when(cardRepository.findById(99L)).thenReturn(Optional.empty());

        assertThrows(CardNotFoundException.class, () -> userCardService.requestUnblock(99L, "testuser"));
        verify(cardRepository).findById(99L);
        verifyNoInteractions(cardEncryptionService);
    }

    @Test
    void requestUnblock_whenCardDoesNotBelongToUser_shouldThrowForbiddenException() {
        Card cardOfAnotherUser = new Card();
        cardOfAnotherUser.setId(3L);
        cardOfAnotherUser.setUser(anotherUser);
        cardOfAnotherUser.setCardNumber("encrypted-3333");
        cardOfAnotherUser.setCardStatus(CardStatus.BLOCKED);

        when(cardRepository.findById(3L)).thenReturn(Optional.of(cardOfAnotherUser));

        assertThrows(ForbiddenException.class, () -> userCardService.requestUnblock(3L, "testuser"));
        verify(cardRepository).findById(3L);
        verifyNoInteractions(cardEncryptionService);
    }

    @Test
    void requestUnblock_whenCardIsNotBlocked_shouldThrowCardNotBlockedException() {
        when(cardRepository.findById(1L)).thenReturn(Optional.of(activeCard));

        assertThrows(CardStatusException.class, () -> userCardService.requestUnblock(1L, "testuser"));
        verify(cardRepository).findById(1L);
        verifyNoInteractions(cardEncryptionService);
    }

    @Test
    void requestUnblock_shouldLogUnblockRequest() {
        when(cardRepository.findById(2L)).thenReturn(Optional.of(blockedCard));
        when(cardEncryptionService.getMaskedCardNumber("encrypted-2222")).thenReturn("masked-2222");

        assertDoesNotThrow(() -> userCardService.requestUnblock(2L, "testuser"));
        verify(cardRepository).findById(2L);
        verify(cardEncryptionService).getMaskedCardNumber("encrypted-2222");
    }

    @Test
    void requestBlock_shouldLogBlockRequest() {
        when(cardRepository.findById(1L)).thenReturn(Optional.of(activeCard));
        when(cardEncryptionService.getMaskedCardNumber("encrypted-1111")).thenReturn("masked-1111");

        assertDoesNotThrow(() -> userCardService.requestBlock(1L, "testuser"));
        verify(cardRepository).findById(1L);
        verify(cardEncryptionService).getMaskedCardNumber("encrypted-1111");
    }

    @Test
    void requestBlock_whenCardNotFound_shouldThrowCardNotFoundException() {
        when(cardRepository.findById(99L)).thenReturn(Optional.empty());

        assertThrows(CardNotFoundException.class, () -> userCardService.requestBlock(99L, "testuser"));
        verify(cardRepository).findById(99L);
        verifyNoInteractions(cardEncryptionService);
    }

    @Test
    void requestBlock_whenCardDoesNotBelongToUser_shouldThrowForbiddenException() {
        Card cardOfAnotherUser = new Card();
        cardOfAnotherUser.setId(3L);
        cardOfAnotherUser.setUser(anotherUser);
        cardOfAnotherUser.setCardNumber("encrypted-3333");
        cardOfAnotherUser.setCardStatus(CardStatus.ACTIVE);

        when(cardRepository.findById(3L)).thenReturn(Optional.of(cardOfAnotherUser));

        assertThrows(ForbiddenException.class, () -> userCardService.requestBlock(3L, "testuser"));
        verify(cardRepository).findById(3L);
        verifyNoInteractions(cardEncryptionService);
    }

    @Test
    void requestBlock_whenCardIsAlreadyBlocked_shouldThrowCardBlockedException() {
        when(cardRepository.findById(2L)).thenReturn(Optional.of(blockedCard));

        assertThrows(CardStatusException.class, () -> userCardService.requestBlock(2L, "testuser"));
        verify(cardRepository).findById(2L);
        verifyNoInteractions(cardEncryptionService);
    }

    @Test
    void getUserCards_shouldReturnPageOfCardResponseDto() {
        Pageable pageable = PageRequest.of(0, 10);
        Page<Card> cardPage = new PageImpl<>(Collections.singletonList(activeCard), pageable, 1);

        CardResponseDto mapperReturnDto = new CardResponseDto();
        mapperReturnDto.setId(1L);
        mapperReturnDto.setCardHolder("Test User");
        mapperReturnDto.setExpiryDate(LocalDate.of(2025, 12, 31));
        mapperReturnDto.setBalance(BigDecimal.valueOf(1000.00));
        mapperReturnDto.setCardStatus(CardStatus.ACTIVE);
        mapperReturnDto.setUsername(testUser.getUsername());

        when(cardRepository.findByUserUsernamePageable("testuser", pageable)).thenReturn(cardPage);
        when(cardMapper.toCardResponseDto(activeCard)).thenReturn(mapperReturnDto);
        when(cardEncryptionService.getMaskedCardNumber("encrypted-1111")).thenReturn("masked-1111");

        Page<CardResponseDto> result = userCardService.getUserCards("testuser", pageable);

        assertNotNull(result);
        assertFalse(result.isEmpty());
        assertEquals(1, result.getTotalElements());
        assertEquals(activeCardResponseDto.getId(), result.getContent().getFirst().getId());
        assertEquals(activeCardResponseDto.getCardNumber(), result.getContent().getFirst().getCardNumber());
        verify(cardRepository).findByUserUsernamePageable("testuser", pageable);
        verify(cardMapper).toCardResponseDto(activeCard);
        verify(cardEncryptionService).getMaskedCardNumber("encrypted-1111");
    }

    @Test
    void getUserCardById_whenCardExistsAndBelongsToUser_shouldReturnCardResponseDto() {
        CardResponseDto mapperReturnDto = new CardResponseDto();
        mapperReturnDto.setId(1L);
        mapperReturnDto.setCardHolder("Test User");
        mapperReturnDto.setExpiryDate(LocalDate.of(2025, 12, 31));
        mapperReturnDto.setBalance(BigDecimal.valueOf(1000.00));
        mapperReturnDto.setCardStatus(CardStatus.ACTIVE);
        mapperReturnDto.setUsername(testUser.getUsername());

        when(cardRepository.findById(1L)).thenReturn(Optional.of(activeCard));
        when(cardMapper.toCardResponseDto(activeCard)).thenReturn(mapperReturnDto);
        when(cardEncryptionService.getMaskedCardNumber("encrypted-1111")).thenReturn("masked-1111");

        CardResponseDto result = userCardService.getUserCardById(1L, "testuser");

        assertNotNull(result);
        assertEquals(activeCardResponseDto.getId(), result.getId());
        assertEquals(activeCardResponseDto.getCardNumber(), result.getCardNumber());
        verify(cardRepository).findById(1L);
        verify(cardMapper).toCardResponseDto(activeCard);
        verify(cardEncryptionService).getMaskedCardNumber("encrypted-1111");
    }

    @Test
    void getUserCardById_whenCardNotFound_shouldThrowCardNotFoundException() {
        when(cardRepository.findById(99L)).thenReturn(Optional.empty());

        assertThrows(CardNotFoundException.class, () -> userCardService.getUserCardById(99L, "testuser"));
        verify(cardRepository).findById(99L);
        verifyNoInteractions(cardMapper, cardEncryptionService);
    }

    @Test
    void getUserCardById_whenCardDoesNotBelongToUser_shouldThrowForbiddenException() {
        Card cardOfAnotherUser = new Card();
        cardOfAnotherUser.setId(3L);
        cardOfAnotherUser.setUser(anotherUser);
        cardOfAnotherUser.setCardNumber("encrypted-3333");

        when(cardRepository.findById(3L)).thenReturn(Optional.of(cardOfAnotherUser));

        assertThrows(ForbiddenException.class, () -> userCardService.getUserCardById(3L, "testuser"));
        verify(cardRepository).findById(3L);
        verifyNoInteractions(cardMapper, cardEncryptionService);
    }
}


================================================================================
ФАЙЛ: D:\TeskTaskBank\Bank_REST\.\src\test\java\com\example\bankcards\service\transfer\TransferServiceTest.java
================================================================================

package com.example.bankcards.service.transfer;

import com.example.bankcards.exception.card.CardNotFoundException;
import com.example.bankcards.exception.card.CardOwnershipException;
import com.example.bankcards.exception.card.CardStatusException;
import com.example.bankcards.exception.card.InsufficientFundsException;
import com.example.bankcards.exception.dto.ForbiddenException;
import com.example.bankcards.exception.dto.ResourceNotFoundException;
import com.example.bankcards.exception.transfer.InvalidTransferException;
import com.example.bankcards.model.dto.transfer.TransferRequest;
import com.example.bankcards.model.dto.transfer.TransferResponseDto;
import com.example.bankcards.model.entity.Card;
import com.example.bankcards.model.entity.Transfer;
import com.example.bankcards.model.entity.User;
import com.example.bankcards.model.entity.enums.CardStatus;
import com.example.bankcards.model.entity.enums.Role;
import com.example.bankcards.model.entity.enums.TransferStatus;
import com.example.bankcards.repository.CardRepository;
import com.example.bankcards.repository.TransferRepository;
import com.example.bankcards.service.card.CardEncryptionService;
import com.example.bankcards.util.mapper.TransferMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.Collections;
import java.util.List;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class TransferServiceTest {

    @Mock
    private CardRepository cardRepository;
    @Mock
    private TransferRepository transferRepository;
    @Mock
    private CardEncryptionService cardEncryptionService;
    @Mock
    private TransferMapper transferMapper;

    @InjectMocks
    private TransferService transferService;

    private User testUser;
    private User anotherUser;
    private Card fromCard;
    private Card toCard;
    private TransferRequest transferRequest;

    @BeforeEach
    void setUp() {
        testUser = new User("testuser", "test@example.com", "pass", Role.ROLE_USER);
        testUser.setId(1L);

        anotherUser = new User("anotheruser", "another@example.com", "pass", Role.ROLE_USER);
        anotherUser.setId(2L);

        fromCard = new Card();
        fromCard.setId(1L);
        fromCard.setCardNumber("encrypted_1234");
        fromCard.setBalance(new BigDecimal("1000.00"));
        fromCard.setCardHolder("Test User");
        fromCard.setExpiryDate(LocalDateTime.now().toLocalDate().plusYears(1));
        fromCard.setCardStatus(CardStatus.ACTIVE);
        fromCard.setUser(testUser);

        toCard = new Card();
        toCard.setId(2L);
        toCard.setCardNumber("encrypted_5678");
        toCard.setBalance(new BigDecimal("500.00"));
        toCard.setCardHolder("Test User");
        toCard.setExpiryDate(LocalDateTime.now().toLocalDate().plusYears(1));
        toCard.setCardStatus(CardStatus.ACTIVE);
        toCard.setUser(testUser);

        transferRequest = new TransferRequest();

        lenient().when(cardEncryptionService.matchesCardNumber("plain_1234", "encrypted_1234")).thenReturn(true);
        lenient().when(cardEncryptionService.matchesCardNumber("plain_5678", "encrypted_5678")).thenReturn(true);
        lenient().when(cardEncryptionService.matchesCardNumber("plain_9999", "encrypted_9999")).thenReturn(true);
    }

    @Test
    void createTransfer_whenValid_shouldSucceed() {
        transferRequest.setFromCardId(1L);
        transferRequest.setToCardNumber("plain_5678");
        transferRequest.setAmount(new BigDecimal("100.00"));

        TransferResponseDto mapperReturnDto = new TransferResponseDto();
        mapperReturnDto.setFromCardNumber("masked_1234");
        mapperReturnDto.setToCardNumber("masked_5678");
        mapperReturnDto.setAmount(transferRequest.getAmount());
        mapperReturnDto.setStatus(TransferStatus.SUCCESS);

        when(cardRepository.findById(1L)).thenReturn(Optional.of(fromCard));
        when(cardRepository.findByUserUsername("testuser")).thenReturn(List.of(fromCard, toCard));

        when(cardEncryptionService.getMaskedCardNumber("encrypted_1234")).thenReturn("masked_1234");
        when(cardEncryptionService.getMaskedCardNumber("encrypted_5678")).thenReturn("masked_5678");

        when(transferRepository.save(any(Transfer.class))).thenAnswer(inv -> {
            Transfer savedTransfer = inv.getArgument(0);
            savedTransfer.setId(1L);
            savedTransfer.setFromCard(fromCard);
            savedTransfer.setToCard(toCard);
            return savedTransfer;
        });
        when(transferMapper.toTransferResponseDto(any(Transfer.class))).thenReturn(mapperReturnDto);

        TransferResponseDto result = transferService.createTransfer(transferRequest, "testuser");

        assertNotNull(result);
        assertEquals(new BigDecimal("900.00"), fromCard.getBalance());
        assertEquals(new BigDecimal("600.00"), toCard.getBalance());
        assertEquals("masked_1234", result.getFromCardNumber());
        assertEquals("masked_5678", result.getToCardNumber());
        verify(cardRepository, times(2)).save(any(Card.class));
        verify(transferRepository).save(any(Transfer.class));
    }

    @Test
    void createTransfer_whenInsufficientFunds_shouldThrowInsufficientFundsException() {
        transferRequest.setFromCardId(1L);
        transferRequest.setToCardNumber("plain_5678");
        transferRequest.setAmount(new BigDecimal("1100.00"));

        fromCard.setBalance(new BigDecimal("1000.00"));
        when(cardRepository.findById(1L)).thenReturn(Optional.of(fromCard));
        when(cardRepository.findByUserUsername("testuser")).thenReturn(List.of(fromCard, toCard));

        assertThrows(InsufficientFundsException.class, () -> transferService.createTransfer(transferRequest, "testuser"));
        verify(cardRepository, never()).save(any());
        verifyNoInteractions(transferMapper);
        verify(transferRepository, never()).save(any(Transfer.class));
    }

    @Test
    void createTransfer_whenFromCardBlocked_shouldThrowCardStatusException() {
        transferRequest.setFromCardId(1L);
        transferRequest.setToCardNumber("plain_5678");
        transferRequest.setAmount(new BigDecimal("100.00"));

        fromCard.setCardStatus(CardStatus.BLOCKED);
        when(cardRepository.findById(1L)).thenReturn(Optional.of(fromCard));

        assertThrows(CardStatusException.class, () -> transferService.createTransfer(transferRequest, "testuser"));
        verify(cardRepository, never()).save(any());
        verifyNoInteractions(transferMapper);
    }

    @Test
    void createTransfer_toSameCard_shouldThrowInvalidTransferException() {
        transferRequest.setFromCardId(1L);
        transferRequest.setToCardNumber("plain_1234");
        transferRequest.setAmount(new BigDecimal("100.00"));

        when(cardRepository.findById(1L)).thenReturn(Optional.of(fromCard));
        when(cardRepository.findByUserUsername("testuser")).thenReturn(List.of(fromCard, toCard));

        assertThrows(InvalidTransferException.class, () -> transferService.createTransfer(transferRequest, "testuser"));
        verify(cardRepository, never()).save(any());
        verifyNoInteractions(transferMapper);
    }

    @Test
    void createTransfer_whenUserNotOwnerOfFromCard_shouldThrowCardOwnershipException() {
        transferRequest.setFromCardId(1L);
        transferRequest.setToCardNumber("plain_5678");
        transferRequest.setAmount(new BigDecimal("100.00"));

        when(cardRepository.findById(1L)).thenReturn(Optional.of(fromCard));


        assertThrows(CardOwnershipException.class, () -> transferService.createTransfer(transferRequest, "wronguser"));
        verify(cardRepository, never()).save(any());
        verifyNoInteractions(transferMapper);
    }

    @Test
    void createTransfer_whenToCardNotFound_shouldThrowCardNotFoundException() {
        transferRequest.setFromCardId(1L);
        transferRequest.setToCardNumber("nonexistent_card_number");
        transferRequest.setAmount(new BigDecimal("100.00"));

        when(cardRepository.findById(1L)).thenReturn(Optional.of(fromCard));
        when(cardRepository.findByUserUsername("testuser")).thenReturn(Collections.singletonList(fromCard));

        assertThrows(CardNotFoundException.class, () -> transferService.createTransfer(transferRequest, "testuser"));
        verify(cardRepository, never()).save(any());
        verifyNoInteractions(transferMapper);
    }

    @Test
    void createTransfer_whenToCardDoesNotBelongToUser_shouldThrowCardNotFoundException() {
        Card cardOfAnotherUser = new Card();
        cardOfAnotherUser.setUser(anotherUser);
        cardOfAnotherUser.setCardNumber("encrypted_9999");

        transferRequest.setFromCardId(1L);
        transferRequest.setToCardNumber("plain_9999");
        transferRequest.setAmount(new BigDecimal("100.00"));

        when(cardRepository.findById(1L)).thenReturn(Optional.of(fromCard));
        when(cardRepository.findByUserUsername("testuser")).thenReturn(List.of(fromCard, toCard));

        assertThrows(CardNotFoundException.class, () -> transferService.createTransfer(transferRequest, "testuser"));
        verify(cardRepository, never()).save(any());
        verifyNoInteractions(transferMapper);
    }

    @Test
    void createTransfer_whenToCardBlocked_shouldThrowCardStatusException() {
        toCard.setCardStatus(CardStatus.BLOCKED);

        transferRequest.setFromCardId(1L);
        transferRequest.setToCardNumber("plain_5678");
        transferRequest.setAmount(new BigDecimal("100.00"));

        when(cardRepository.findById(1L)).thenReturn(Optional.of(fromCard));

        when(cardRepository.findByUserUsername("testuser")).thenReturn(List.of(fromCard, toCard));

        assertThrows(CardStatusException.class, () -> transferService.createTransfer(transferRequest, "testuser"));
        verify(cardRepository, never()).save(any());
        verifyNoInteractions(transferMapper);
    }


    @Test
    void getUserTransfers_shouldReturnListOfTransferResponseDto() {
        Transfer testTransfer = new Transfer();
        testTransfer.setFromCard(fromCard);
        testTransfer.setToCard(toCard);

        TransferResponseDto dto = new TransferResponseDto();
        dto.setFromCardNumber("masked_1234");
        dto.setToCardNumber("masked_5678");

        when(transferRepository.findByUserUsername("testuser")).thenReturn(Collections.singletonList(testTransfer));
        when(transferMapper.toTransferResponseDto(testTransfer)).thenReturn(dto);
        when(cardEncryptionService.getMaskedCardNumber(fromCard.getCardNumber())).thenReturn("masked_1234");
        when(cardEncryptionService.getMaskedCardNumber(toCard.getCardNumber())).thenReturn("masked_5678");

        List<TransferResponseDto> result = transferService.getUserTransfers("testuser");

        assertFalse(result.isEmpty());
        assertEquals(1, result.size());
        assertEquals("masked_1234", result.getFirst().getFromCardNumber());
        assertEquals("masked_5678", result.getFirst().getToCardNumber());
        verify(transferRepository).findByUserUsername("testuser");
    }

    @Test
    void getCardTransfers_shouldReturnListOfTransferResponseDto() {
        Transfer testTransfer = new Transfer();
        testTransfer.setFromCard(fromCard);
        testTransfer.setToCard(toCard);

        TransferResponseDto dto = new TransferResponseDto();
        dto.setFromCardNumber("masked_1234");
        dto.setToCardNumber("masked_5678");

        when(cardRepository.findById(1L)).thenReturn(Optional.of(fromCard));
        when(transferRepository.findByCardId(1L)).thenReturn(Collections.singletonList(testTransfer));
        when(transferMapper.toTransferResponseDto(testTransfer)).thenReturn(dto);
        when(cardEncryptionService.getMaskedCardNumber(fromCard.getCardNumber())).thenReturn("masked_1234");
        when(cardEncryptionService.getMaskedCardNumber(toCard.getCardNumber())).thenReturn("masked_5678");

        List<TransferResponseDto> result = transferService.getCardTransfers(1L, "testuser");

        assertFalse(result.isEmpty());
        assertEquals(1, result.size());
        verify(transferRepository).findByCardId(1L);
    }

    @Test
    void getCardTransfers_whenCardNotFound_shouldThrowCardNotFoundException() {
        when(cardRepository.findById(99L)).thenReturn(Optional.empty());

        assertThrows(CardNotFoundException.class, () -> transferService.getCardTransfers(99L, "testuser"));
        verifyNoInteractions(transferRepository, transferMapper);
    }

    @Test
    void getCardTransfers_whenCardDoesNotBelongToUser_shouldThrowForbiddenException() {
        fromCard.setUser(anotherUser);
        when(cardRepository.findById(1L)).thenReturn(Optional.of(fromCard));

        assertThrows(ForbiddenException.class, () -> transferService.getCardTransfers(1L, "testuser"));
        verifyNoInteractions(transferRepository, transferMapper);
    }

    @Test
    void getTransfer_shouldReturnTransferResponseDto() {
        Transfer testTransfer = new Transfer();
        testTransfer.setFromCard(fromCard);
        testTransfer.setToCard(toCard);

        TransferResponseDto dto = new TransferResponseDto();
        dto.setFromCardNumber("masked_1234");
        dto.setToCardNumber("masked_5678");

        when(transferRepository.findById(1L)).thenReturn(Optional.of(testTransfer));
        when(transferMapper.toTransferResponseDto(testTransfer)).thenReturn(dto);
        when(cardEncryptionService.getMaskedCardNumber(fromCard.getCardNumber())).thenReturn("masked_1234");
        when(cardEncryptionService.getMaskedCardNumber(toCard.getCardNumber())).thenReturn("masked_5678");

        TransferResponseDto result = transferService.getTransfer(1L, "testuser");

        assertNotNull(result);
        assertEquals("masked_1234", result.getFromCardNumber());
        verify(transferRepository).findById(1L);
    }

    @Test
    void getTransfer_whenTransferNotFound_shouldThrowResourceNotFoundException() {
        when(transferRepository.findById(99L)).thenReturn(Optional.empty());
        assertThrows(ResourceNotFoundException.class, () -> transferService.getTransfer(99L, "testuser"));
    }

    @Test
    void getTransfer_whenUserNotParticipant_shouldThrowForbiddenException() {
        Transfer testTransfer = new Transfer();
        testTransfer.setFromCard(fromCard);
        testTransfer.setToCard(toCard);

        when(transferRepository.findById(1L)).thenReturn(Optional.of(testTransfer));

        assertThrows(ForbiddenException.class, () -> transferService.getTransfer(1L, "anotheruser"));
        verifyNoInteractions(transferMapper, cardEncryptionService);
    }
}


